{"version":3,"sources":["../../../../src/streaming/Stream.js"],"names":[],"mappings":"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","file":"Stream.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport StreamProcessor from './StreamProcessor';\nimport EventController from './controllers/EventController';\nimport FragmentController from './controllers/FragmentController';\nimport ThumbnailController from './thumbnail/ThumbnailController';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport Debug from '../core/Debug';\nimport FactoryMaker from '../core/FactoryMaker';\n\nfunction Stream(config) {\n\n    const DATA_UPDATE_FAILED_ERROR_CODE = 1;\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    const manifestModel = config.manifestModel;\n    const dashManifestModel = config.dashManifestModel;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const manifestUpdater = config.manifestUpdater;\n    const adapter = config.adapter;\n    const capabilities = config.capabilities;\n    const errHandler = config.errHandler;\n    const timelineConverter = config.timelineConverter;\n    const metricsModel = config.metricsModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const mediaController = config.mediaController;\n    const textController = config.textController;\n    const videoModel = config.videoModel;\n\n    let instance,\n        logger,\n        streamProcessors,\n        isStreamActivated,\n        isMediaInitialized,\n        streamInfo,\n        updateError,\n        isUpdating,\n        protectionController,\n        fragmentController,\n        thumbnailController,\n        eventController,\n        preloaded,\n        trackChangedEvent;\n\n    const codecCompatibilityTable = [\n        {\n            'codec': 'avc1',\n            'compatibleCodecs': ['avc3']\n        },\n        {\n            'codec': 'avc3',\n            'compatibleCodecs': ['avc1']\n        }\n    ];\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n\n        fragmentController = FragmentController(context).create({\n            mediaPlayerModel: mediaPlayerModel,\n            metricsModel: metricsModel,\n            errHandler: errHandler\n        });\n\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    }\n\n    function initialize(StreamInfo, ProtectionController) {\n        streamInfo = StreamInfo;\n        protectionController = ProtectionController;\n        if (protectionController) {\n            eventBus.on(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.on(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.on(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.on(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.on(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.on(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    /**\n     * Activates Stream by re-initializing some of its components\n     * @param {MediaSource} mediaSource\n     * @memberof Stream#\n     * @param {SourceBuffer} previousBuffers\n     */\n    function activate(mediaSource, previousBuffers) {\n        if (!isStreamActivated) {\n            let result;\n            if (!getPreloaded()) {\n                result = initializeMedia(mediaSource, previousBuffers);\n            } else {\n                initializeAfterPreload();\n                result = previousBuffers;\n            }\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n            isStreamActivated = true;\n            return result;\n        }\n        return previousBuffers;\n    }\n\n    /**\n     * Partially resets some of the Stream elements\n     * @memberof Stream#\n     * @param {boolean} keepBuffers\n     */\n    function deactivate(keepBuffers) {\n        let ln = streamProcessors ? streamProcessors.length : 0;\n        const errored = false;\n        for (let i = 0; i < ln; i++) {\n            let fragmentModel = streamProcessors[i].getFragmentModel();\n            fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\n            streamProcessors[i].reset(errored, keepBuffers);\n        }\n        streamProcessors = [];\n        isStreamActivated = false;\n        isMediaInitialized = false;\n        setPreloaded(false);\n        eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n    }\n\n    function isActive() {\n        return isStreamActivated;\n    }\n\n    function setMediaSource(mediaSource) {\n        for (let i = 0; i < streamProcessors.length;) {\n            if (isMediaSupported(streamProcessors[i].getMediaInfo())) {\n                streamProcessors[i].setMediaSource(mediaSource);\n                i++;\n            } else {\n                streamProcessors[i].reset();\n                streamProcessors.splice(i,1);\n            }\n        }\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state\n            //so do this after the buffers are created above.\n            streamProcessors[i].dischargePreBuffer();\n        }\n\n        if (streamProcessors.length === 0) {\n            let msg = 'No streams to play.';\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\n            logger.fatal(msg);\n        }\n    }\n\n    function resetInitialSettings() {\n        deactivate();\n        streamInfo = null;\n        updateError = {};\n        isUpdating = false;\n    }\n\n    function reset() {\n\n        if (playbackController) {\n            playbackController.pause();\n        }\n\n        if (fragmentController) {\n            fragmentController.reset();\n            fragmentController = null;\n        }\n\n        resetInitialSettings();\n\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n        eventBus.off(Events.KEY_ERROR, onProtectionError, instance);\n        eventBus.off(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n        eventBus.off(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n        eventBus.off(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n        eventBus.off(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n        eventBus.off(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n\n        setPreloaded(false);\n    }\n\n    function getDuration() {\n        return streamInfo ? streamInfo.duration : NaN;\n    }\n\n    function getStartTime() {\n        return streamInfo ? streamInfo.start : NaN;\n    }\n\n    function getId() {\n        return streamInfo ? streamInfo.id : NaN;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function getEventController() {\n        return eventController;\n    }\n\n    function getFragmentController() {\n        return fragmentController;\n    }\n\n    function getThumbnailController() {\n        return thumbnailController;\n    }\n\n    function checkConfig() {\n        if (!abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) {\n            throw new Error('Missing config parameter(s)');\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @returns {Array}\n     * @memberof Stream#\n     */\n    function getBitrateListFor(type) {\n        checkConfig();\n        if (type === Constants.IMAGE) {\n            if (!thumbnailController) {\n                return [];\n            }\n            return thumbnailController.getBitrateList();\n        }\n        const mediaInfo = getMediaInfo(type);\n        return abrController.getBitrateList(mediaInfo);\n    }\n\n    function startEventController() {\n        if (eventController) {\n            eventController.start();\n        }\n    }\n\n    function stopEventController() {\n        if (eventController) {\n            eventController.stop();\n        }\n    }\n\n    function onProtectionError(event) {\n        if (event.error) {\n            errHandler.mediaKeySessionError(event.error);\n            logger.fatal(event.error);\n            reset();\n        }\n    }\n\n    function isMediaSupported(mediaInfo) {\n        const type = mediaInfo.type;\n        let codec,\n            msg;\n\n        if (type === Constants.MUXED && mediaInfo) {\n            msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines';\n            logger.fatal(msg);\n            errHandler.manifestError(msg, 'multiplexedrep', manifestModel.getValue());\n            return false;\n        }\n\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.EMBEDDED_TEXT || type === Constants.IMAGE) {\n            return true;\n        }\n        codec = mediaInfo.codec;\n        logger.debug(type + ' codec: ' + codec);\n\n        if (!!mediaInfo.contentProtection && !capabilities.supportsEncryptedMedia()) {\n            errHandler.capabilityError('encryptedmedia');\n        } else if (!capabilities.supportsCodec(codec)) {\n            msg = type + 'Codec (' + codec + ') is not supported.';\n            logger.error(msg);\n            return false;\n        }\n\n        return true;\n    }\n\n    function onCurrentTrackChanged(e) {\n        if (e.newMediaInfo.streamInfo.id !== streamInfo.id) return;\n\n        let processor = getProcessorForMediaInfo(e.newMediaInfo);\n        if (!processor) return;\n\n        let currentTime = playbackController.getTime();\n        logger.info('Stream -  Process track changed at current time ' + currentTime);\n        let mediaInfo = e.newMediaInfo;\n        let manifest = manifestModel.getValue();\n\n        logger.debug('Stream -  Update stream controller');\n        if (manifest.refreshManifestOnSwitchTrack) {\n            logger.debug('Stream -  Refreshing manifest for switch track');\n            trackChangedEvent = e;\n            manifestUpdater.refreshManifest();\n        } else {\n            processor.selectMediaInfo(mediaInfo);\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\n                abrController.updateTopQualityIndex(mediaInfo);\n                processor.switchTrackAsked();\n                processor.getFragmentModel().abortRequests();\n            } else {\n                processor.getScheduleController().setSeekTarget(NaN);\n                adapter.setIndexHandlerTime(processor, currentTime);\n                adapter.resetIndexHandler(processor);\n            }\n        }\n    }\n\n    function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) {\n        let streamProcessor = StreamProcessor(context).create({\n            type: mediaInfo.type,\n            mimeType: mediaInfo.mimeType,\n            timelineConverter: timelineConverter,\n            adapter: adapter,\n            manifestModel: manifestModel,\n            dashManifestModel: dashManifestModel,\n            mediaPlayerModel: mediaPlayerModel,\n            metricsModel: metricsModel,\n            dashMetrics: config.dashMetrics,\n            baseURLController: config.baseURLController,\n            stream: instance,\n            abrController: abrController,\n            domStorage: config.domStorage,\n            playbackController: playbackController,\n            mediaController: mediaController,\n            streamController: config.streamController,\n            textController: textController,\n            errHandler: errHandler\n        });\n\n        streamProcessor.initialize(mediaSource);\n        abrController.updateTopQualityIndex(mediaInfo);\n\n        if (optionalSettings) {\n            streamProcessor.setBuffer(optionalSettings.buffer);\n            streamProcessor.getIndexHandler().setCurrentTime(optionalSettings.currentTime);\n            streamProcessors[optionalSettings.replaceIdx] = streamProcessor;\n        } else {\n            streamProcessors.push(streamProcessor);\n        }\n\n        if (optionalSettings && optionalSettings.ignoreMediaInfo) {\n            return;\n        }\n\n        if ((mediaInfo.type === Constants.TEXT || mediaInfo.type === Constants.FRAGMENTED_TEXT)) {\n            let idx;\n            for (let i = 0; i < allMediaForType.length; i++) {\n                if (allMediaForType[i].index === mediaInfo.index) {\n                    idx = i;\n                }\n                streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor\n            }\n            streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info\n        } else {\n            streamProcessor.addMediaInfo(mediaInfo, true);\n        }\n    }\n\n    function initializeMediaForType(type, mediaSource) {\n        const allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type);\n\n        let mediaInfo = null;\n        let initialMediaInfo;\n\n        if (!allMediaForType || allMediaForType.length === 0) {\n            logger.info('No ' + type + ' data.');\n            return;\n        }\n\n        for (let i = 0, ln = allMediaForType.length; i < ln; i++) {\n            mediaInfo = allMediaForType[i];\n\n            if (type === Constants.EMBEDDED_TEXT) {\n                textController.addEmbeddedTrack(mediaInfo);\n            } else {\n                if (!isMediaSupported(mediaInfo)) continue;\n                mediaController.addTrack(mediaInfo);\n            }\n        }\n\n        if (type === Constants.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) {\n            return;\n        }\n\n        if (type === Constants.IMAGE) {\n            thumbnailController = ThumbnailController(context).create({\n                dashManifestModel: dashManifestModel,\n                adapter: adapter,\n                baseURLController: config.baseURLController,\n                stream: instance\n            });\n            return;\n        }\n\n        if (type !== Constants.FRAGMENTED_TEXT || (type === Constants.FRAGMENTED_TEXT && textController.getTextDefaultEnabled())) {\n            mediaController.checkInitialMediaSettingsForType(type, streamInfo);\n            initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo);\n        }\n\n        if (type === Constants.FRAGMENTED_TEXT && !textController.getTextDefaultEnabled()) {\n            initialMediaInfo = mediaController.getTracksFor(type, streamInfo)[0];\n        }\n\n        // TODO : How to tell index handler live/duration?\n        // TODO : Pass to controller and then pass to each method on handler?\n\n        createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource);\n    }\n\n    function initializeMedia(mediaSource, previousBuffers) {\n        checkConfig();\n        let events;\n        let element = videoModel.getElement();\n\n        //if initializeMedia is called from a switch period, eventController could have been already created.\n        if (!eventController) {\n            eventController = EventController(context).create();\n\n            eventController.setConfig({\n                manifestModel: manifestModel,\n                manifestUpdater: manifestUpdater,\n                playbackController: playbackController\n            });\n            events = adapter.getEventsFor(streamInfo);\n            eventController.addInlineEvents(events);\n        }\n\n        isUpdating = true;\n\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        if (element === null || (element && (/^VIDEO$/i).test(element.nodeName))) {\n            initializeMediaForType(Constants.VIDEO, mediaSource);\n        }\n        initializeMediaForType(Constants.AUDIO, mediaSource);\n        initializeMediaForType(Constants.TEXT, mediaSource);\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n        initializeMediaForType(Constants.MUXED, mediaSource);\n        initializeMediaForType(Constants.IMAGE, mediaSource);\n\n        //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText.\n        const buffers = createBuffers(previousBuffers);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\n            logger.fatal(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n\n        return buffers;\n    }\n\n    function initializeAfterPreload() {\n        isUpdating = true;\n        checkConfig();\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n        if (streamProcessors.length === 0) {\n            let msg = 'No streams to play.';\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\n            logger.debug(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n    }\n\n    function filterCodecs(type) {\n        const realAdaptation = dashManifestModel.getAdaptationForType(manifestModel.getValue(), streamInfo.index, type, streamInfo);\n\n        if (!realAdaptation || !Array.isArray(realAdaptation.Representation_asArray)) return null;\n\n        // Filter codecs that are not supported\n        realAdaptation.Representation_asArray = realAdaptation.Representation_asArray.filter((_, i) => {\n            // keep at least codec from lowest representation\n            if (i === 0) return true;\n\n            const codec = dashManifestModel.getCodec(realAdaptation, i, true);\n            if (!capabilities.supportsCodec(codec)) {\n                logger.error('[Stream] codec not supported: ' + codec);\n                return false;\n            }\n            return true;\n        });\n    }\n\n    function checkIfInitializationCompleted() {\n        const ln = streamProcessors.length;\n        const hasError = !!updateError.audio || !!updateError.video;\n        let error = hasError ? new Error(DATA_UPDATE_FAILED_ERROR_CODE, 'Data update failed', null) : null;\n        for (let i = 0; i < ln; i++) {\n            if (streamProcessors[i].isUpdating() || isUpdating) {\n                return;\n            }\n        }\n\n        if (!isMediaInitialized) {\n            return;\n        }\n\n        if (protectionController) {\n            // Need to check if streamProcessors exists because streamProcessors\n            // could be cleared in case an error is detected while initializing DRM keysystem\n            for (let i = 0; i < ln && streamProcessors[i]; i++) {\n                if (streamProcessors[i].getType() === Constants.AUDIO ||\n                    streamProcessors[i].getType() === Constants.VIDEO ||\n                    streamProcessors[i].getType() === Constants.FRAGMENTED_TEXT) {\n                    protectionController.initializeForMedia(streamProcessors[i].getMediaInfo());\n                }\n            }\n        }\n\n        eventBus.trigger(Events.STREAM_INITIALIZED, {\n            streamInfo: streamInfo,\n            error: error\n        });\n    }\n\n    function getMediaInfo(type) {\n        const ln = streamProcessors.length;\n        let streamProcessor = null;\n\n        for (let i = 0; i < ln; i++) {\n            streamProcessor = streamProcessors[i];\n\n            if (streamProcessor.getType() === type) {\n                return streamProcessor.getMediaInfo();\n            }\n        }\n\n        return null;\n    }\n\n    function createBuffers(previousBuffers) {\n        const buffers = {};\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            buffers[streamProcessors[i].getType()] = streamProcessors[i].createBuffer(previousBuffers).getBuffer();\n        }\n        return buffers;\n    }\n\n    function onBufferingCompleted(e) {\n        if (e.streamInfo !== streamInfo) {\n            return;\n        }\n\n        let processors = getProcessors();\n        const ln = processors.length;\n\n        if (ln === 0) {\n            logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined');\n            return;\n        }\n\n        // if there is at least one buffer controller that has not completed buffering yet do nothing\n        for (let i = 0; i < ln; i++) {\n            //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED\n            if (!processors[i].isBufferingCompleted() && (processors[i].getType() === Constants.AUDIO || processors[i].getType() === Constants.VIDEO)) {\n                logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because streamProcessor ' + processors[i].getType() + ' is not buffering completed');\n                return;\n            }\n        }\n\n        logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED');\n\n        eventBus.trigger(Events.STREAM_BUFFERING_COMPLETED, {\n            streamInfo: streamInfo\n        });\n    }\n\n    function onDataUpdateCompleted(e) {\n        let sp = e.sender.getStreamProcessor();\n\n        if (sp.getStreamInfo() !== streamInfo) {\n            return;\n        }\n\n        updateError[sp.getType()] = e.error;\n        checkIfInitializationCompleted();\n    }\n\n    function getProcessorForMediaInfo(mediaInfo) {\n        if (!mediaInfo) {\n            return false;\n        }\n\n        let processors = getProcessors();\n\n        return processors.filter(function (processor) {\n            return (processor.getType() === mediaInfo.type);\n        })[0];\n    }\n\n    function getProcessors() {\n        const ln = streamProcessors.length;\n        let arr = [];\n\n        let type,\n            streamProcessor;\n\n        for (let i = 0; i < ln; i++) {\n            streamProcessor = streamProcessors[i];\n            type = streamProcessor.getType();\n\n            if (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) {\n                arr.push(streamProcessor);\n            }\n        }\n\n        return arr;\n    }\n\n    function updateData(updatedStreamInfo) {\n        logger.info('Manifest updated... updating data system wide.');\n\n        isStreamActivated = false;\n        isUpdating = true;\n        streamInfo = updatedStreamInfo;\n\n        if (eventController) {\n            let events = adapter.getEventsFor(streamInfo);\n            eventController.addInlineEvents(events);\n        }\n\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            let streamProcessor = streamProcessors[i];\n            let mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType());\n            abrController.updateTopQualityIndex(mediaInfo);\n            streamProcessor.addMediaInfo(mediaInfo, true);\n        }\n\n        if (trackChangedEvent) {\n            let mediaInfo = trackChangedEvent.newMediaInfo;\n            if (mediaInfo.type !== 'fragmentedText') {\n                let processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo);\n                if (!processor) return;\n                processor.switchTrackAsked();\n                trackChangedEvent = undefined;\n            }\n        }\n\n        isUpdating = false;\n        checkIfInitializationCompleted();\n    }\n\n    function isCompatibleWithStream(stream) {\n        return compareCodecs(stream, Constants.VIDEO) && compareCodecs(stream, Constants.AUDIO);\n    }\n\n    function compareCodecs( stream, type ) {\n        if (!stream) {\n            return false;\n        }\n        const newStreamInfo = stream.getStreamInfo();\n        const currentStreamInfo = getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = dashManifestModel.getAdaptationForType(manifestModel.getValue(), newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = dashManifestModel.getAdaptationForType(manifestModel.getValue(), currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        const sameMimeType =  newAdaptation && currentAdaptation && newAdaptation.mimeType === currentAdaptation.mimeType;\n        const oldCodecs = currentAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const newCodecs = newAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const codecMatch = newCodecs.some((newCodec) => {\n            return oldCodecs.indexOf(newCodec) > -1;\n        });\n\n        const partialCodecMatch = newCodecs.some((newCodec) => oldCodecs.some((oldCodec) => codecRootCompatibleWithCodec(oldCodec, newCodec)));\n        return codecMatch || (partialCodecMatch && sameMimeType);\n    }\n\n    // Check if the root of the old codec is the same as the new one, or if it's declared as compatible in the compat table\n    function codecRootCompatibleWithCodec(codec1, codec2) {\n        const codecRoot = codec1.split('.')[0];\n        const compatTableCodec = codecCompatibilityTable.find((compat) => compat.codec === codecRoot);\n        const rootCompatible = codec2.indexOf(codecRoot) === 0;\n        if (compatTableCodec) {\n            return rootCompatible || compatTableCodec.compatibleCodecs.some((compatibleCodec) => codec2.indexOf(compatibleCodec) === 0);\n        }\n        return rootCompatible;\n    }\n\n    function setPreloaded(value) {\n        preloaded = value;\n    }\n\n    function getPreloaded() {\n        return preloaded;\n    }\n\n    function preload(mediaSource, previousBuffers) {\n        let events;\n\n        //if initializeMedia is called from a switch period, eventController could have been already created.\n        if (!eventController) {\n            eventController = EventController(context).create();\n\n            eventController.setConfig({\n                manifestModel: manifestModel,\n                manifestUpdater: manifestUpdater,\n                playbackController: playbackController\n            });\n            events = adapter.getEventsFor(streamInfo);\n            eventController.addInlineEvents(events);\n        }\n\n        initializeMediaForType(Constants.VIDEO, mediaSource);\n        initializeMediaForType(Constants.AUDIO, mediaSource);\n        initializeMediaForType(Constants.TEXT, mediaSource);\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n        initializeMediaForType(Constants.MUXED, mediaSource);\n        initializeMediaForType(Constants.IMAGE, mediaSource);\n\n        createBuffers(previousBuffers);\n\n        eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n        for (let i = 0; i < streamProcessors.length && streamProcessors[i]; i++) {\n            streamProcessors[i].getScheduleController().start();\n        }\n\n        setPreloaded(true);\n    }\n\n    instance = {\n        initialize: initialize,\n        activate: activate,\n        deactivate: deactivate,\n        isActive: isActive,\n        getDuration: getDuration,\n        getStartTime: getStartTime,\n        getId: getId,\n        getStreamInfo: getStreamInfo,\n        preload: preload,\n        getFragmentController: getFragmentController,\n        getThumbnailController: getThumbnailController,\n        getEventController: getEventController,\n        getBitrateListFor: getBitrateListFor,\n        startEventController: startEventController,\n        stopEventController: stopEventController,\n        updateData: updateData,\n        reset: reset,\n        getProcessors: getProcessors,\n        setMediaSource: setMediaSource,\n        isCompatibleWithStream: isCompatibleWithStream,\n        getPreloaded: getPreloaded\n    };\n\n    setup();\n    return instance;\n}\n\nStream.__dashjs_factory_name = 'Stream';\nexport default FactoryMaker.getClassFactory(Stream);\n"]}