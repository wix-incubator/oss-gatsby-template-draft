{"version":3,"sources":["../../../../../src/streaming/net/FetchLoader.js"],"names":[],"mappings":"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","file":"FetchLoader.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport BoxParser from '../utils/BoxParser';\n\n/**\n* @module FetchLoader\n* @description Manages download of resources via HTTP using fetch.\n* @param {Object} cfg - dependencies from parent\n*/\nfunction FetchLoader(cfg) {\n    cfg = cfg || {};\n    const requestModifier = cfg.requestModifier;\n\n    let instance;\n\n    function load(httpRequest) {\n\n        // Variables will be used in the callback functions\n        let firstProgress = true; /*jshint ignore:line*/\n        let needFailureReport = true; /*jshint ignore:line*/\n        let requestStartTime = new Date();\n        let lastTraceTime = requestStartTime; /*jshint ignore:line*/\n        let lastTraceReceivedCount = 0; /*jshint ignore:line*/\n\n        let request = httpRequest.request;\n\n        const headers = new Headers(); /*jshint ignore:line*/\n        if (request.range) {\n            headers.append('Range', 'bytes=' + request.range);\n        }\n\n        if (!request.requestStartDate) {\n            request.requestStartDate = requestStartTime;\n        }\n\n        if (requestModifier) {\n            // modifyRequestHeader expects a XMLHttpRequest object so,\n            // to keep backward compatibility, we should expose a setRequestHeader method\n            // TODO: Remove RequestModifier dependency on XMLHttpRequest object and define\n            // a more generic way to intercept/modify requests\n            requestModifier.modifyRequestHeader({\n                setRequestHeader: function (header, value) {\n                    headers.append(header, value);\n                }\n            });\n        }\n\n        let abortController;\n        if (typeof window.AbortController === 'function') {\n            abortController = new AbortController(); /*jshint ignore:line*/\n            httpRequest.abortController = abortController;\n        }\n\n        const reqOptions = {\n            method: httpRequest.method,\n            headers: headers,\n            credentials: httpRequest.withCredentials ? 'include' : undefined,\n            signal: abortController ? abortController.signal : undefined\n        };\n\n        fetch(httpRequest.url, reqOptions).then(function (response) {\n            if (!httpRequest.response) {\n                httpRequest.response = {};\n            }\n            httpRequest.response.status = response.status;\n            httpRequest.response.statusText = response.statusText;\n            httpRequest.response.responseURL = response.url;\n\n            if (!response.ok) {\n                httpRequest.onerror();\n            }\n\n            let responseHeaders = '';\n            for (const key of response.headers.keys()) {\n                responseHeaders += key + ': ' + response.headers.get(key) + '\\n';\n            }\n            httpRequest.response.responseHeaders = responseHeaders;\n\n            if (!response.body) {\n                // Fetch returning a ReadableStream response body is not currently supported by all browsers.\n                // Browser compatibility: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n                // If it is not supported, returning the whole segment when it's ready (as xhr)\n                return response.arrayBuffer().then(function (buffer) {\n                    httpRequest.response.response = buffer;\n                    const event = {\n                        loaded: buffer.byteLength,\n                        total: buffer.byteLength\n                    };\n                    httpRequest.progress(event);\n                    httpRequest.onload();\n                    httpRequest.onend();\n                    return;\n                });\n            }\n\n            const totalBytes = parseInt(response.headers.get('Content-Length'), 10);\n            let bytesReceived = 0;\n            let signaledFirstByte = false;\n            let remaining = new Uint8Array();\n            let offset = 0;\n\n            httpRequest.reader = response.body.getReader();\n            let downLoadedData = [];\n\n            const processResult = function ({ value, done }) {\n                if (done) {\n                    if (remaining) {\n                        // If there is pending data, call progress so network metrics\n                        // are correctly generated\n                        // Same structure as https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/onprogress\n                        httpRequest.progress({\n                            loaded: bytesReceived,\n                            total: isNaN(totalBytes) ? bytesReceived : totalBytes,\n                            lengthComputable: true,\n                            time: calculateDownloadedTime(downLoadedData, bytesReceived)\n                        });\n\n                        httpRequest.response.response = remaining.buffer;\n                    }\n                    httpRequest.onload();\n                    httpRequest.onend();\n                    return;\n                }\n\n                if (value && value.length > 0) {\n                    remaining = concatTypedArray(remaining, value);\n                    bytesReceived += value.length;\n                    downLoadedData.push({\n                        ts: Date.now(),\n                        bytes: value.length\n                    });\n\n                    const boxesInfo = BoxParser().getInstance().findLastTopIsoBoxCompleted(['moov', 'mdat'], remaining, offset);\n                    if (boxesInfo.found) {\n                        const end = boxesInfo.lastCompletedOffset + boxesInfo.size;\n\n                        // If we are going to pass full buffer, avoid copying it and pass\n                        // complete buffer. Otherwise clone the part of the buffer that is completed\n                        // and adjust remaining buffer. A clone is needed because ArrayBuffer of a typed-array\n                        // keeps a reference to the original data\n                        let data;\n                        if (end === remaining.length) {\n                            data = remaining;\n                            remaining = new Uint8Array();\n                        } else {\n                            data = new Uint8Array(remaining.subarray(0, end));\n                            remaining = remaining.subarray(end);\n                        }\n\n                        // Announce progress but don't track traces. Throughput measures are quite unstable\n                        // when they are based in small amount of data\n                        httpRequest.progress({\n                            data: data.buffer,\n                            lengthComputable: false,\n                            noTrace: true\n                        });\n\n                        offset = 0;\n                    } else {\n                        offset = boxesInfo.lastCompletedOffset;\n\n                        // Call progress so it generates traces that will be later used to know when the first byte\n                        // were received\n                        if (!signaledFirstByte) {\n                            httpRequest.progress({\n                                lengthComputable: false,\n                                noTrace: true\n                            });\n                            signaledFirstByte = true;\n                        }\n                    }\n                }\n                read(httpRequest, processResult);\n            };\n\n            read(httpRequest, processResult);\n        })\n        .catch( function (e) {\n            if (httpRequest.onerror) {\n                httpRequest.onerror(e);\n            }\n        });\n    }\n\n    function read(httpRequest, processResult) {\n        httpRequest.reader.read()\n        .then(processResult)\n        .catch(function (e) {\n            if (httpRequest.onerror && httpRequest.response.status === 200) {\n                // Error, but response code is 200, trigger error\n                httpRequest.onerror(e);\n            }\n        });\n    }\n\n    function concatTypedArray(remaining, data) {\n        if (remaining.length === 0) {\n            return data;\n        }\n        const result = new Uint8Array(remaining.length + data.length);\n        result.set(remaining);\n        result.set(data, remaining.length);\n        return result;\n    }\n\n    function abort(request) {\n        if (request.abortController) {\n            // For firefox and edge\n            request.abortController.abort();\n        } else if (request.reader) {\n            // For Chrome\n            try {\n                request.reader.cancel();\n            } catch (e) {\n                // throw exceptions (TypeError) when reader was previously closed,\n                // for example, because a network issue\n            }\n        }\n    }\n\n    function calculateDownloadedTime(datum, bytesReceived) {\n        datum = datum.filter(data => data.bytes > ((bytesReceived / 4) / datum.length) );\n        if (datum.length > 1) {\n            let time = 0;\n            const avgTimeDistance = (datum[datum.length - 1].ts - datum[0].ts) / datum.length;\n            datum.forEach((data, index) => {\n                // To be counted the data has to be over a threshold\n                const next = datum[index + 1];\n                if (next) {\n                    const distance = next.ts - data.ts;\n                    time += distance < avgTimeDistance ? distance : 0;\n                }\n            });\n            return time;\n        }\n        return null;\n    }\n\n    instance = {\n        load: load,\n        abort: abort,\n        calculateDownloadedTime: calculateDownloadedTime\n    };\n\n    return instance;\n}\n\nFetchLoader.__dashjs_factory_name = 'FetchLoader';\n\nconst factory = FactoryMaker.getClassFactory(FetchLoader);\nexport default factory;\n"]}