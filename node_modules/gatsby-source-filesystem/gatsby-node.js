"use strict";

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var path = require("path");
var md5File = require("md5-file");
var fs = require("fs");
var prettyBytes = require("pretty-bytes");
var slash = require("slash");
var chokidar = require("chokidar");
var mime = require("mime");

var createId = function createId(path) {
  var slashed = slash(path);
  return slashed + " absPath of file";
};

function readFile(file, pluginOptions, cb) {
  var slashed = slash(file);
  var slashedFile = (0, _extends3.default)({}, path.parse(slashed), {
    absolutePath: slashed
  });
  md5File(slashedFile.absolutePath, function (md5Err, contentDigest) {
    fs.stat(slashedFile.absolutePath, function (statErr, stats) {
      // Stringify date objects.
      var newFile = JSON.parse(JSON.stringify((0, _extends3.default)({
        // Don't actually make the File id the absolute path as otherwise
        // people will use the id for that and ids shouldn't be treated as
        // useful information.
        id: createId(file),
        children: [],
        parent: "___SOURCE___",
        internal: {
          contentDigest: contentDigest,
          mediaType: mime.lookup(slashedFile.ext),
          type: "File"
        },
        sourceInstanceName: pluginOptions.name,
        absolutePath: slashedFile.absolutePath,
        relativePath: slash(path.relative(pluginOptions.path, slashedFile.absolutePath)),
        extension: slashedFile.ext.slice(1).toLowerCase(),
        size: stats.size,
        prettySize: prettyBytes(stats.size),
        modifiedTime: stats.mtime,
        accessTime: stats.atime,
        changeTime: stats.ctime,
        birthTime: stats.birthtime
      }, slashedFile, stats)));
      cb(null, newFile);
    });
  });
}

exports.sourceNodes = function (_ref, pluginOptions, done) {
  var boundActionCreators = _ref.boundActionCreators,
      getNode = _ref.getNode,
      hasNodeChanged = _ref.hasNodeChanged;
  var createNode = boundActionCreators.createNode,
      deleteNode = boundActionCreators.deleteNode;


  var ready = false;

  var watcher = chokidar.watch(pluginOptions.path, {
    ignored: ["**/*.un~", "**/.gitignore", "**/.npmignore", "**/.babelrc", "**/yarn.lock", "**/node_modules", "../**/dist/**"]
  });

  // For every path that is reported before the 'ready' event, we throw them
  // into a queue and then flush the queue when 'ready' event arrives.
  // After 'ready', we handle the 'add' event without putting it into a queue.
  var pathQueue = [];
  var flushPathQueue = function flushPathQueue(onComplete) {
    var queue = pathQueue;
    pathQueue = [];

    var numPathsProcessed = 0;
    var numPaths = queue.length;

    queue.forEach(function (path) {
      readFile(path, pluginOptions, function (err, file) {
        createNode(file);

        numPathsProcessed++;
        if (numPathsProcessed === numPaths) {
          onComplete();
        }
      });
    });
  };

  watcher.on("add", function (path) {
    if (ready) {
      console.log("added file at", path);
      readFile(path, pluginOptions, function (err, file) {
        createNode(file);
      });
    } else {
      pathQueue.push(path);
    }
  });
  watcher.on("change", function (path) {
    console.log("changed file at", path);
    readFile(path, pluginOptions, function (err, file) {
      createNode(file);
    });
  });
  watcher.on("unlink", function (path) {
    console.log("file deleted at", path);
    deleteNode(createId(path));
  });
  watcher.on("ready", function () {
    if (ready) {
      return;
    }

    ready = true;
    flushPathQueue(function () {
      done();
    });
  });

  return;
};