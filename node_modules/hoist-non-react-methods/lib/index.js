'use strict';

exports.__esModule = true;
exports.default = hoistNonReactMethods;
var REACT_PROTOTYPE = {
  autobind: true,
  childContextTypes: true,
  componentDidMount: true,
  componentDidUpdate: true,
  componentWillMount: true,
  componentWillReceiveProps: true,
  componentWillUnmount: true,
  componentWillUpdate: true,
  contextTypes: true,
  displayName: true,
  forceUpdate: true,
  getChildContext: true,
  getDefaultProps: true,
  getDOMNode: true,
  getInitialState: true,
  isMounted: true,
  mixins: true,
  propTypes: true,
  render: true,
  replaceProps: true,
  replaceState: true,
  setProps: true,
  setState: true,
  shouldComponentUpdate: true,
  statics: true,
  updateComponent: true
};

var REACT_STATICS = {
  childContextTypes: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  mixins: true,
  propTypes: true,
  type: true
};

var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  arguments: true,
  arity: true
};

var defaultConfig = {
  delegateTo: function delegateTo(w) {
    return w.refs.child;
  },
  hoistStatics: true
};

function hoistNonReactMethods(targetComponent, sourceComponent, config) {
  var targetComponentName = targetComponent.displayName || targetComponent.name || 'Wrapper';
  var sourceComponentName = sourceComponent.displayName || sourceComponent.name || 'WrappedComponent';
  var hoistStatics = config && typeof config.hoistStatics !== 'undefined' ? config.hoistStatics : defaultConfig.hoistStatics;
  var delegateTo = config && typeof config.delegateTo !== 'undefined' ? config.delegateTo : defaultConfig.delegateTo;
  // backwards compatible where config option is delegateTo function
  if (typeof config === 'function') delegateTo = config;

  if (hoistStatics) {
    var statics = Object.getOwnPropertyNames(sourceComponent).filter(function (k) {
      return !REACT_STATICS[k] && !KNOWN_STATICS[k];
    });

    statics.forEach(function (methodName) {
      if (targetComponent[methodName]) console.warn('Static method ' + methodName + ' already exists in wrapper component ' + targetComponentName + ', and won\'t be hoisted. Consider changing the name on ' + sourceComponentName + '.');
      targetComponent[methodName] = sourceComponent[methodName];
    });
  }

  var methods = Object.getOwnPropertyNames(sourceComponent.prototype).filter(function (k) {
    return !REACT_PROTOTYPE[k];
  });

  methods.forEach(function (methodName) {
    if (targetComponent.prototype[methodName]) {
      console.warn('Method ' + methodName + ' already exists in wrapper component ' + targetComponentName + ', and won\'t be hoisted. Consider changing the name on ' + sourceComponentName + '.');
      return;
    }

    targetComponent.prototype[methodName] = function () {
      var _sourceComponent$prot;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_sourceComponent$prot = sourceComponent.prototype[methodName]).call.apply(_sourceComponent$prot, [delegateTo.call(this, this)].concat(args));
    };
  });

  return targetComponent;
}
//# sourceMappingURL=index.js.map