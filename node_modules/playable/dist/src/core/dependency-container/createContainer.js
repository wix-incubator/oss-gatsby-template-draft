"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tslib_2 = require("tslib");
var registrations_1 = require("./registrations");
var ResolutionError_1 = tslib_1.__importDefault(require("./errors/ResolutionError"));
var nameValueToObject_1 = tslib_1.__importDefault(require("./utils/nameValueToObject"));
var Lifetime_1 = tslib_1.__importDefault(require("./constants/Lifetime"));
var FAMILY_TREE = '__familyTree__';
var Container = /** @class */ (function () {
    function Container(options, _parentContainer) {
        this._registrations = {};
        this._resolutionStack = [];
        this.options = tslib_2.__assign({}, options);
        this._parentContainer = _parentContainer || null;
        this[FAMILY_TREE] = this._parentContainer
            ? [this].concat(this._parentContainer[FAMILY_TREE])
            : [this];
        this.cache = {};
    }
    Object.defineProperty(Container.prototype, "registrations", {
        get: function () {
            return tslib_2.__assign({}, this._parentContainer && this._parentContainer.registrations, this._registrations);
        },
        enumerable: true,
        configurable: true
    });
    Container.prototype._registerAs = function (fn, verbatimValue, name, value, options) {
        var _this = this;
        var registrations = nameValueToObject_1.default(name, value);
        Object.keys(registrations).forEach(function (key) {
            var valueToRegister = registrations[key];
            // If we have options, copy them over.
            options = tslib_2.__assign({}, options);
            /* ignore coverage */
            if (!verbatimValue && Array.isArray(valueToRegister)) {
                // The ('name', [value, options]) style
                options = tslib_2.__assign({}, options, valueToRegister[1]);
                valueToRegister = valueToRegister[0];
            }
            _this.register(key, fn(valueToRegister, options));
        });
        // Chaining
        return this;
    };
    Container.prototype.createScope = function () {
        return new Container(this.options, this);
    };
    Container.prototype.register = function (name, registration) {
        var _this = this;
        var obj = nameValueToObject_1.default(name, registration);
        Object.keys(obj).forEach(function (key) {
            _this._registrations[key] = obj[key];
        });
        return this;
    };
    Container.prototype.registerClass = function (name, value, options) {
        return this._registerAs(registrations_1.asClass, false, name, value, options);
    };
    Container.prototype.registerFunction = function (name, value, options) {
        return this._registerAs(registrations_1.asFunction, false, name, value, options);
    };
    Container.prototype.registerValue = function (name, value, options) {
        return this._registerAs(registrations_1.asValue, true, name, value, options);
    };
    Container.prototype.resolve = function (name) {
        // We need a reference to the root container,
        // so we can retrieve and store singletons.
        var root = this[FAMILY_TREE][this[FAMILY_TREE].length - 1];
        try {
            // Grab the registration by name.
            var registration = this.registrations[name];
            if (this._resolutionStack.indexOf(name) > -1) {
                throw new ResolutionError_1.default(name, this._resolutionStack, 'Cyclic dependencies detected.');
            }
            if (!registration) {
                throw new ResolutionError_1.default(name, this._resolutionStack);
            }
            // Pushes the currently-resolving module name onto the stack
            this._resolutionStack.push(name);
            // Do the thing
            var cached = void 0;
            var resolved = void 0;
            switch (registration.lifetime) {
                case Lifetime_1.default.Transient:
                    // Transient lifetime means resolve every time.
                    resolved = registration.resolve(this);
                    break;
                case Lifetime_1.default.Singelton:
                    // Singleton lifetime means cache at all times, regardless of scope.
                    cached = root.cache[name];
                    if (cached === undefined) {
                        resolved = registration.resolve(this);
                        root.cache[name] = resolved;
                    }
                    else {
                        resolved = cached;
                    }
                    break;
                case Lifetime_1.default.Scoped:
                    // Scoped lifetime means that the container
                    // that resolves the registration also caches it.
                    // When a registration is not found, we travel up
                    // the family tree until we find one that is cached.
                    // Note: The first element in the family tree is this container.
                    for (var _i = 0, _a = this[FAMILY_TREE]; _i < _a.length; _i++) {
                        var _containerFromFamiltyTree = _a[_i];
                        cached = _containerFromFamiltyTree.cache[name];
                        if (cached !== undefined) {
                            // We found one!
                            resolved = cached;
                            break;
                        }
                    }
                    // If we still have not found one, we need to resolve and cache it.
                    if (cached === undefined) {
                        resolved = registration.resolve(this);
                        this.cache[name] = resolved;
                    }
                    break;
                default:
                    throw new ResolutionError_1.default(name, this._resolutionStack, "Unknown lifetime \"" + registration.lifetime + "\"");
            }
            // Pop it from the stack again, ready for the next resolution
            this._resolutionStack.pop();
            return resolved;
        }
        catch (err) {
            // When we get an error we need to reset the stack.
            this._resolutionStack = [];
            throw err;
        }
    };
    return Container;
}());
exports.Container = Container;
function createContainer(options, __parentContainer) {
    return new Container(options, __parentContainer);
}
exports.default = createContainer;
//# sourceMappingURL=createContainer.js.map