"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var chai_1 = require("chai");
//@ts-ignore
var sinon = tslib_1.__importStar(require("sinon"));
var createContainer_1 = tslib_1.__importDefault(require("./createContainer"));
var registrations_1 = require("./registrations");
describe('container created by createContainer', function () {
    var container;
    beforeEach(function () {
        container = createContainer_1.default();
    });
    it('should have method for registering and resolving modules', function () {
        var valueRegistration = registrations_1.asValue(10);
        container.register('value', valueRegistration);
        sinon.spy(valueRegistration, 'resolve');
        container.resolve('value');
        chai_1.expect(valueRegistration.resolve.called).to.be.equal(true);
        var classARegistration = registrations_1.asClass(/** @class */ (function () {
            function A() {
            }
            return A;
        }()));
        container.register('classA', classARegistration);
        sinon.spy(classARegistration, 'resolve');
        container.resolve('classA');
        chai_1.expect(classARegistration.resolve.called).to.be.equal(true);
        var funcRegistration = registrations_1.asFunction(function () { });
        container.register('func', funcRegistration);
        sinon.spy(funcRegistration, 'resolve');
        container.resolve('func');
        chai_1.expect(funcRegistration.resolve.called).to.be.equal(true);
    });
    it('resolve should react on transient lifetime', function () {
        var obj = {};
        var transientFuncRegistration = registrations_1.asFunction(function () { return obj; }).transient();
        sinon.spy(transientFuncRegistration, 'resolve');
        container.register('func', transientFuncRegistration);
        container.resolve('func');
        container.resolve('func');
        chai_1.expect(transientFuncRegistration.resolve.calledTwice).to.be.true;
        var singletonFuncRegistration = registrations_1.asFunction(function () { return obj; }).singleton();
        sinon.spy(singletonFuncRegistration, 'resolve');
        container.register('func2', singletonFuncRegistration);
        container.resolve('func2');
        container.resolve('func2');
        chai_1.expect(singletonFuncRegistration.resolve.calledOnce).to.be.true;
        var scopedFuncRegistration = registrations_1.asFunction(function () { return obj; }).scoped();
        sinon.spy(scopedFuncRegistration, 'resolve');
        container.register('func3', scopedFuncRegistration);
        container.resolve('func3');
        container.resolve('func3');
        chai_1.expect(scopedFuncRegistration.resolve.calledOnce).to.be.true;
        var scope = container.createScope();
        scope.register('func4', scopedFuncRegistration);
        chai_1.expect(scope.resolve('func3')).to.be.equal(obj);
        chai_1.expect(scopedFuncRegistration.resolve.calledOnce).to.be.true;
        chai_1.expect(function () { return container.resolve('func4'); }).to.throw();
        var unknownFuncRegistration = registrations_1.asFunction(function () { return obj; }).setLifetime('testtest');
        container.register('func5', unknownFuncRegistration);
        chai_1.expect(function () { return container.resolve('func5'); }).to.throw();
    });
    it('resolve should react on singleton lifetime', function () {
        var obj = {};
        var singletonFuncRegistration = registrations_1.asFunction(function () { return obj; }).singleton();
        sinon.spy(singletonFuncRegistration, 'resolve');
        container.register('func2', singletonFuncRegistration);
        container.resolve('func2');
        container.resolve('func2');
        chai_1.expect(singletonFuncRegistration.resolve.calledOnce).to.be.true;
    });
    it('resolve should react on scoped lifetime', function () {
        var obj = {};
        var scopedFuncRegistration = registrations_1.asFunction(function () { return obj; }).scoped();
        sinon.spy(scopedFuncRegistration, 'resolve');
        container.register('func3', scopedFuncRegistration);
        container.resolve('func3');
        container.resolve('func3');
        chai_1.expect(scopedFuncRegistration.resolve.calledOnce).to.be.true;
        var scope = container.createScope();
        scope.register('func4', scopedFuncRegistration);
        chai_1.expect(scope.resolve('func3')).to.be.equal(obj);
        chai_1.expect(scopedFuncRegistration.resolve.calledOnce).to.be.true;
        chai_1.expect(function () { return container.resolve('func4'); }).to.throw();
    });
    it('resolve should react on unknown lifetime', function () {
        var obj = {};
        var unknownFuncRegistration = registrations_1.asFunction(function () { return obj; }).setLifetime('testtest');
        container.register('func5', unknownFuncRegistration);
        chai_1.expect(function () { return container.resolve('func5'); }).to.throw();
    });
    it('should throw error on duplication of id', function () {
        var _a, _b;
        container.registerClass('name', (_a = /** @class */ (function () {
                function A() {
                }
                return A;
            }()),
            _a.dependencies = ['name2'],
            _a));
        container.registerClass('name2', (_b = /** @class */ (function () {
                function B() {
                }
                return B;
            }()),
            _b.dependencies = ['name'],
            _b));
        chai_1.expect(function () { return container.resolve('name'); }).to.throw();
    });
    it('should throw error if trying to resolve not registered module', function () {
        chai_1.expect(function () { return container.resolve('name'); }).to.throw();
    });
});
//# sourceMappingURL=createContainer.spec.js.map