"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tslib_2 = require("tslib");
var NotAFunctionError_1 = tslib_1.__importDefault(require("./errors/NotAFunctionError"));
var Lifetime_1 = tslib_1.__importDefault(require("./constants/Lifetime"));
exports.PROPERTY_FOR_DEPENDENCIES = 'dependencies';
exports.makeFluidInterface = function (obj) {
    var setLifetime = function (value) {
        obj.lifetime = value;
        return obj;
    };
    return {
        setLifetime: setLifetime,
        transient: function () { return setLifetime(Lifetime_1.default.Transient); },
        scoped: function () { return setLifetime(Lifetime_1.default.Scoped); },
        singleton: function () { return setLifetime(Lifetime_1.default.Singelton); },
    };
};
exports.asValue = function (value) {
    var resolve = function () { return value; };
    return {
        resolve: resolve,
        lifetime: Lifetime_1.default.Transient,
    };
};
exports.asFunction = function (fn, options) {
    if (typeof fn !== 'function') {
        throw new NotAFunctionError_1.default('asFunction', 'function', typeof fn);
    }
    var defaults = {
        lifetime: Lifetime_1.default.Transient,
    };
    options = tslib_2.__assign({}, defaults, options);
    var resolve = generateResolve(fn);
    var result = {
        resolve: resolve,
        lifetime: options.lifetime,
    };
    result.resolve = resolve.bind(result);
    tslib_2.__assign(result, exports.makeFluidInterface(result));
    return result;
};
exports.asClass = function (Type, options) {
    if (typeof Type !== 'function') {
        throw new NotAFunctionError_1.default('asClass', 'class', typeof Type);
    }
    var defaults = {
        lifetime: Lifetime_1.default.Transient,
    };
    options = tslib_2.__assign({}, defaults, options);
    // A function to handle object construction for us, as to make the generateResolve more reusable
    var newClass = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return new (Type.bind.apply(Type, [void 0].concat(args)))();
    };
    var resolve = generateResolve(newClass, Type);
    var result = {
        resolve: resolve,
        lifetime: options.lifetime,
    };
    result.resolve = resolve.bind(result);
    tslib_2.__assign(result, exports.makeFluidInterface(result));
    return result;
};
function generateResolve(fn, dependencyParseTarget) {
    // If the function used for dependency parsing is falsy, use the supplied function
    if (!dependencyParseTarget) {
        dependencyParseTarget = fn;
    }
    // Try to resolve the dependencies
    var dependencies = dependencyParseTarget[exports.PROPERTY_FOR_DEPENDENCIES] || [];
    // Use a regular function instead of an arrow function to facilitate binding to the registration.
    return function resolve(container) {
        if (dependencies.length > 0) {
            var wrapper = dependencies.reduce(function (wrapper, dependency) {
                wrapper[dependency] = container.resolve(dependency);
                return wrapper;
            }, {});
            return fn(wrapper, container);
        }
        return fn(container);
    };
}
exports.default = {
    asValue: exports.asValue,
    asFunction: exports.asFunction,
    asClass: exports.asClass,
};
//# sourceMappingURL=registrations.js.map