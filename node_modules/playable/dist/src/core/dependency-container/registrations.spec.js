"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var chai_1 = require("chai");
//@ts-ignore
var sinon = tslib_1.__importStar(require("sinon"));
var Lifetime_1 = tslib_1.__importDefault(require("./constants/Lifetime"));
var NotAFunctionError_1 = tslib_1.__importDefault(require("./errors/NotAFunctionError"));
var registrations_1 = require("./registrations");
describe('registration method', function () {
    var container = {
        resolve: sinon.spy(function (name) { return name; }),
    };
    afterEach(function () {
        container.resolve.reset();
    });
    describe('asValue', function () {
        it('should return object in proper format', function () {
            var value = 10;
            var registeredValue = registrations_1.asValue(value);
            chai_1.expect(registeredValue.lifetime).to.be.equal(Lifetime_1.default.Transient);
            chai_1.expect(registeredValue.resolve()).to.be.equal(value);
        });
    });
    describe('asFunction', function () {
        it('should return error if not function passed', function () {
            var func = 10;
            var errorThrown = function () { return registrations_1.asFunction(func); };
            chai_1.expect(errorThrown).to.throw(new NotAFunctionError_1.default('asFunction', 'function', typeof func).message);
        });
        it('should return object in proper format', function () {
            var func = function () { };
            var registeredFunction = registrations_1.asFunction(func);
            chai_1.expect(registeredFunction.lifetime).to.be.equal(Lifetime_1.default.Transient);
            chai_1.expect(registeredFunction.resolve).to.exist;
        });
        it('should except options', function () {
            var func = function () { };
            var registeredFunction = registrations_1.asFunction(func, {
                lifetime: Lifetime_1.default.Scoped,
            });
            chai_1.expect(registeredFunction.lifetime).to.be.equal(Lifetime_1.default.Scoped);
        });
        describe("returned object's resolve method", function () {
            it('should call initial method only with container passed', function () {
                var func = sinon.spy();
                var registeredFunction = registrations_1.asFunction(func);
                registeredFunction.resolve(container);
                chai_1.expect(func.calledWith(container)).to.be.true;
            });
            it('should combine wrapper object with resolved dependencies from container', function () {
                var func = sinon.spy();
                var moduleName = 'moduleName';
                func[registrations_1.PROPERTY_FOR_DEPENDENCIES] = [moduleName];
                var registeredFunction = registrations_1.asFunction(func);
                registeredFunction.resolve(container);
                chai_1.expect(container.resolve.calledWithExactly(moduleName)).to.be.true;
                chai_1.expect(func.calledWithExactly({
                    moduleName: moduleName,
                }, container)).to.be.true;
            });
        });
        describe('returned object should have fluid interface', function () {
            var func = function () { };
            var registeredFunction = registrations_1.asFunction(func);
            registeredFunction.transient();
            chai_1.expect(registeredFunction.lifetime).to.be.equal(Lifetime_1.default.Transient);
            registeredFunction.scoped();
            chai_1.expect(registeredFunction.lifetime).to.be.equal(Lifetime_1.default.Scoped);
            registeredFunction.singleton();
            chai_1.expect(registeredFunction.lifetime).to.be.equal(Lifetime_1.default.Singelton);
            registeredFunction.setLifetime(Lifetime_1.default.Scoped);
            chai_1.expect(registeredFunction.lifetime).to.be.equal(Lifetime_1.default.Scoped);
        });
    });
    describe('asClass', function () {
        it('should return error if not function passed', function () {
            var classDeclare = 10;
            var errorThrown = function () { return registrations_1.asClass(classDeclare); };
            chai_1.expect(errorThrown).to.throw(new NotAFunctionError_1.default('asClass', 'class', typeof classDeclare).message);
        });
        it('should return object in proper format', function () {
            var Class = /** @class */ (function () {
                function Class() {
                }
                return Class;
            }());
            var registeredClass = registrations_1.asClass(Class);
            chai_1.expect(registeredClass.lifetime).to.be.equal(Lifetime_1.default.Transient);
            chai_1.expect(registeredClass.resolve).to.exist;
        });
        it('should except options', function () {
            var Class = /** @class */ (function () {
                function Class() {
                }
                return Class;
            }());
            var registeredClass = registrations_1.asClass(Class, {
                lifetime: Lifetime_1.default.Scoped,
            });
            chai_1.expect(registeredClass.lifetime).to.be.equal(Lifetime_1.default.Scoped);
        });
        describe("returned object's resolve method", function () {
            it('should call initial method only with container passed', function () {
                var constructor = sinon.spy();
                var registeredClass = registrations_1.asClass(constructor);
                registeredClass.resolve(container);
                chai_1.expect(constructor.calledWithNew()).to.be.true;
                chai_1.expect(constructor.calledWith(container)).to.be.true;
            });
            it('should combine wrapper object with resolved dependencies from container', function () {
                var constructor = sinon.spy();
                var moduleName = 'moduleName';
                constructor[registrations_1.PROPERTY_FOR_DEPENDENCIES] = [moduleName];
                var registeredClass = registrations_1.asClass(constructor);
                registeredClass.resolve(container);
                chai_1.expect(constructor.calledWithNew()).to.be.true;
                chai_1.expect(container.resolve.calledWithExactly(moduleName)).to.be.true;
                chai_1.expect(constructor.calledWithExactly({
                    moduleName: moduleName,
                }, container)).to.be.true;
            });
        });
        describe('returned object should have fluid interface', function () {
            var constructor = sinon.spy();
            var registeredClass = registrations_1.asClass(constructor);
            registeredClass.transient();
            chai_1.expect(registeredClass.lifetime).to.be.equal(Lifetime_1.default.Transient);
            registeredClass.scoped();
            chai_1.expect(registeredClass.lifetime).to.be.equal(Lifetime_1.default.Scoped);
            registeredClass.singleton();
            chai_1.expect(registeredClass.lifetime).to.be.equal(Lifetime_1.default.Singelton);
            registeredClass.setLifetime(Lifetime_1.default.Scoped);
            chai_1.expect(registeredClass.lifetime).to.be.equal(Lifetime_1.default.Scoped);
        });
    });
});
//# sourceMappingURL=registrations.spec.js.map