"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
require("jsdom-global/register");
var chai_1 = require("chai");
//@ts-ignore
var sinon = tslib_1.__importStar(require("sinon"));
var config_1 = tslib_1.__importDefault(require("./config"));
var player_facade_1 = tslib_1.__importDefault(require("./player-facade"));
var dependency_container_1 = tslib_1.__importDefault(require("./dependency-container"));
var player_api_decorator_1 = tslib_1.__importDefault(require("../core/player-api-decorator"));
describe("Player's instance", function () {
    var container;
    var player;
    var defaultModules;
    var additionalModules;
    beforeEach(function () {
        container = dependency_container_1.default.createContainer();
    });
    describe('rootNode and params', function () {
        it('should be registered and resolved', function () {
            var registerValueSpy = sinon.spy(container, 'registerValue');
            var params = {};
            player = new player_facade_1.default({}, container, []);
            chai_1.expect(registerValueSpy.calledWith({
                config: config_1.default(params),
            })).to.be.true;
        });
        it('should be resolved', function () {
            var resolveSpy = sinon.spy(container, 'resolve');
            player = new player_facade_1.default({}, container, []);
            chai_1.expect(resolveSpy.args).to.deep.equal([['config']]);
        });
    });
    describe('default modules', function () {
        it('should be resolved', function () {
            var ClassA = /** @class */ (function () {
                function ClassA() {
                }
                return ClassA;
            }());
            var resolveSpy = sinon.spy(container, 'resolve');
            defaultModules = {
                ClassA: ClassA,
            };
            container.registerClass('ClassA', ClassA);
            player = new player_facade_1.default({}, container, Object.keys(defaultModules));
            chai_1.expect(resolveSpy.calledWith('ClassA')).to.be.true;
        });
        it('should call destroy on player destroy', function () {
            var destroySpy = sinon.spy();
            var ClassA = /** @class */ (function () {
                function ClassA() {
                }
                ClassA.prototype.destroy = function () {
                    destroySpy();
                };
                return ClassA;
            }());
            defaultModules = {
                ClassA: ClassA,
            };
            container.registerClass('ClassA', ClassA);
            player = new player_facade_1.default({}, container, Object.keys(defaultModules));
            player.destroy();
            chai_1.expect(destroySpy.called).to.be.true;
        });
    });
    describe('additional modules', function () {
        it('should be resolved', function () {
            var ClassB = /** @class */ (function () {
                function ClassB() {
                }
                return ClassB;
            }());
            var resolveSpy = sinon.spy(container, 'resolve');
            container.registerClass('ClassB', ClassB);
            player = new player_facade_1.default({}, container, [], ['ClassB']);
            chai_1.expect(resolveSpy.calledWith('ClassB')).to.be.true;
        });
        it('should call destroy on player destroy', function () {
            var destroySpy = sinon.spy();
            var ClassA = /** @class */ (function () {
                function ClassA() {
                }
                ClassA.prototype.destroy = function () {
                    destroySpy();
                };
                return ClassA;
            }());
            container.registerClass('ClassA', ClassA);
            player = new player_facade_1.default({}, container, [], ['ClassA']);
            player.destroy();
            chai_1.expect(destroySpy.called).to.be.true;
        });
    });
    describe('public API', function () {
        var ClassA;
        var ClassB;
        var ClassC;
        var methodASpy;
        var methodBSpy;
        beforeEach(function () {
            methodASpy = sinon.spy();
            methodBSpy = sinon.spy();
            var A = /** @class */ (function () {
                function A() {
                }
                A.prototype.methodA = function () {
                    methodASpy();
                };
                Object.defineProperty(A.prototype, "methodC", {
                    get: function () {
                        return;
                    },
                    set: function (_) { },
                    enumerable: true,
                    configurable: true
                });
                A.prototype.destroy = function () { };
                tslib_1.__decorate([
                    player_api_decorator_1.default()
                ], A.prototype, "methodA", null);
                tslib_1.__decorate([
                    player_api_decorator_1.default()
                ], A.prototype, "methodC", null);
                return A;
            }());
            var B = /** @class */ (function () {
                function B() {
                }
                B.prototype.methodB = function () {
                    methodBSpy();
                };
                B.prototype.destroy = function () { };
                tslib_1.__decorate([
                    player_api_decorator_1.default()
                ], B.prototype, "methodB", null);
                return B;
            }());
            var C = /** @class */ (function () {
                function C() {
                }
                C.prototype.methodA = function () { };
                C.prototype.destroy = function () { };
                tslib_1.__decorate([
                    player_api_decorator_1.default('methodA')
                ], C.prototype, "methodA", null);
                return C;
            }());
            ClassA = A;
            ClassB = B;
            ClassC = C;
        });
        it('should be constructed from default modules', function () {
            container.registerClass('ClassA', ClassA);
            defaultModules = {
                ClassA: ClassA,
            };
            player = new player_facade_1.default({}, container, Object.keys(defaultModules));
            chai_1.expect(Reflect.has(player, 'methodA')).to.be.true;
            chai_1.expect(Reflect.has(player, 'methodB')).to.be.false;
            chai_1.expect(Reflect.has(player, 'methodC')).to.be.true;
            container.registerClass('ClassB', ClassB);
            defaultModules = {
                ClassA: ClassA,
                ClassB: ClassB,
            };
            player = new player_facade_1.default({}, container, Object.keys(defaultModules));
            chai_1.expect(Reflect.has(player, 'methodA')).to.be.true;
            chai_1.expect(Reflect.has(player, 'methodB')).to.be.true;
        });
        it('should be constructed from additional modules', function () {
            container.registerClass('ClassA', ClassA);
            defaultModules = {
                ClassA: ClassA,
            };
            additionalModules = {
                ClassA: ClassA,
            };
            player = new player_facade_1.default({}, container, Object.keys(defaultModules), Object.keys(additionalModules));
            chai_1.expect(Reflect.has(player, 'methodA')).to.be.true;
            chai_1.expect(Reflect.has(player, 'methodC')).to.be.true;
        });
        it('methods should call proper methods from modules', function () {
            defaultModules = {
                ClassA: ClassA,
            };
            additionalModules = {
                ClassB: ClassB,
            };
            container.registerClass('ClassA', ClassA);
            container.registerClass('ClassB', ClassB);
            player = new player_facade_1.default({}, container, Object.keys(defaultModules), Object.keys(additionalModules));
            player.methodA();
            player.methodB();
            chai_1.expect(methodASpy.called).to.be.true;
            chai_1.expect(methodBSpy.called).to.be.true;
        });
        it('should throw error on duplicate method in API', function () {
            defaultModules = {
                ClassA: ClassA,
                ClassC: ClassC,
            };
            container.registerClass('ClassA', ClassA);
            container.registerClass('ClassC', ClassC);
            var getDuplicateAPIMethodPlayer = function () {
                return new player_facade_1.default({}, container, Object.keys(defaultModules));
            };
            chai_1.expect(getDuplicateAPIMethodPlayer).to.throw('API method methodA is already defined in Player facade');
        });
        describe('when instance destroyed', function () {
            it('should clear instance', function () {
                defaultModules = {
                    ClassA: ClassA,
                };
                container.registerClass('ClassA', ClassA);
                player = new player_facade_1.default({}, container, Object.keys(defaultModules));
                player.destroy();
                chai_1.expect(Reflect.has(player, 'methodA')).to.be.false;
            });
            it('should not broadcast call methods of module', function () {
                defaultModules = {
                    ClassA: ClassA,
                };
                container.registerClass('ClassA', ClassA);
                player = new player_facade_1.default({}, container, Object.keys(defaultModules));
                var methodA = player.methodA;
                player.destroy();
                chai_1.expect(methodA).to.throw('Player instance is destroyed');
            });
        });
    });
});
//# sourceMappingURL=player-facade.spec.js.map