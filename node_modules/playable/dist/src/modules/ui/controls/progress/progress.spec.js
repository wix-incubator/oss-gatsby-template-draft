"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
require("jsdom-global/register");
var chai_1 = require("chai");
//@ts-ignore
var sinon = tslib_1.__importStar(require("sinon"));
var testkit_1 = tslib_1.__importDefault(require("../../../../testkit"));
var progress_1 = tslib_1.__importDefault(require("./progress"));
var constants_1 = require("../../../../constants");
describe('ProgressControl', function () {
    var testkit;
    var control;
    var engine;
    var eventEmitter;
    beforeEach(function () {
        testkit = testkit_1.default();
        testkit.registerModule('progressControl', progress_1.default);
        control = testkit.getModule('progressControl');
        eventEmitter = testkit.getModule('eventEmitter');
        engine = testkit.getModule('engine');
    });
    describe('constructor', function () {
        it('should create instance ', function () {
            chai_1.expect(control).to.exist;
            chai_1.expect(control.view).to.exist;
        });
    });
    describe('API', function () {
        it('should have method for setting value for played', function () {
            var played = '10';
            var spy = sinon.spy(control.view, 'setPlayed');
            chai_1.expect(control.updatePlayed).to.exist;
            control.updatePlayed(played);
            chai_1.expect(spy.calledWith(played)).to.be.true;
        });
        it('should have method for setting value for buffered', function () {
            var buffered = '30';
            var spy = sinon.spy(control.view, 'setBuffered');
            chai_1.expect(control.updateBuffered).to.exist;
            control.updateBuffered(buffered);
            chai_1.expect(spy.calledWith(buffered)).to.be.true;
        });
        it('should have method for showing whole view', function () {
            chai_1.expect(control.show).to.exist;
            control.show();
            chai_1.expect(control.isHidden).to.be.false;
        });
        it('should have method for hiding whole view', function () {
            chai_1.expect(control.hide).to.exist;
            control.hide();
            chai_1.expect(control.isHidden).to.be.true;
        });
        it('should have method for destroying', function () {
            var spy = sinon.spy(control, '_unbindEvents');
            chai_1.expect(control.destroy).to.exist;
            control.destroy();
            chai_1.expect(control.view).to.not.exist;
            chai_1.expect(control._eventEmitter).to.not.exist;
            chai_1.expect(spy.called).to.be.true;
        });
        describe('for time indicators', function () {
            var VIDEO_DURATION_TIME = 1000;
            var engineGetDurationTimeStub;
            beforeEach(function () {
                engineGetDurationTimeStub = sinon
                    .stub(control._engine, 'getDurationTime')
                    .callsFake(function () { return VIDEO_DURATION_TIME; });
            });
            afterEach(function () {
                engineGetDurationTimeStub.restore();
            });
            it('should have methods for adding/deleting indicators', function () {
                chai_1.expect(control.addTimeIndicator, 'addTimeIndicator').to.exist;
                chai_1.expect(control.addTimeIndicators, 'addTimeIndicators').to.exist;
                chai_1.expect(control.clearTimeIndicators, 'clearTimeIndicators').to.exist;
            });
            describe('before `METADATA_LOADED`', function () {
                beforeEach(function () {
                    control.clearTimeIndicators();
                });
                it('should add one indicator', function () {
                    var timeIndicatorsNode = control.view._$timeIndicators;
                    control.addTimeIndicator(100);
                    chai_1.expect(control._engine.isMetadataLoaded, '`isMetadataLoaded` before add').to.equal(false);
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'indicator added before `METADATA_LOADED`').to.equal(0);
                    eventEmitter.emit(constants_1.VIDEO_EVENTS.STATE_CHANGED, {
                        nextState: constants_1.EngineState.METADATA_LOADED,
                    });
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'indicator added after `METADATA_LOADED`').to.equal(1);
                });
                it('should add multiple indicators', function () {
                    var timeIndicatorsNode = control.view._$timeIndicators;
                    control.addTimeIndicators([100, 200, 300]);
                    chai_1.expect(control._engine.isMetadataLoaded, '`isMetadataLoaded` before add').to.equal(false);
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'indicator added before `METADATA_LOADED`').to.equal(0);
                    eventEmitter.emit(constants_1.VIDEO_EVENTS.STATE_CHANGED, {
                        nextState: constants_1.EngineState.METADATA_LOADED,
                    });
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'indicators added after `METADATA_LOADED`').to.equal(3);
                });
            });
            describe('after `METADATA_LOADED`', function () {
                beforeEach(function () {
                    control.clearTimeIndicators();
                    Reflect.defineProperty(control._engine, 'isMetadataLoaded', tslib_1.__assign({}, Reflect.getOwnPropertyDescriptor(engine.constructor.prototype, 'isMetadataLoaded'), { get: function () { return true; } }));
                });
                afterEach(function () {
                    Reflect.deleteProperty(engine, 'isMetadataLoaded');
                });
                it('should add one indicator', function () {
                    var timeIndicatorsNode = control.view._$timeIndicators;
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'empty before add').to.equal(0);
                    control.addTimeIndicator(100);
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'indicators added').to.equal(1);
                });
                it('should add multiple indicator', function () {
                    var timeIndicatorsNode = control.view._$timeIndicators;
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'empty before add').to.equal(0);
                    control.addTimeIndicators([100, 200, 300]);
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'indicators added').to.equal(3);
                });
                it('should ignore time more then video duration time', function () {
                    var timeIndicatorsNode = control.view._$timeIndicators;
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'empty before add').to.equal(0);
                    control.addTimeIndicator(VIDEO_DURATION_TIME + 1);
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'indicators added').to.equal(0);
                });
                it('should delete all added indicators', function () {
                    var timeIndicatorsNode = control.view._$timeIndicators;
                    control.addTimeIndicators([100, 200, 300]);
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'indicators added').to.equal(3);
                    control.clearTimeIndicators();
                    chai_1.expect(timeIndicatorsNode.childNodes.length, 'indicators after clear').to.equal(0);
                });
            });
        });
    });
    describe('video events listeners', function () {
        it('should call callback on playback status change', function () {
            var spy = sinon.spy(control, '_processStateChange');
            control._bindEvents();
            eventEmitter.emit(constants_1.VIDEO_EVENTS.STATE_CHANGED, {});
            chai_1.expect(spy.called).to.be.true;
        });
        it('should call callback on seek', function () {
            var spyPlayed = sinon.spy(control, '_updatePlayedIndicator');
            var spyBuffered = sinon.spy(control, '_updateBufferIndicator');
            control._bindEvents();
            eventEmitter.emit(constants_1.VIDEO_EVENTS.STATE_CHANGED, {
                nextState: constants_1.EngineState.SEEK_IN_PROGRESS,
            });
            chai_1.expect(spyPlayed.called).to.be.true;
            chai_1.expect(spyBuffered.called).to.be.true;
        });
        it('should call callback on duration update', function () {
            var spy = sinon.spy(control, '_updateBufferIndicator');
            control._bindEvents();
            eventEmitter.emit(constants_1.VIDEO_EVENTS.CHUNK_LOADED);
            chai_1.expect(spy.called).to.be.true;
        });
    });
    describe('internal methods', function () {
        it('should toggle playback on manipulation change', function () {
            var startSpy = sinon.spy(control, '_pauseVideoOnProgressManipulationStart');
            var stopSpy = sinon.spy(control, '_playVideoOnProgressManipulationEnd');
            control._onUserInteractionStarts();
            chai_1.expect(startSpy.called).to.be.true;
            control._onUserInteractionEnds();
            chai_1.expect(stopSpy.called).to.be.true;
            startSpy.restore();
            stopSpy.restore();
        });
        it('should toggle interval updates', function () {
            var startSpy = sinon.spy(control, '_startIntervalUpdates');
            control._processStateChange({ nextState: constants_1.EngineState.PLAYING });
            chai_1.expect(startSpy.called).to.be.true;
            var stopSpy = sinon.spy(control, '_stopIntervalUpdates');
            control._processStateChange({ nextState: constants_1.EngineState.PAUSED });
            chai_1.expect(stopSpy.called).to.be.true;
        });
        it('should start interval updates', function () {
            var spy = sinon.spy(window, 'setInterval');
            var stopSpy = sinon.spy(control, '_stopIntervalUpdates');
            control._startIntervalUpdates();
            chai_1.expect(spy.calledWith(control._updateControlOnInterval)).to.be.true;
            chai_1.expect(stopSpy.called).to.be.false;
            control._startIntervalUpdates();
            chai_1.expect(stopSpy.called).to.be.true;
            spy.restore();
        });
        it('should change current time of video', function () {
            var spy = sinon.spy(engine, 'setCurrentTime');
            control._changePlayedProgress(10);
            chai_1.expect(spy.called).to.be.true;
        });
        it('should update view', function () {
            var playedSpy = sinon.spy(control, 'updatePlayed');
            var bufferSpy = sinon.spy(control, 'updateBuffered');
            control._updatePlayedIndicator();
            chai_1.expect(playedSpy.called).to.be.true;
            control._updateBufferIndicator();
            chai_1.expect(bufferSpy.called).to.be.true;
        });
        it('should trigger update of both played and buffered', function () {
            var playedSpy = sinon.spy(control, '_updatePlayedIndicator');
            var bufferSpy = sinon.spy(control, '_updateBufferIndicator');
            control._updateControlOnInterval();
            chai_1.expect(playedSpy.called).to.be.true;
            chai_1.expect(bufferSpy.called).to.be.true;
        });
    });
});
//# sourceMappingURL=progress.spec.js.map