'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Transform operations `a` by operations `b` with `priority`.
 *
 * @param {Array} a
 * @param {Array} b
 * @param {String} priority
 */

function transform(a, b, priority) {
  // Deeply clone A so that the transformers can edit in place without worry.
  a = (0, _cloneDeep2.default)(a);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = b[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var bo = _step.value;

      // Create a temporary array to store the new A operations, because sometimes
      // the transformers need to return `null` to remove an operation, or return
      // an array to add operations.
      var tmp = [];

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = a[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var ao = _step2.value;

          var ret = t(ao, bo, priority);

          if (ret === null) {
            continue;
          } else if (Array.isArray(ret)) {
            tmp = tmp.concat(ret);
          } else {
            tmp.push(ao);
          }
        }

        // Update A for the next iteration.
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      a = tmp;
    }

    // Return the transformed A operations.
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return a;
}

/**
 * Find the place where path `a` is intersected by path `b`, if it does.
 *
 * @param {Array} a
 * @param {Array} b
 * @return {String|Null}
 */

function intersectPath(a, b) {
  if (a == null || b == null) return null;

  for (var i = 0; i < b.length; i++) {
    var bv = b[i];
    var av = a[i];
    var al = i + 1 === a.length;
    var bl = i + 1 === b.length;
    // If ever `bv > av`, `b` doesn't intersect `a`.
    if (bv > av) return 'none';
    // If we're not at the end of `b`, and `bv < av`, `b` doesn't intersect `a`.
    if (!bl && bv < av) return 'none';
    // If at the end of both, and `bv == av`, `b` is exactly equal to `a`.
    if (al && bl && bv == av) return 'exact';
    // If only at the end of `b`, and `bv == av`, `b` is above `a`.
    if (bl && bv == av) return 'above';
    // If at the end of `b`, and `bv < av`, `b` is before `a`.
    if (bl && bv < av) return 'before';
  }

  return 'none';
}

/**
 * Find the place where `a`'s offset `a` is intersected by operation B's
 * offset `b`, if it does at all.
 *
 * @param {Number} a
 * @param {Number} b
 * @return {String}
 */

function intersectOffset(a, b) {
  if (a == null || b == null) return null;
  if (b < a) return 'before';
  if (b == a) return 'exact';
  return 'after';
}

/**
 * Transform operation `a` in place based on operation `b` and priority `p`.
 *
 * @param {Object} a
 * @param {Object} b
 * @param {String} p
 */

function t(a, b, p) {
  var i = b.path.length - 1;
  var ni = b.newPath ? b.newPath.length - 1 : null;

  var ap_bp = intersectPath(a.path, b.path);
  var ap_bnp = intersectPath(a.path, b.newPath);
  var anp_bp = intersectPath(a.newPath, b.path);
  var anp_bnp = intersectPath(a.newPath, b.newPath);
  var awp_bp = intersectPath(a.withPath, b.path);
  var ap_bwp = intersectPath(a.path, b.withPath);

  var ao_bo = intersectOffset(a.offset, b.offset);
  var ao_bol = intersectOffset(a.offset, b.offset + b.length);
  var aol_bo = intersectOffset(a.offset + a.length, b.offset);
  var aol_bol = intersectOffset(a.offset + a.length, b.offset + b.length);

  /**
   * Insert node.
   */

  if (b.type == 'insert_node') {
    // If A is a `join_node` operation, and B's path intersects A's exactly, a
    // node was inserted between where the join was supposed to happen, so we
    // add an extra `move_node` operation to keep the join from failing.
    if (a.type == 'join_node' && ap_bp == 'exact') {
      var newPath = a.path.slice();
      var path = newPath.slice(0, -1).concat([newPath[i] + 1]);
      var move = { type: 'move_node', path: path, newPath: newPath };
      return [move, a];
    }

    // If B's path intersects before, above, or exactly at A's path, increment
    // A's path to account for the inserted node. If operation A is an
    // `insert_node` operation, check for priority to maintain ordering.
    if (ap_bp == 'before' || ap_bp == 'above' || ap_bp == 'exact' && a.type != 'insert_node' || ap_bp == 'exact' && a.type == 'insert_node' && p == 'right') {
      a.path[i]++;
      if (a.withPath) a.withPath[i]++;
    }

    // If B's path intersects before or above A's new path, or exactly at it
    // with priority, increment A's new path to account for the inserted node.
    if (anp_bp == 'before' || anp_bp == 'above' || anp_bp == 'exact' && p == 'right') {
      a.newPath[i]++;
    }
  }

  /**
   * Remove node.
   */

  if (b.type == 'remove_node') {
    // If A is a `join_node` operation, and B's path intersects exactly with one
    // of A's paths, one of the join targets was already removed, so remove the
    // other one as well.
    if (a.type == 'join_node' && (ap_bp == 'exact' || awp_bp == 'exact')) {
      var _path = ap_bp == 'exact' ? a.withPath.slice() : a.path.slice();
      var remove = { type: 'remove_node', path: _path };
      return [remove];
    }

    // If B's path intersects exactly at A's path, and operation A is not an
    // `insert_node` operation, ignore operation A because the node it is
    // targeting has already been removed.
    if (a.type != 'insert_node' && ap_bp == 'exact') {
      return null;
    }

    // If B's path intersects above of A's, ignore operation A because the
    // target has already been removed.
    if (ap_bp == 'above') {
      return null;
    }

    // If B's path intersects before A's, decrement A's to account for the
    // earlier node's removal.
    if (ap_bp == 'before') {
      a.path[i]--;
      if (a.withPath) a.withPath[i]--;
    }

    // If B's path intersects before A's `newPath`, decrement A's `newPath` to
    // account for the earlier node's removal.
    if (anp_bp == 'before') {
      a.newPath[i]--;
    }
  }

  /**
   * Join node.
   */

  if (b.type == 'join_node') {
    // If A is a `join_node` operation, and B's path intersects A's path
    // exactly, then ignore operation A.
    if (a.type == 'join_node' && ap_bp == 'exact') {
      return null;
    }

    // If A is an `insert_node` operation, and B's path intersects exactly with
    // A's, do nothing, because the insert path won't be affected.
    if (a.type == 'insert_node' && ap_bp == 'exact') {
      return;
    }

    // If A is a `remove_node` operation, and B's `withPath` intersects with
    // A's, then the removal target was already joined with another node, and we
    // need to remove the combined result node instead.
    if (ap_bp == 'exact') {
      a.path = b.withPath.slice();
    }

    // If B's path is before A's, decrement A's to account for the join.
    if (ap_bp == 'before' || ap_bp == 'above') {
      a.path[i]--;
      if (a.withPath) a.withPath[i]--;
    }

    // If B's path is before A's `newPath`, decrement A's `newPath` to account
    // for the join.
    if (anp_bp == 'before' || anp_bp == 'above') {
      a.newPath[i]--;
    }
  }

  /**
   * Insert text.
   */

  if (b.type == 'insert_text') {
    // If operation B's path doesn't exactly intersect with A's, then the text
    // insertion won't have any effect on it.
    if (ap_bp != 'exact') {
      return;
    }

    // If B's offset intersects befores A's, or at the same index as A's but
    // with priority, increment A's offset to account for the inserted text.
    if (ao_bo == 'before' || ao_bo == 'exact' && p == 'right') {
      a.offset += b.text.length;
    }
  }

  /**
   * Remove text.
   */

  if (b.type == 'remove_text') {
    // If operation B's path doesn't exactly intersect with A's, then the text
    // removal won't have any effect on it.
    if (ap_bp != 'exact') {
      return;
    }

    // If A is a `remove_text` operation, and B's `offset` intersects before A's
    // `offset`, decrement A's `offset` by the number of characters removed
    // before it, and A's `length` by the characters removed that overlap it.
    if (a.type == 'remove_text' && ao_bo == 'before') {
      var decrement = Math.min(b.length, a.offset - b.offset);
      var _remove = Math.min(a.length, b.length - decrement);
      a.offset -= decrement;
      a.length -= _remove;
    }

    // If A is a `remove_text` operation, and B intersects is exactly, decrement
    // A's `length` by B's `length` since that text is already removed.
    if (a.type == 'remove_text' && ao_bo == 'exact') {
      var _remove2 = Math.min(a.length, b.length);
      a.length -= _remove2;
    }

    // If A is a `remove_text` operation, and B's `offset` intersects after A's
    // `offset`, decrement A's `length` by any overlapping characters that have
    // already been removed.
    if (a.type == 'remove_text' && ao_bo == 'after') {
      var diff = b.offset - a.offset;
      var overlap = Math.max(0, Math.min(b.length, a.length - diff));
      var _remove3 = Math.min(a.length, overlap);
      a.length -= _remove3;
    }

    // If A is a `remove_text` operation, and after adjusting A's `offset` and
    // `length`, its `length` is zero, ignore A since it does nothing.
    if (a.type == 'remove_text') {
      if (a.length == 0) return null;
      return;
    }

    // If A is anything other than an `insert_text` operation, and if B's offset
    // intersects befores A's, or at the same index as A's but with priority,
    // decrement A's offset to account for the removed text.
    if (ao_bo == 'before' || ao_bo == 'exact' && a.type != 'insert_text') {
      var _remove4 = Math.min(a.offset, b.length);
      a.offset -= _remove4;
    }
  }

  /**
   * Add mark.
   */

  if (b.type == 'add_mark') {
    // If B's path doesn't intersect A's exactly, or either operation has no
    // `offset`, or B doesn't have priority, or the operations's `mark` don't
    // match, then B can't affect A, so abort.
    if (ap_bp != 'exact' || ao_bo == null || p != 'right' || !(0, _isEqual2.default)(a.mark, b.mark)) {
      return;
    }

    // If A is an `remove_mark` operation, and B's start intersects before A's,
    // shift A to omit the range removed by B.
    if (a.type == 'remove_mark' && ao_bo == 'before') {
      var skip = Math.min(b.length, a.offset - b.offset);
      var omit = Math.min(a.length, b.length - skip);
      a.offset += skip;
      a.length -= omit;
    }

    // If A is an `remove_mark` operation, and B's start intersects exactly at
    // A's, shift A to omit the range removed by B.
    if (a.type == 'remove_mark' && ao_bo == 'exact') {
      var _omit = Math.min(a.length, b.length);
      a.offset += _omit;
      a.length -= _omit;
    }

    // If A is an `remove_mark` operation, and B's start intersects after A's,
    // and B's end intersects before A's, we need to split A into two operations
    // since B removes the mark in the middle.
    if (a.type == 'remove_mark' && ao_bo == 'after' && aol_bol == 'before') {
      var before = b.offset - a.offset;
      var after = a.length - before - b.length;
      var middle = a.length - before - after;
      var first = _extends({}, a, { length: before });
      var second = _extends({}, a, { offset: a.offset + before + middle, length: after });
      return [first, second];
    }

    // If A is an `remove_mark` operation, and B's start intersects after A's,
    // remove the overlaping region from A.
    if (a.type == 'remove_mark' && ao_bo == 'after') {
      var _diff = b.offset - a.offset;
      var _overlap = Math.max(0, Math.min(b.length, a.length - _diff));
      var _remove5 = Math.min(a.length, _overlap);
      a.length -= _remove5;
    }

    // If A is an `remove_mark` operation, and its `length` is now zero, remove
    // it because it will have no effect.
    if (a.type == 'remove_mark' && a.length == 0) {
      return null;
    }
  }

  /**
   * Remove mark.
   */

  if (b.type == 'remove_mark') {
    // If B's path doesn't intersect A's exactly, or either operation has no
    // `offset`, or B doesn't have priority, or the operations's `mark` don't
    // match, then B can't affect A, so abort.
    if (ap_bp != 'exact' || ao_bo == null || p != 'right' || !(0, _isEqual2.default)(a.mark, b.mark)) {
      return;
    }

    // If A is an `add_mark` operation, and B's start intersects before A's,
    // shift A to omit the range removed by B.
    if (a.type == 'add_mark' && ao_bo == 'before') {
      var _skip = Math.min(b.length, a.offset - b.offset);
      var _omit2 = Math.min(a.length, b.length - _skip);
      a.offset += _skip;
      a.length -= _omit2;
    }

    // If A is an `add_mark` operation, and B's start intersects exactly at A's,
    // shift A to omit the range removed by B.
    if (a.type == 'add_mark' && ao_bo == 'exact') {
      var _omit3 = Math.min(a.length, b.length);
      a.offset += _omit3;
      a.length -= _omit3;
    }

    // If A is an `add_mark` operation, and B's start intersects after A's,
    // and B's end intersects before A's, we need to split A into two operations
    // since B removes the mark in the middle.
    if (a.type == 'add_mark' && ao_bo == 'after' && aol_bol == 'before') {
      var _before = b.offset - a.offset;
      var _after = a.length - _before - b.length;
      var _middle = a.length - _before - _after;
      var _first = _extends({}, a, { length: _before });
      var _second = _extends({}, a, { offset: a.offset + _before + _middle, length: _after });
      return [_first, _second];
    }

    // If A is an `add_mark` operation, and B's start intersects after A's,
    // remove the overlaping region from A.
    if (a.type == 'add_mark' && ao_bo == 'after') {
      var _diff2 = b.offset - a.offset;
      var _overlap2 = Math.max(0, Math.min(b.length, a.length - _diff2));
      var _remove6 = Math.min(a.length, _overlap2);
      a.length -= _remove6;
    }

    // If A is an `add_mark` operation, and its `length` is now zero, remove it
    // because it will have no effect.
    if (a.type == 'add_mark' && a.length == 0) {
      return null;
    }
  }

  // /**
  //  * Move node.
  //  */

  // if (b.type == 'move_node') {
  //   // If A is a `join_node` operation, and B's path intersected either one of
  //   // A's paths, then ignore A since the nodes are no longer adjacent.
  //   if (
  //     (a.type == 'join_node') &&
  //     (ap_bp == 'same' || awp_bp == 'same') &&
  //     (p == 'right')
  //   ) {
  //     return null
  //   }

  //   // If B's old path intersects at A's, and B has priority, then update A's
  //   // path to refer to B's new path where the node has moved to.
  //   if (ap_bp == 'same' && p == 'right') {
  //     a.path = b.newPath.concat(a.path.slice(b.newPath.length))
  //   }

  //   // If A has a `newPath`, and `b.path` intersects at `a.path`, and `b` has
  //   // priority, and `b.newPath` doesn't intersect, decrement.
  //   if (anp_bp == 'same' && p == 'right' && anp_bnp == 'none') {
  //     a.newPath[i]--
  //   }

  //   // If B's old path intersected A's, but it's new one doesn't, then decrement
  //   // A's to account for the move.
  //   if (
  //     (ap_bp == 'before') &&
  //     ((ap_bnp == 'none') || (ap_bnp == 'same' && p == 'right'))
  //   ) {
  //     a.path[i]--
  //     if (a.withPath) a.withPath[i]--
  //   }

  //   // If B's old path intersects A's new path, and it's previous one doesn't,
  //   // then decrement A's to account for the move.
  //   if (
  //     (anp_bp == 'before') &&
  //     ((anp_bnp == 'none') || (anp_bnp == 'same' && p == 'right'))
  //   ) {
  //     a.newPath[i]--
  //   }

  //   // If B's new path intersects A's, and it's previous one doesn't, then
  //   // increment A's to account for the move.
  //   if (
  //     (ap_bp == 'none') &&
  //     ((ap_bnp == 'before') || (ap_bnp == 'same' && p == 'right'))
  //   ) {
  //     a.path[ni]++
  //     if (a.withPath) a.withPath[ni]++
  //   }

  //   // If A's new path wasn't intersected by B's old path, but is by B's new
  //   // path, then increment it to account for the move.
  //   if (
  //     (anp_bp == 'none') &&
  //     ((anp_bnp == 'before') || (anp_bnp == 'same' && p == 'right'))
  //   ) {
  //     a.newPath[ni]++
  //   }
  // }

  // /**
  //  * Split node.
  //  */

  // if (b.type == 'split_node') {
  //   // If `b.path` intersects before `a.path`, increment.
  //   if (ap_bp == 'before') {
  //     a.path[i]++
  //     if (a.withPath) a.withPath[i]++
  //   }

  //   // If `b.path` intersects at `a.path`, and `b` has priority, and `a` is a
  //   // `remove_node` operation, then ignore `a`.
  //   if (a.type == 'remove_node' && ap_bp == 'same' && p == 'right') {
  //     return null
  //   }

  //   // If `b.path` intersects at `a.path`, and `b` has priority, and `a` is a
  //   // `split_node` operation, then increment `a.path` and decrement `a.offset`.
  //   if (a.type == 'split_node' && ap_bp == 'same' && p == 'right') {
  //     a.path[i]++
  //     a.offset -= b.offset
  //   }

  //   // If `b.path` intersects at `a.path`, and `b` has priority, increment
  //   // `a.path`.
  //   if (ap_bp == 'same' && p == 'right') {
  //     a.path[i]++
  //     if (a.withPath) a.withPath[i]++
  //   }

  //   // If `b.path` intersects at `a.path`, and `b` has priority, and A is a
  //   // `remove_node` operation, then ignore A.
  //   if (a.type == 'remove_node' && awp_bp == 'same' && p == 'right') {
  //     return null
  //   }

  //   // If A has a `newPath`, and `b.path` intersects before `a.path`, increment A's
  //   // path.
  //   if (anp_bp == 'before') {
  //     a.newPath[i]++
  //   }

  //   // If `b.path` intersects at `a.newPath`, and `b` has priority, increment
  //   // `a.newPath`.
  //   if (anp_bp == 'same' && p == 'right') {
  //     a.newPath[i]++
  //   }
  // }
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = transform;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9vdC90cmFuc2Zvcm0uanMiXSwibmFtZXMiOlsidHJhbnNmb3JtIiwiYSIsImIiLCJwcmlvcml0eSIsImJvIiwidG1wIiwiYW8iLCJyZXQiLCJ0IiwiQXJyYXkiLCJpc0FycmF5IiwiY29uY2F0IiwicHVzaCIsImludGVyc2VjdFBhdGgiLCJpIiwibGVuZ3RoIiwiYnYiLCJhdiIsImFsIiwiYmwiLCJpbnRlcnNlY3RPZmZzZXQiLCJwIiwicGF0aCIsIm5pIiwibmV3UGF0aCIsImFwX2JwIiwiYXBfYm5wIiwiYW5wX2JwIiwiYW5wX2JucCIsImF3cF9icCIsIndpdGhQYXRoIiwiYXBfYndwIiwiYW9fYm8iLCJvZmZzZXQiLCJhb19ib2wiLCJhb2xfYm8iLCJhb2xfYm9sIiwidHlwZSIsInNsaWNlIiwibW92ZSIsInJlbW92ZSIsInRleHQiLCJkZWNyZW1lbnQiLCJNYXRoIiwibWluIiwiZGlmZiIsIm92ZXJsYXAiLCJtYXgiLCJtYXJrIiwic2tpcCIsIm9taXQiLCJiZWZvcmUiLCJhZnRlciIsIm1pZGRsZSIsImZpcnN0Iiwic2Vjb25kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7OztBQVFBLFNBQVNBLFNBQVQsQ0FBbUJDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QkMsUUFBekIsRUFBbUM7QUFDakM7QUFDQUYsTUFBSSx5QkFBVUEsQ0FBVixDQUFKOztBQUZpQztBQUFBO0FBQUE7O0FBQUE7QUFJakMseUJBQWlCQyxDQUFqQiw4SEFBb0I7QUFBQSxVQUFURSxFQUFTOztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFJQyxNQUFNLEVBQVY7O0FBSmtCO0FBQUE7QUFBQTs7QUFBQTtBQU1sQiw4QkFBaUJKLENBQWpCLG1JQUFvQjtBQUFBLGNBQVRLLEVBQVM7O0FBQ2xCLGNBQU1DLE1BQU1DLEVBQUVGLEVBQUYsRUFBTUYsRUFBTixFQUFVRCxRQUFWLENBQVo7O0FBRUEsY0FBSUksUUFBUSxJQUFa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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztrQkFNZWYsUyIsImZpbGUiOiJ0cmFuc2Zvcm0uanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoL2Nsb25lRGVlcCdcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJ1xuXG4vKipcbiAqIFRyYW5zZm9ybSBvcGVyYXRpb25zIGBhYCBieSBvcGVyYXRpb25zIGBiYCB3aXRoIGBwcmlvcml0eWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYVxuICogQHBhcmFtIHtBcnJheX0gYlxuICogQHBhcmFtIHtTdHJpbmd9IHByaW9yaXR5XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtKGEsIGIsIHByaW9yaXR5KSB7XG4gIC8vIERlZXBseSBjbG9uZSBBIHNvIHRoYXQgdGhlIHRyYW5zZm9ybWVycyBjYW4gZWRpdCBpbiBwbGFjZSB3aXRob3V0IHdvcnJ5LlxuICBhID0gY2xvbmVEZWVwKGEpXG5cbiAgZm9yIChjb25zdCBibyBvZiBiKSB7XG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGFycmF5IHRvIHN0b3JlIHRoZSBuZXcgQSBvcGVyYXRpb25zLCBiZWNhdXNlIHNvbWV0aW1lc1xuICAgIC8vIHRoZSB0cmFuc2Zvcm1lcnMgbmVlZCB0byByZXR1cm4gYG51bGxgIHRvIHJlbW92ZSBhbiBvcGVyYXRpb24sIG9yIHJldHVyblxuICAgIC8vIGFuIGFycmF5IHRvIGFkZCBvcGVyYXRpb25zLlxuICAgIGxldCB0bXAgPSBbXVxuXG4gICAgZm9yIChjb25zdCBhbyBvZiBhKSB7XG4gICAgICBjb25zdCByZXQgPSB0KGFvLCBibywgcHJpb3JpdHkpXG5cbiAgICAgIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXQpKSB7XG4gICAgICAgIHRtcCA9IHRtcC5jb25jYXQocmV0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1wLnB1c2goYW8pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIEEgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICBhID0gdG1wXG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHRyYW5zZm9ybWVkIEEgb3BlcmF0aW9ucy5cbiAgcmV0dXJuIGFcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBwbGFjZSB3aGVyZSBwYXRoIGBhYCBpcyBpbnRlcnNlY3RlZCBieSBwYXRoIGBiYCwgaWYgaXQgZG9lcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhXG4gKiBAcGFyYW0ge0FycmF5fSBiXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBpbnRlcnNlY3RQYXRoKGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBudWxsXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnYgPSBiW2ldXG4gICAgY29uc3QgYXYgPSBhW2ldXG4gICAgY29uc3QgYWwgPSBpICsgMSA9PT0gYS5sZW5ndGhcbiAgICBjb25zdCBibCA9IGkgKyAxID09PSBiLmxlbmd0aFxuICAgIC8vIElmIGV2ZXIgYGJ2ID4gYXZgLCBgYmAgZG9lc24ndCBpbnRlcnNlY3QgYGFgLlxuICAgIGlmIChidiA+IGF2KSByZXR1cm4gJ25vbmUnXG4gICAgLy8gSWYgd2UncmUgbm90IGF0IHRoZSBlbmQgb2YgYGJgLCBhbmQgYGJ2IDwgYXZgLCBgYmAgZG9lc24ndCBpbnRlcnNlY3QgYGFgLlxuICAgIGlmICghYmwgJiYgYnYgPCBhdikgcmV0dXJuICdub25lJ1xuICAgIC8vIElmIGF0IHRoZSBlbmQgb2YgYm90aCwgYW5kIGBidiA9PSBhdmAsIGBiYCBpcyBleGFjdGx5IGVxdWFsIHRvIGBhYC5cbiAgICBpZiAoYWwgJiYgYmwgJiYgYnYgPT0gYXYpIHJldHVybiAnZXhhY3QnXG4gICAgLy8gSWYgb25seSBhdCB0aGUgZW5kIG9mIGBiYCwgYW5kIGBidiA9PSBhdmAsIGBiYCBpcyBhYm92ZSBgYWAuXG4gICAgaWYgKGJsICYmIGJ2ID09IGF2KSByZXR1cm4gJ2Fib3ZlJ1xuICAgIC8vIElmIGF0IHRoZSBlbmQgb2YgYGJgLCBhbmQgYGJ2IDwgYXZgLCBgYmAgaXMgYmVmb3JlIGBhYC5cbiAgICBpZiAoYmwgJiYgYnYgPCBhdikgcmV0dXJuICdiZWZvcmUnXG4gIH1cblxuICByZXR1cm4gJ25vbmUnXG59XG5cbi8qKlxuICogRmluZCB0aGUgcGxhY2Ugd2hlcmUgYGFgJ3Mgb2Zmc2V0IGBhYCBpcyBpbnRlcnNlY3RlZCBieSBvcGVyYXRpb24gQidzXG4gKiBvZmZzZXQgYGJgLCBpZiBpdCBkb2VzIGF0IGFsbC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYVxuICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBpbnRlcnNlY3RPZmZzZXQoYSwgYikge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIG51bGxcbiAgaWYgKGIgPCBhKSByZXR1cm4gJ2JlZm9yZSdcbiAgaWYgKGIgPT0gYSkgcmV0dXJuICdleGFjdCdcbiAgcmV0dXJuICdhZnRlcidcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gb3BlcmF0aW9uIGBhYCBpbiBwbGFjZSBiYXNlZCBvbiBvcGVyYXRpb24gYGJgIGFuZCBwcmlvcml0eSBgcGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcGFyYW0ge1N0cmluZ30gcFxuICovXG5cbmZ1bmN0aW9uIHQoYSwgYiwgcCkge1xuICBjb25zdCBpID0gYi5wYXRoLmxlbmd0aCAtIDFcbiAgY29uc3QgbmkgPSBiLm5ld1BhdGggPyBiLm5ld1BhdGgubGVuZ3RoIC0gMSA6IG51bGxcblxuICBjb25zdCBhcF9icCA9IGludGVyc2VjdFBhdGgoYS5wYXRoLCBiLnBhdGgpXG4gIGNvbnN0IGFwX2JucCA9IGludGVyc2VjdFBhdGgoYS5wYXRoLCBiLm5ld1BhdGgpXG4gIGNvbnN0IGFucF9icCA9IGludGVyc2VjdFBhdGgoYS5uZXdQYXRoLCBiLnBhdGgpXG4gIGNvbnN0IGFucF9ibnAgPSBpbnRlcnNlY3RQYXRoKGEubmV3UGF0aCwgYi5uZXdQYXRoKVxuICBjb25zdCBhd3BfYnAgPSBpbnRlcnNlY3RQYXRoKGEud2l0aFBhdGgsIGIucGF0aClcbiAgY29uc3QgYXBfYndwID0gaW50ZXJzZWN0UGF0aChhLnBhdGgsIGIud2l0aFBhdGgpXG5cbiAgY29uc3QgYW9fYm8gPSBpbnRlcnNlY3RPZmZzZXQoYS5vZmZzZXQsIGIub2Zmc2V0KVxuICBjb25zdCBhb19ib2wgPSBpbnRlcnNlY3RPZmZzZXQoYS5vZmZzZXQsIGIub2Zmc2V0ICsgYi5sZW5ndGgpXG4gIGNvbnN0IGFvbF9ibyA9IGludGVyc2VjdE9mZnNldChhLm9mZnNldCArIGEubGVuZ3RoLCBiLm9mZnNldClcbiAgY29uc3QgYW9sX2JvbCA9IGludGVyc2VjdE9mZnNldChhLm9mZnNldCArIGEubGVuZ3RoLCBiLm9mZnNldCArIGIubGVuZ3RoKVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgbm9kZS5cbiAgICovXG5cbiAgaWYgKGIudHlwZSA9PSAnaW5zZXJ0X25vZGUnKSB7XG4gICAgLy8gSWYgQSBpcyBhIGBqb2luX25vZGVgIG9wZXJhdGlvbiwgYW5kIEIncyBwYXRoIGludGVyc2VjdHMgQSdzIGV4YWN0bHksIGFcbiAgICAvLyBub2RlIHdhcyBpbnNlcnRlZCBiZXR3ZWVuIHdoZXJlIHRoZSBqb2luIHdhcyBzdXBwb3NlZCB0byBoYXBwZW4sIHNvIHdlXG4gICAgLy8gYWRkIGFuIGV4dHJhIGBtb3ZlX25vZGVgIG9wZXJhdGlvbiB0byBrZWVwIHRoZSBqb2luIGZyb20gZmFpbGluZy5cbiAgICBpZiAoYS50eXBlID09ICdqb2luX25vZGUnICYmIGFwX2JwID09ICdleGFjdCcpIHtcbiAgICAgIGNvbnN0IG5ld1BhdGggPSBhLnBhdGguc2xpY2UoKVxuICAgICAgY29uc3QgcGF0aCA9IG5ld1BhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChbbmV3UGF0aFtpXSArIDFdKVxuICAgICAgY29uc3QgbW92ZSA9IHsgdHlwZTogJ21vdmVfbm9kZScsIHBhdGgsIG5ld1BhdGggfVxuICAgICAgcmV0dXJuIFttb3ZlLCBhXVxuICAgIH1cblxuICAgIC8vIElmIEIncyBwYXRoIGludGVyc2VjdHMgYmVmb3JlLCBhYm92ZSwgb3IgZXhhY3RseSBhdCBBJ3MgcGF0aCwgaW5jcmVtZW50XG4gICAgLy8gQSdzIHBhdGggdG8gYWNjb3VudCBmb3IgdGhlIGluc2VydGVkIG5vZGUuIElmIG9wZXJhdGlvbiBBIGlzIGFuXG4gICAgLy8gYGluc2VydF9ub2RlYCBvcGVyYXRpb24sIGNoZWNrIGZvciBwcmlvcml0eSB0byBtYWludGFpbiBvcmRlcmluZy5cbiAgICBpZiAoXG4gICAgICAoYXBfYnAgPT0gJ2JlZm9yZScpIHx8XG4gICAgICAoYXBfYnAgPT0gJ2Fib3ZlJykgfHxcbiAgICAgIChhcF9icCA9PSAnZXhhY3QnICYmIGEudHlwZSAhPSAnaW5zZXJ0X25vZGUnKSB8fFxuICAgICAgKGFwX2JwID09ICdleGFjdCcgJiYgYS50eXBlID09ICdpbnNlcnRfbm9kZScgJiYgcCA9PSAncmlnaHQnKVxuICAgICkge1xuICAgICAgYS5wYXRoW2ldKytcbiAgICAgIGlmIChhLndpdGhQYXRoKSBhLndpdGhQYXRoW2ldKytcbiAgICB9XG5cbiAgICAvLyBJZiBCJ3MgcGF0aCBpbnRlcnNlY3RzIGJlZm9yZSBvciBhYm92ZSBBJ3MgbmV3IHBhdGgsIG9yIGV4YWN0bHkgYXQgaXRcbiAgICAvLyB3aXRoIHByaW9yaXR5LCBpbmNyZW1lbnQgQSdzIG5ldyBwYXRoIHRvIGFjY291bnQgZm9yIHRoZSBpbnNlcnRlZCBub2RlLlxuICAgIGlmIChcbiAgICAgIChhbnBfYnAgPT0gJ2JlZm9yZScpIHx8XG4gICAgICAoYW5wX2JwID09ICdhYm92ZScpIHx8XG4gICAgICAoYW5wX2JwID09ICdleGFjdCcgJiYgcCA9PSAncmlnaHQnKVxuICAgICkge1xuICAgICAgYS5uZXdQYXRoW2ldKytcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG5vZGUuXG4gICAqL1xuXG4gIGlmIChiLnR5cGUgPT0gJ3JlbW92ZV9ub2RlJykge1xuICAgIC8vIElmIEEgaXMgYSBgam9pbl9ub2RlYCBvcGVyYXRpb24sIGFuZCBCJ3MgcGF0aCBpbnRlcnNlY3RzIGV4YWN0bHkgd2l0aCBvbmVcbiAgICAvLyBvZiBBJ3MgcGF0aHMsIG9uZSBvZiB0aGUgam9pbiB0YXJnZXRzIHdhcyBhbHJlYWR5IHJlbW92ZWQsIHNvIHJlbW92ZSB0aGVcbiAgICAvLyBvdGhlciBvbmUgYXMgd2VsbC5cbiAgICBpZiAoXG4gICAgICAoYS50eXBlID09ICdqb2luX25vZGUnKSAmJlxuICAgICAgKGFwX2JwID09ICdleGFjdCcgfHwgYXdwX2JwID09ICdleGFjdCcpXG4gICAgKSB7XG4gICAgICBjb25zdCBwYXRoID0gYXBfYnAgPT0gJ2V4YWN0JyA/IGEud2l0aFBhdGguc2xpY2UoKSA6IGEucGF0aC5zbGljZSgpXG4gICAgICBjb25zdCByZW1vdmUgPSB7IHR5cGU6ICdyZW1vdmVfbm9kZScsIHBhdGggfVxuICAgICAgcmV0dXJuIFtyZW1vdmVdXG4gICAgfVxuXG4gICAgLy8gSWYgQidzIHBhdGggaW50ZXJzZWN0cyBleGFjdGx5IGF0IEEncyBwYXRoLCBhbmQgb3BlcmF0aW9uIEEgaXMgbm90IGFuXG4gICAgLy8gYGluc2VydF9ub2RlYCBvcGVyYXRpb24sIGlnbm9yZSBvcGVyYXRpb24gQSBiZWNhdXNlIHRoZSBub2RlIGl0IGlzXG4gICAgLy8gdGFyZ2V0aW5nIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cbiAgICBpZiAoYS50eXBlICE9ICdpbnNlcnRfbm9kZScgJiYgYXBfYnAgPT0gJ2V4YWN0Jykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBJZiBCJ3MgcGF0aCBpbnRlcnNlY3RzIGFib3ZlIG9mIEEncywgaWdub3JlIG9wZXJhdGlvbiBBIGJlY2F1c2UgdGhlXG4gICAgLy8gdGFyZ2V0IGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cbiAgICBpZiAoYXBfYnAgPT0gJ2Fib3ZlJykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBJZiBCJ3MgcGF0aCBpbnRlcnNlY3RzIGJlZm9yZSBBJ3MsIGRlY3JlbWVudCBBJ3MgdG8gYWNjb3VudCBmb3IgdGhlXG4gICAgLy8gZWFybGllciBub2RlJ3MgcmVtb3ZhbC5cbiAgICBpZiAoYXBfYnAgPT0gJ2JlZm9yZScpIHtcbiAgICAgIGEucGF0aFtpXS0tXG4gICAgICBpZiAoYS53aXRoUGF0aCkgYS53aXRoUGF0aFtpXS0tXG4gICAgfVxuXG4gICAgLy8gSWYgQidzIHBhdGggaW50ZXJzZWN0cyBiZWZvcmUgQSdzIGBuZXdQYXRoYCwgZGVjcmVtZW50IEEncyBgbmV3UGF0aGAgdG9cbiAgICAvLyBhY2NvdW50IGZvciB0aGUgZWFybGllciBub2RlJ3MgcmVtb3ZhbC5cbiAgICBpZiAoYW5wX2JwID09ICdiZWZvcmUnKSB7XG4gICAgICBhLm5ld1BhdGhbaV0tLVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBKb2luIG5vZGUuXG4gICAqL1xuXG4gIGlmIChiLnR5cGUgPT0gJ2pvaW5fbm9kZScpIHtcbiAgICAvLyBJZiBBIGlzIGEgYGpvaW5fbm9kZWAgb3BlcmF0aW9uLCBhbmQgQidzIHBhdGggaW50ZXJzZWN0cyBBJ3MgcGF0aFxuICAgIC8vIGV4YWN0bHksIHRoZW4gaWdub3JlIG9wZXJhdGlvbiBBLlxuICAgIGlmIChhLnR5cGUgPT0gJ2pvaW5fbm9kZScgJiYgYXBfYnAgPT0gJ2V4YWN0Jykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGFuIGBpbnNlcnRfbm9kZWAgb3BlcmF0aW9uLCBhbmQgQidzIHBhdGggaW50ZXJzZWN0cyBleGFjdGx5IHdpdGhcbiAgICAvLyBBJ3MsIGRvIG5vdGhpbmcsIGJlY2F1c2UgdGhlIGluc2VydCBwYXRoIHdvbid0IGJlIGFmZmVjdGVkLlxuICAgIGlmIChhLnR5cGUgPT0gJ2luc2VydF9ub2RlJyAmJiBhcF9icCA9PSAnZXhhY3QnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGEgYHJlbW92ZV9ub2RlYCBvcGVyYXRpb24sIGFuZCBCJ3MgYHdpdGhQYXRoYCBpbnRlcnNlY3RzIHdpdGhcbiAgICAvLyBBJ3MsIHRoZW4gdGhlIHJlbW92YWwgdGFyZ2V0IHdhcyBhbHJlYWR5IGpvaW5lZCB3aXRoIGFub3RoZXIgbm9kZSwgYW5kIHdlXG4gICAgLy8gbmVlZCB0byByZW1vdmUgdGhlIGNvbWJpbmVkIHJlc3VsdCBub2RlIGluc3RlYWQuXG4gICAgaWYgKGFwX2JwID09ICdleGFjdCcpIHtcbiAgICAgIGEucGF0aCA9IGIud2l0aFBhdGguc2xpY2UoKVxuICAgIH1cblxuICAgIC8vIElmIEIncyBwYXRoIGlzIGJlZm9yZSBBJ3MsIGRlY3JlbWVudCBBJ3MgdG8gYWNjb3VudCBmb3IgdGhlIGpvaW4uXG4gICAgaWYgKFxuICAgICAgKGFwX2JwID09ICdiZWZvcmUnKSB8fFxuICAgICAgKGFwX2JwID09ICdhYm92ZScpXG4gICAgKSB7XG4gICAgICBhLnBhdGhbaV0tLVxuICAgICAgaWYgKGEud2l0aFBhdGgpIGEud2l0aFBhdGhbaV0tLVxuICAgIH1cblxuICAgIC8vIElmIEIncyBwYXRoIGlzIGJlZm9yZSBBJ3MgYG5ld1BhdGhgLCBkZWNyZW1lbnQgQSdzIGBuZXdQYXRoYCB0byBhY2NvdW50XG4gICAgLy8gZm9yIHRoZSBqb2luLlxuICAgIGlmIChcbiAgICAgIChhbnBfYnAgPT0gJ2JlZm9yZScpIHx8XG4gICAgICAoYW5wX2JwID09ICdhYm92ZScpXG4gICAgKSB7XG4gICAgICBhLm5ld1BhdGhbaV0tLVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgdGV4dC5cbiAgICovXG5cbiAgaWYgKGIudHlwZSA9PSAnaW5zZXJ0X3RleHQnKSB7XG4gICAgLy8gSWYgb3BlcmF0aW9uIEIncyBwYXRoIGRvZXNuJ3QgZXhhY3RseSBpbnRlcnNlY3Qgd2l0aCBBJ3MsIHRoZW4gdGhlIHRleHRcbiAgICAvLyBpbnNlcnRpb24gd29uJ3QgaGF2ZSBhbnkgZWZmZWN0IG9uIGl0LlxuICAgIGlmIChhcF9icCAhPSAnZXhhY3QnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBCJ3Mgb2Zmc2V0IGludGVyc2VjdHMgYmVmb3JlcyBBJ3MsIG9yIGF0IHRoZSBzYW1lIGluZGV4IGFzIEEncyBidXRcbiAgICAvLyB3aXRoIHByaW9yaXR5LCBpbmNyZW1lbnQgQSdzIG9mZnNldCB0byBhY2NvdW50IGZvciB0aGUgaW5zZXJ0ZWQgdGV4dC5cbiAgICBpZiAoXG4gICAgICAoYW9fYm8gPT0gJ2JlZm9yZScpIHx8XG4gICAgICAoYW9fYm8gPT0gJ2V4YWN0JyAmJiBwID09ICdyaWdodCcpXG4gICAgKSB7XG4gICAgICBhLm9mZnNldCArPSBiLnRleHQubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0ZXh0LlxuICAgKi9cblxuICBpZiAoYi50eXBlID09ICdyZW1vdmVfdGV4dCcpIHtcbiAgICAvLyBJZiBvcGVyYXRpb24gQidzIHBhdGggZG9lc24ndCBleGFjdGx5IGludGVyc2VjdCB3aXRoIEEncywgdGhlbiB0aGUgdGV4dFxuICAgIC8vIHJlbW92YWwgd29uJ3QgaGF2ZSBhbnkgZWZmZWN0IG9uIGl0LlxuICAgIGlmIChhcF9icCAhPSAnZXhhY3QnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGEgYHJlbW92ZV90ZXh0YCBvcGVyYXRpb24sIGFuZCBCJ3MgYG9mZnNldGAgaW50ZXJzZWN0cyBiZWZvcmUgQSdzXG4gICAgLy8gYG9mZnNldGAsIGRlY3JlbWVudCBBJ3MgYG9mZnNldGAgYnkgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHJlbW92ZWRcbiAgICAvLyBiZWZvcmUgaXQsIGFuZCBBJ3MgYGxlbmd0aGAgYnkgdGhlIGNoYXJhY3RlcnMgcmVtb3ZlZCB0aGF0IG92ZXJsYXAgaXQuXG4gICAgaWYgKGEudHlwZSA9PSAncmVtb3ZlX3RleHQnICYmIGFvX2JvID09ICdiZWZvcmUnKSB7XG4gICAgICBjb25zdCBkZWNyZW1lbnQgPSBNYXRoLm1pbihiLmxlbmd0aCwgYS5vZmZzZXQgLSBiLm9mZnNldClcbiAgICAgIGNvbnN0IHJlbW92ZSA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCAtIGRlY3JlbWVudClcbiAgICAgIGEub2Zmc2V0IC09IGRlY3JlbWVudFxuICAgICAgYS5sZW5ndGggLT0gcmVtb3ZlXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhIGByZW1vdmVfdGV4dGAgb3BlcmF0aW9uLCBhbmQgQiBpbnRlcnNlY3RzIGlzIGV4YWN0bHksIGRlY3JlbWVudFxuICAgIC8vIEEncyBgbGVuZ3RoYCBieSBCJ3MgYGxlbmd0aGAgc2luY2UgdGhhdCB0ZXh0IGlzIGFscmVhZHkgcmVtb3ZlZC5cbiAgICBpZiAoYS50eXBlID09ICdyZW1vdmVfdGV4dCcgJiYgYW9fYm8gPT0gJ2V4YWN0Jykge1xuICAgICAgY29uc3QgcmVtb3ZlID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICAgICAgYS5sZW5ndGggLT0gcmVtb3ZlXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhIGByZW1vdmVfdGV4dGAgb3BlcmF0aW9uLCBhbmQgQidzIGBvZmZzZXRgIGludGVyc2VjdHMgYWZ0ZXIgQSdzXG4gICAgLy8gYG9mZnNldGAsIGRlY3JlbWVudCBBJ3MgYGxlbmd0aGAgYnkgYW55IG92ZXJsYXBwaW5nIGNoYXJhY3RlcnMgdGhhdCBoYXZlXG4gICAgLy8gYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG4gICAgaWYgKGEudHlwZSA9PSAncmVtb3ZlX3RleHQnICYmIGFvX2JvID09ICdhZnRlcicpIHtcbiAgICAgIGNvbnN0IGRpZmYgPSBiLm9mZnNldCAtIGEub2Zmc2V0XG4gICAgICBjb25zdCBvdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYi5sZW5ndGgsIGEubGVuZ3RoIC0gZGlmZikpXG4gICAgICBjb25zdCByZW1vdmUgPSBNYXRoLm1pbihhLmxlbmd0aCwgb3ZlcmxhcClcbiAgICAgIGEubGVuZ3RoIC09IHJlbW92ZVxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgYSBgcmVtb3ZlX3RleHRgIG9wZXJhdGlvbiwgYW5kIGFmdGVyIGFkanVzdGluZyBBJ3MgYG9mZnNldGAgYW5kXG4gICAgLy8gYGxlbmd0aGAsIGl0cyBgbGVuZ3RoYCBpcyB6ZXJvLCBpZ25vcmUgQSBzaW5jZSBpdCBkb2VzIG5vdGhpbmcuXG4gICAgaWYgKGEudHlwZSA9PSAncmVtb3ZlX3RleHQnKSB7XG4gICAgICBpZiAoYS5sZW5ndGggPT0gMCkgcmV0dXJuIG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhbiBgaW5zZXJ0X3RleHRgIG9wZXJhdGlvbiwgYW5kIGlmIEIncyBvZmZzZXRcbiAgICAvLyBpbnRlcnNlY3RzIGJlZm9yZXMgQSdzLCBvciBhdCB0aGUgc2FtZSBpbmRleCBhcyBBJ3MgYnV0IHdpdGggcHJpb3JpdHksXG4gICAgLy8gZGVjcmVtZW50IEEncyBvZmZzZXQgdG8gYWNjb3VudCBmb3IgdGhlIHJlbW92ZWQgdGV4dC5cbiAgICBpZiAoXG4gICAgICAoYW9fYm8gPT0gJ2JlZm9yZScpIHx8XG4gICAgICAoYW9fYm8gPT0gJ2V4YWN0JyAmJiBhLnR5cGUgIT0gJ2luc2VydF90ZXh0JylcbiAgICApIHtcbiAgICAgIGNvbnN0IHJlbW92ZSA9IE1hdGgubWluKGEub2Zmc2V0LCBiLmxlbmd0aClcbiAgICAgIGEub2Zmc2V0IC09IHJlbW92ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbWFyay5cbiAgICovXG5cbiAgaWYgKGIudHlwZSA9PSAnYWRkX21hcmsnKSB7XG4gICAgLy8gSWYgQidzIHBhdGggZG9lc24ndCBpbnRlcnNlY3QgQSdzIGV4YWN0bHksIG9yIGVpdGhlciBvcGVyYXRpb24gaGFzIG5vXG4gICAgLy8gYG9mZnNldGAsIG9yIEIgZG9lc24ndCBoYXZlIHByaW9yaXR5LCBvciB0aGUgb3BlcmF0aW9ucydzIGBtYXJrYCBkb24ndFxuICAgIC8vIG1hdGNoLCB0aGVuIEIgY2FuJ3QgYWZmZWN0IEEsIHNvIGFib3J0LlxuICAgIGlmIChcbiAgICAgIGFwX2JwICE9ICdleGFjdCcgfHxcbiAgICAgIGFvX2JvID09IG51bGwgfHxcbiAgICAgIHAgIT0gJ3JpZ2h0JyB8fFxuICAgICAgIWlzRXF1YWwoYS5tYXJrLCBiLm1hcmspXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGFuIGByZW1vdmVfbWFya2Agb3BlcmF0aW9uLCBhbmQgQidzIHN0YXJ0IGludGVyc2VjdHMgYmVmb3JlIEEncyxcbiAgICAvLyBzaGlmdCBBIHRvIG9taXQgdGhlIHJhbmdlIHJlbW92ZWQgYnkgQi5cbiAgICBpZiAoYS50eXBlID09ICdyZW1vdmVfbWFyaycgJiYgYW9fYm8gPT0gJ2JlZm9yZScpIHtcbiAgICAgIGNvbnN0IHNraXAgPSBNYXRoLm1pbihiLmxlbmd0aCwgYS5vZmZzZXQgLSBiLm9mZnNldClcbiAgICAgIGNvbnN0IG9taXQgPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGggLSBza2lwKVxuICAgICAgYS5vZmZzZXQgKz0gc2tpcFxuICAgICAgYS5sZW5ndGggLT0gb21pdFxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgYW4gYHJlbW92ZV9tYXJrYCBvcGVyYXRpb24sIGFuZCBCJ3Mgc3RhcnQgaW50ZXJzZWN0cyBleGFjdGx5IGF0XG4gICAgLy8gQSdzLCBzaGlmdCBBIHRvIG9taXQgdGhlIHJhbmdlIHJlbW92ZWQgYnkgQi5cbiAgICBpZiAoYS50eXBlID09ICdyZW1vdmVfbWFyaycgJiYgYW9fYm8gPT0gJ2V4YWN0Jykge1xuICAgICAgY29uc3Qgb21pdCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgICAgIGEub2Zmc2V0ICs9IG9taXRcbiAgICAgIGEubGVuZ3RoIC09IG9taXRcbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGFuIGByZW1vdmVfbWFya2Agb3BlcmF0aW9uLCBhbmQgQidzIHN0YXJ0IGludGVyc2VjdHMgYWZ0ZXIgQSdzLFxuICAgIC8vIGFuZCBCJ3MgZW5kIGludGVyc2VjdHMgYmVmb3JlIEEncywgd2UgbmVlZCB0byBzcGxpdCBBIGludG8gdHdvIG9wZXJhdGlvbnNcbiAgICAvLyBzaW5jZSBCIHJlbW92ZXMgdGhlIG1hcmsgaW4gdGhlIG1pZGRsZS5cbiAgICBpZiAoYS50eXBlID09ICdyZW1vdmVfbWFyaycgJiYgYW9fYm8gPT0gJ2FmdGVyJyAmJiBhb2xfYm9sID09ICdiZWZvcmUnKSB7XG4gICAgICBjb25zdCBiZWZvcmUgPSBiLm9mZnNldCAtIGEub2Zmc2V0XG4gICAgICBjb25zdCBhZnRlciA9IGEubGVuZ3RoIC0gYmVmb3JlIC0gYi5sZW5ndGhcbiAgICAgIGNvbnN0IG1pZGRsZSA9IGEubGVuZ3RoIC0gYmVmb3JlIC0gYWZ0ZXJcbiAgICAgIGNvbnN0IGZpcnN0ID0geyAuLi5hLCBsZW5ndGg6IGJlZm9yZSB9XG4gICAgICBjb25zdCBzZWNvbmQgPSB7IC4uLmEsIG9mZnNldDogYS5vZmZzZXQgKyBiZWZvcmUgKyBtaWRkbGUsIGxlbmd0aDogYWZ0ZXIgfVxuICAgICAgcmV0dXJuIFtmaXJzdCwgc2Vjb25kXVxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgYW4gYHJlbW92ZV9tYXJrYCBvcGVyYXRpb24sIGFuZCBCJ3Mgc3RhcnQgaW50ZXJzZWN0cyBhZnRlciBBJ3MsXG4gICAgLy8gcmVtb3ZlIHRoZSBvdmVybGFwaW5nIHJlZ2lvbiBmcm9tIEEuXG4gICAgaWYgKGEudHlwZSA9PSAncmVtb3ZlX21hcmsnICYmIGFvX2JvID09ICdhZnRlcicpIHtcbiAgICAgIGNvbnN0IGRpZmYgPSBiLm9mZnNldCAtIGEub2Zmc2V0XG4gICAgICBjb25zdCBvdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYi5sZW5ndGgsIGEubGVuZ3RoIC0gZGlmZikpXG4gICAgICBjb25zdCByZW1vdmUgPSBNYXRoLm1pbihhLmxlbmd0aCwgb3ZlcmxhcClcbiAgICAgIGEubGVuZ3RoIC09IHJlbW92ZVxuICAgIH1cblxuICAgIC8vIElmIEEgaXMgYW4gYHJlbW92ZV9tYXJrYCBvcGVyYXRpb24sIGFuZCBpdHMgYGxlbmd0aGAgaXMgbm93IHplcm8sIHJlbW92ZVxuICAgIC8vIGl0IGJlY2F1c2UgaXQgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICBpZiAoYS50eXBlID09ICdyZW1vdmVfbWFyaycgJiYgYS5sZW5ndGggPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG1hcmsuXG4gICAqL1xuXG4gIGlmIChiLnR5cGUgPT0gJ3JlbW92ZV9tYXJrJykge1xuICAgIC8vIElmIEIncyBwYXRoIGRvZXNuJ3QgaW50ZXJzZWN0IEEncyBleGFjdGx5LCBvciBlaXRoZXIgb3BlcmF0aW9uIGhhcyBub1xuICAgIC8vIGBvZmZzZXRgLCBvciBCIGRvZXNuJ3QgaGF2ZSBwcmlvcml0eSwgb3IgdGhlIG9wZXJhdGlvbnMncyBgbWFya2AgZG9uJ3RcbiAgICAvLyBtYXRjaCwgdGhlbiBCIGNhbid0IGFmZmVjdCBBLCBzbyBhYm9ydC5cbiAgICBpZiAoXG4gICAgICBhcF9icCAhPSAnZXhhY3QnIHx8XG4gICAgICBhb19ibyA9PSBudWxsIHx8XG4gICAgICBwICE9ICdyaWdodCcgfHxcbiAgICAgICFpc0VxdWFsKGEubWFyaywgYi5tYXJrKVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhbiBgYWRkX21hcmtgIG9wZXJhdGlvbiwgYW5kIEIncyBzdGFydCBpbnRlcnNlY3RzIGJlZm9yZSBBJ3MsXG4gICAgLy8gc2hpZnQgQSB0byBvbWl0IHRoZSByYW5nZSByZW1vdmVkIGJ5IEIuXG4gICAgaWYgKGEudHlwZSA9PSAnYWRkX21hcmsnICYmIGFvX2JvID09ICdiZWZvcmUnKSB7XG4gICAgICBjb25zdCBza2lwID0gTWF0aC5taW4oYi5sZW5ndGgsIGEub2Zmc2V0IC0gYi5vZmZzZXQpXG4gICAgICBjb25zdCBvbWl0ID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoIC0gc2tpcClcbiAgICAgIGEub2Zmc2V0ICs9IHNraXBcbiAgICAgIGEubGVuZ3RoIC09IG9taXRcbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGFuIGBhZGRfbWFya2Agb3BlcmF0aW9uLCBhbmQgQidzIHN0YXJ0IGludGVyc2VjdHMgZXhhY3RseSBhdCBBJ3MsXG4gICAgLy8gc2hpZnQgQSB0byBvbWl0IHRoZSByYW5nZSByZW1vdmVkIGJ5IEIuXG4gICAgaWYgKGEudHlwZSA9PSAnYWRkX21hcmsnICYmIGFvX2JvID09ICdleGFjdCcpIHtcbiAgICAgIGNvbnN0IG9taXQgPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gICAgICBhLm9mZnNldCArPSBvbWl0XG4gICAgICBhLmxlbmd0aCAtPSBvbWl0XG4gICAgfVxuXG4gICAgLy8gSWYgQSBpcyBhbiBgYWRkX21hcmtgIG9wZXJhdGlvbiwgYW5kIEIncyBzdGFydCBpbnRlcnNlY3RzIGFmdGVyIEEncyxcbiAgICAvLyBhbmQgQidzIGVuZCBpbnRlcnNlY3RzIGJlZm9yZSBBJ3MsIHdlIG5lZWQgdG8gc3BsaXQgQSBpbnRvIHR3byBvcGVyYXRpb25zXG4gICAgLy8gc2luY2UgQiByZW1vdmVzIHRoZSBtYXJrIGluIHRoZSBtaWRkbGUuXG4gICAgaWYgKGEudHlwZSA9PSAnYWRkX21hcmsnICYmIGFvX2JvID09ICdhZnRlcicgJiYgYW9sX2JvbCA9PSAnYmVmb3JlJykge1xuICAgICAgY29uc3QgYmVmb3JlID0gYi5vZmZzZXQgLSBhLm9mZnNldFxuICAgICAgY29uc3QgYWZ0ZXIgPSBhLmxlbmd0aCAtIGJlZm9yZSAtIGIubGVuZ3RoXG4gICAgICBjb25zdCBtaWRkbGUgPSBhLmxlbmd0aCAtIGJlZm9yZSAtIGFmdGVyXG4gICAgICBjb25zdCBmaXJzdCA9IHsgLi4uYSwgbGVuZ3RoOiBiZWZvcmUgfVxuICAgICAgY29uc3Qgc2Vjb25kID0geyAuLi5hLCBvZmZzZXQ6IGEub2Zmc2V0ICsgYmVmb3JlICsgbWlkZGxlLCBsZW5ndGg6IGFmdGVyIH1cbiAgICAgIHJldHVybiBbZmlyc3QsIHNlY29uZF1cbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGFuIGBhZGRfbWFya2Agb3BlcmF0aW9uLCBhbmQgQidzIHN0YXJ0IGludGVyc2VjdHMgYWZ0ZXIgQSdzLFxuICAgIC8vIHJlbW92ZSB0aGUgb3ZlcmxhcGluZyByZWdpb24gZnJvbSBBLlxuICAgIGlmIChhLnR5cGUgPT0gJ2FkZF9tYXJrJyAmJiBhb19ibyA9PSAnYWZ0ZXInKSB7XG4gICAgICBjb25zdCBkaWZmID0gYi5vZmZzZXQgLSBhLm9mZnNldFxuICAgICAgY29uc3Qgb3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGIubGVuZ3RoLCBhLmxlbmd0aCAtIGRpZmYpKVxuICAgICAgY29uc3QgcmVtb3ZlID0gTWF0aC5taW4oYS5sZW5ndGgsIG92ZXJsYXApXG4gICAgICBhLmxlbmd0aCAtPSByZW1vdmVcbiAgICB9XG5cbiAgICAvLyBJZiBBIGlzIGFuIGBhZGRfbWFya2Agb3BlcmF0aW9uLCBhbmQgaXRzIGBsZW5ndGhgIGlzIG5vdyB6ZXJvLCByZW1vdmUgaXRcbiAgICAvLyBiZWNhdXNlIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAgaWYgKGEudHlwZSA9PSAnYWRkX21hcmsnICYmIGEubGVuZ3RoID09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gLyoqXG4gIC8vICAqIE1vdmUgbm9kZS5cbiAgLy8gICovXG5cbiAgLy8gaWYgKGIudHlwZSA9PSAnbW92ZV9ub2RlJykge1xuICAvLyAgIC8vIElmIEEgaXMgYSBgam9pbl9ub2RlYCBvcGVyYXRpb24sIGFuZCBCJ3MgcGF0aCBpbnRlcnNlY3RlZCBlaXRoZXIgb25lIG9mXG4gIC8vICAgLy8gQSdzIHBhdGhzLCB0aGVuIGlnbm9yZSBBIHNpbmNlIHRoZSBub2RlcyBhcmUgbm8gbG9uZ2VyIGFkamFjZW50LlxuICAvLyAgIGlmIChcbiAgLy8gICAgIChhLnR5cGUgPT0gJ2pvaW5fbm9kZScpICYmXG4gIC8vICAgICAoYXBfYnAgPT0gJ3NhbWUnIHx8IGF3cF9icCA9PSAnc2FtZScpICYmXG4gIC8vICAgICAocCA9PSAncmlnaHQnKVxuICAvLyAgICkge1xuICAvLyAgICAgcmV0dXJuIG51bGxcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBJZiBCJ3Mgb2xkIHBhdGggaW50ZXJzZWN0cyBhdCBBJ3MsIGFuZCBCIGhhcyBwcmlvcml0eSwgdGhlbiB1cGRhdGUgQSdzXG4gIC8vICAgLy8gcGF0aCB0byByZWZlciB0byBCJ3MgbmV3IHBhdGggd2hlcmUgdGhlIG5vZGUgaGFzIG1vdmVkIHRvLlxuICAvLyAgIGlmIChhcF9icCA9PSAnc2FtZScgJiYgcCA9PSAncmlnaHQnKSB7XG4gIC8vICAgICBhLnBhdGggPSBiLm5ld1BhdGguY29uY2F0KGEucGF0aC5zbGljZShiLm5ld1BhdGgubGVuZ3RoKSlcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBJZiBBIGhhcyBhIGBuZXdQYXRoYCwgYW5kIGBiLnBhdGhgIGludGVyc2VjdHMgYXQgYGEucGF0aGAsIGFuZCBgYmAgaGFzXG4gIC8vICAgLy8gcHJpb3JpdHksIGFuZCBgYi5uZXdQYXRoYCBkb2Vzbid0IGludGVyc2VjdCwgZGVjcmVtZW50LlxuICAvLyAgIGlmIChhbnBfYnAgPT0gJ3NhbWUnICYmIHAgPT0gJ3JpZ2h0JyAmJiBhbnBfYm5wID09ICdub25lJykge1xuICAvLyAgICAgYS5uZXdQYXRoW2ldLS1cbiAgLy8gICB9XG5cbiAgLy8gICAvLyBJZiBCJ3Mgb2xkIHBhdGggaW50ZXJzZWN0ZWQgQSdzLCBidXQgaXQncyBuZXcgb25lIGRvZXNuJ3QsIHRoZW4gZGVjcmVtZW50XG4gIC8vICAgLy8gQSdzIHRvIGFjY291bnQgZm9yIHRoZSBtb3ZlLlxuICAvLyAgIGlmIChcbiAgLy8gICAgIChhcF9icCA9PSAnYmVmb3JlJykgJiZcbiAgLy8gICAgICgoYXBfYm5wID09ICdub25lJykgfHwgKGFwX2JucCA9PSAnc2FtZScgJiYgcCA9PSAncmlnaHQnKSlcbiAgLy8gICApIHtcbiAgLy8gICAgIGEucGF0aFtpXS0tXG4gIC8vICAgICBpZiAoYS53aXRoUGF0aCkgYS53aXRoUGF0aFtpXS0tXG4gIC8vICAgfVxuXG4gIC8vICAgLy8gSWYgQidzIG9sZCBwYXRoIGludGVyc2VjdHMgQSdzIG5ldyBwYXRoLCBhbmQgaXQncyBwcmV2aW91cyBvbmUgZG9lc24ndCxcbiAgLy8gICAvLyB0aGVuIGRlY3JlbWVudCBBJ3MgdG8gYWNjb3VudCBmb3IgdGhlIG1vdmUuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgKGFucF9icCA9PSAnYmVmb3JlJykgJiZcbiAgLy8gICAgICgoYW5wX2JucCA9PSAnbm9uZScpIHx8IChhbnBfYm5wID09ICdzYW1lJyAmJiBwID09ICdyaWdodCcpKVxuICAvLyAgICkge1xuICAvLyAgICAgYS5uZXdQYXRoW2ldLS1cbiAgLy8gICB9XG5cbiAgLy8gICAvLyBJZiBCJ3MgbmV3IHBhdGggaW50ZXJzZWN0cyBBJ3MsIGFuZCBpdCdzIHByZXZpb3VzIG9uZSBkb2Vzbid0LCB0aGVuXG4gIC8vICAgLy8gaW5jcmVtZW50IEEncyB0byBhY2NvdW50IGZvciB0aGUgbW92ZS5cbiAgLy8gICBpZiAoXG4gIC8vICAgICAoYXBfYnAgPT0gJ25vbmUnKSAmJlxuICAvLyAgICAgKChhcF9ibnAgPT0gJ2JlZm9yZScpIHx8IChhcF9ibnAgPT0gJ3NhbWUnICYmIHAgPT0gJ3JpZ2h0JykpXG4gIC8vICAgKSB7XG4gIC8vICAgICBhLnBhdGhbbmldKytcbiAgLy8gICAgIGlmIChhLndpdGhQYXRoKSBhLndpdGhQYXRoW25pXSsrXG4gIC8vICAgfVxuXG4gIC8vICAgLy8gSWYgQSdzIG5ldyBwYXRoIHdhc24ndCBpbnRlcnNlY3RlZCBieSBCJ3Mgb2xkIHBhdGgsIGJ1dCBpcyBieSBCJ3MgbmV3XG4gIC8vICAgLy8gcGF0aCwgdGhlbiBpbmNyZW1lbnQgaXQgdG8gYWNjb3VudCBmb3IgdGhlIG1vdmUuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgKGFucF9icCA9PSAnbm9uZScpICYmXG4gIC8vICAgICAoKGFucF9ibnAgPT0gJ2JlZm9yZScpIHx8IChhbnBfYm5wID09ICdzYW1lJyAmJiBwID09ICdyaWdodCcpKVxuICAvLyAgICkge1xuICAvLyAgICAgYS5uZXdQYXRoW25pXSsrXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLy8gLyoqXG4gIC8vICAqIFNwbGl0IG5vZGUuXG4gIC8vICAqL1xuXG4gIC8vIGlmIChiLnR5cGUgPT0gJ3NwbGl0X25vZGUnKSB7XG4gIC8vICAgLy8gSWYgYGIucGF0aGAgaW50ZXJzZWN0cyBiZWZvcmUgYGEucGF0aGAsIGluY3JlbWVudC5cbiAgLy8gICBpZiAoYXBfYnAgPT0gJ2JlZm9yZScpIHtcbiAgLy8gICAgIGEucGF0aFtpXSsrXG4gIC8vICAgICBpZiAoYS53aXRoUGF0aCkgYS53aXRoUGF0aFtpXSsrXG4gIC8vICAgfVxuXG4gIC8vICAgLy8gSWYgYGIucGF0aGAgaW50ZXJzZWN0cyBhdCBgYS5wYXRoYCwgYW5kIGBiYCBoYXMgcHJpb3JpdHksIGFuZCBgYWAgaXMgYVxuICAvLyAgIC8vIGByZW1vdmVfbm9kZWAgb3BlcmF0aW9uLCB0aGVuIGlnbm9yZSBgYWAuXG4gIC8vICAgaWYgKGEudHlwZSA9PSAncmVtb3ZlX25vZGUnICYmIGFwX2JwID09ICdzYW1lJyAmJiBwID09ICdyaWdodCcpIHtcbiAgLy8gICAgIHJldHVybiBudWxsXG4gIC8vICAgfVxuXG4gIC8vICAgLy8gSWYgYGIucGF0aGAgaW50ZXJzZWN0cyBhdCBgYS5wYXRoYCwgYW5kIGBiYCBoYXMgcHJpb3JpdHksIGFuZCBgYWAgaXMgYVxuICAvLyAgIC8vIGBzcGxpdF9ub2RlYCBvcGVyYXRpb24sIHRoZW4gaW5jcmVtZW50IGBhLnBhdGhgIGFuZCBkZWNyZW1lbnQgYGEub2Zmc2V0YC5cbiAgLy8gICBpZiAoYS50eXBlID09ICdzcGxpdF9ub2RlJyAmJiBhcF9icCA9PSAnc2FtZScgJiYgcCA9PSAncmlnaHQnKSB7XG4gIC8vICAgICBhLnBhdGhbaV0rK1xuICAvLyAgICAgYS5vZmZzZXQgLT0gYi5vZmZzZXRcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBJZiBgYi5wYXRoYCBpbnRlcnNlY3RzIGF0IGBhLnBhdGhgLCBhbmQgYGJgIGhhcyBwcmlvcml0eSwgaW5jcmVtZW50XG4gIC8vICAgLy8gYGEucGF0aGAuXG4gIC8vICAgaWYgKGFwX2JwID09ICdzYW1lJyAmJiBwID09ICdyaWdodCcpIHtcbiAgLy8gICAgIGEucGF0aFtpXSsrXG4gIC8vICAgICBpZiAoYS53aXRoUGF0aCkgYS53aXRoUGF0aFtpXSsrXG4gIC8vICAgfVxuXG4gIC8vICAgLy8gSWYgYGIucGF0aGAgaW50ZXJzZWN0cyBhdCBgYS5wYXRoYCwgYW5kIGBiYCBoYXMgcHJpb3JpdHksIGFuZCBBIGlzIGFcbiAgLy8gICAvLyBgcmVtb3ZlX25vZGVgIG9wZXJhdGlvbiwgdGhlbiBpZ25vcmUgQS5cbiAgLy8gICBpZiAoYS50eXBlID09ICdyZW1vdmVfbm9kZScgJiYgYXdwX2JwID09ICdzYW1lJyAmJiBwID09ICdyaWdodCcpIHtcbiAgLy8gICAgIHJldHVybiBudWxsXG4gIC8vICAgfVxuXG4gIC8vICAgLy8gSWYgQSBoYXMgYSBgbmV3UGF0aGAsIGFuZCBgYi5wYXRoYCBpbnRlcnNlY3RzIGJlZm9yZSBgYS5wYXRoYCwgaW5jcmVtZW50IEEnc1xuICAvLyAgIC8vIHBhdGguXG4gIC8vICAgaWYgKGFucF9icCA9PSAnYmVmb3JlJykge1xuICAvLyAgICAgYS5uZXdQYXRoW2ldKytcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBJZiBgYi5wYXRoYCBpbnRlcnNlY3RzIGF0IGBhLm5ld1BhdGhgLCBhbmQgYGJgIGhhcyBwcmlvcml0eSwgaW5jcmVtZW50XG4gIC8vICAgLy8gYGEubmV3UGF0aGAuXG4gIC8vICAgaWYgKGFucF9icCA9PSAnc2FtZScgJiYgcCA9PSAncmlnaHQnKSB7XG4gIC8vICAgICBhLm5ld1BhdGhbaV0rK1xuICAvLyAgIH1cbiAgLy8gfVxufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgdHJhbnNmb3JtXG4iXX0=