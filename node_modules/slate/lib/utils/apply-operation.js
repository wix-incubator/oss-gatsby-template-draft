'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _warn = require('../utils/warn');

var _warn2 = _interopRequireDefault(_warn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Debug.
 *
 * @type {Function}
 */

var debug = (0, _debug2.default)('slate:operation');

/**
 * Operations.
 *
 * @type {Object}
 */

var OPERATIONS = {
  // Text operations.
  insert_text: insertText,
  remove_text: removeText,
  // Mark operations.
  add_mark: addMark,
  remove_mark: removeMark,
  set_mark: setMark,
  // Node operations.
  insert_node: insertNode,
  join_node: joinNode,
  move_node: moveNode,
  remove_node: removeNode,
  set_node: setNode,
  split_node: splitNode,
  // Selection operations.
  set_selection: setSelection,
  // State data operations.
  set_data: setData
};

/**
 * Apply an `operation` to a `state`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State} state
 */

function applyOperation(state, operation) {
  var type = operation.type;

  var fn = OPERATIONS[type];

  if (!fn) {
    throw new Error('Unknown operation type: "' + type + '".');
  }

  debug(type, operation);
  state = fn(state, operation);
  return state;
}

/**
 * Add mark to text at `offset` and `length` in node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function addMark(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      length = operation.length,
      mark = operation.mark;
  var _state = state,
      document = _state.document;

  var node = document.assertPath(path);
  node = node.addMark(offset, length, mark);
  document = document.updateDescendant(node);
  state = state.set('document', document);
  return state;
}

/**
 * Insert a `node` at `index` in a node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function insertNode(state, operation) {
  var path = operation.path,
      node = operation.node;

  var index = path[path.length - 1];
  var rest = path.slice(0, -1);
  var _state2 = state,
      document = _state2.document;

  var parent = document.assertPath(rest);
  var isParent = document == parent;
  parent = parent.insertNode(index, node);
  document = isParent ? parent : document.updateDescendant(parent);
  state = state.set('document', document);
  return state;
}

/**
 * Insert `text` at `offset` in node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function insertText(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      text = operation.text,
      marks = operation.marks;
  var _state3 = state,
      document = _state3.document,
      selection = _state3.selection;
  var _selection = selection,
      anchorKey = _selection.anchorKey,
      focusKey = _selection.focusKey,
      anchorOffset = _selection.anchorOffset,
      focusOffset = _selection.focusOffset;

  var node = document.assertPath(path);

  // Update the document
  node = node.insertText(offset, text, marks);
  document = document.updateDescendant(node);

  // Update the selection
  if (anchorKey == node.key && anchorOffset >= offset) {
    selection = selection.moveAnchor(text.length);
  }
  if (focusKey == node.key && focusOffset >= offset) {
    selection = selection.moveFocus(text.length);
  }

  state = state.set('document', document).set('selection', selection);
  return state;
}

/**
 * Join a node by `path` with a node `withPath`.
 *
 * @param {State} state
 * @param {Object} operation
 *   @param {Boolean} operation.deep (optional) Join recursively the
 *   respective last node and first node of the nodes' children. Like a zipper :)
 * @return {State}
 */

function joinNode(state, operation) {
  var path = operation.path,
      withPath = operation.withPath,
      _operation$deep = operation.deep,
      deep = _operation$deep === undefined ? false : _operation$deep;
  var _state4 = state,
      document = _state4.document,
      selection = _state4.selection;

  var first = document.assertPath(withPath);
  var second = document.assertPath(path);

  document = document.joinNode(first, second, { deep: deep });

  // If the operation is deep, or the nodes are text nodes, it means we will be
  // merging two text nodes together, so we need to update the selection.
  if (deep || second.kind == 'text') {
    var _selection2 = selection,
        anchorKey = _selection2.anchorKey,
        anchorOffset = _selection2.anchorOffset,
        focusKey = _selection2.focusKey,
        focusOffset = _selection2.focusOffset;

    var firstText = first.kind == 'text' ? first : first.getLastText();
    var secondText = second.kind == 'text' ? second : second.getFirstText();

    if (anchorKey == secondText.key) {
      selection = selection.merge({
        anchorKey: firstText.key,
        anchorOffset: anchorOffset + firstText.characters.size
      });
    }

    if (focusKey == secondText.key) {
      selection = selection.merge({
        focusKey: firstText.key,
        focusOffset: focusOffset + firstText.characters.size
      });
    }
  }

  state = state.set('document', document).set('selection', selection);
  return state;
}

/**
 * Move a node by `path` to `newPath`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function moveNode(state, operation) {
  var path = operation.path,
      newPath = operation.newPath;

  var newIndex = newPath[newPath.length - 1];
  var newParentPath = newPath.slice(0, -1);
  var oldParentPath = path.slice(0, -1);
  var oldIndex = path[path.length - 1];
  var _state5 = state,
      document = _state5.document;

  var node = document.assertPath(path);

  // Remove the node from its current parent.
  var parent = document.getParent(node.key);
  parent = parent.removeNode(oldIndex);
  document = parent.kind === 'document' ? parent : document.updateDescendant(parent);

  // Find the new target...
  var target = void 0;

  // If the old path and the rest of the new path are the same, then the new
  // target is the old parent.
  if (oldParentPath.every(function (x, i) {
    return x === newParentPath[i];
  }) && oldParentPath.length === newParentPath.length) {
    target = parent;
  }

  // Otherwise, if the old path removal resulted in the new path being no longer
  // correct, we need to decrement the new path at the old path's last index.
  else if (oldParentPath.every(function (x, i) {
      return x === newParentPath[i];
    }) && oldIndex < newParentPath[oldParentPath.length]) {
      newParentPath[oldParentPath.length]--;
      target = document.assertPath(newParentPath);
    }

    // Otherwise, we can just grab the target normally...
    else {
        target = document.assertPath(newParentPath);
      }

  // Insert the new node to its new parent.
  target = target.insertNode(newIndex, node);
  document = target.kind === 'document' ? target : document.updateDescendant(target);
  state = state.set('document', document);
  return state;
}

/**
 * Remove mark from text at `offset` and `length` in node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function removeMark(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      length = operation.length,
      mark = operation.mark;
  var _state6 = state,
      document = _state6.document;

  var node = document.assertPath(path);
  node = node.removeMark(offset, length, mark);
  document = document.updateDescendant(node);
  state = state.set('document', document);
  return state;
}

/**
 * Remove a node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function removeNode(state, operation) {
  var path = operation.path;
  var _state7 = state,
      document = _state7.document,
      selection = _state7.selection;
  var _selection3 = selection,
      startKey = _selection3.startKey,
      endKey = _selection3.endKey;

  var node = document.assertPath(path);

  // If the selection is set, check to see if it needs to be updated.
  if (selection.isSet) {
    var hasStartNode = node.hasNode(startKey);
    var hasEndNode = node.hasNode(endKey);

    // If one of the selection's nodes is being removed, we need to update it.
    if (hasStartNode) {
      var prev = document.getPreviousText(startKey);
      var next = document.getNextText(startKey);

      if (prev) {
        selection = selection.moveStartTo(prev.key, prev.length);
      } else if (next) {
        selection = selection.moveStartTo(next.key, 0);
      } else {
        selection = selection.deselect();
      }
    }

    if (hasEndNode) {
      var _prev = document.getPreviousText(endKey);
      var _next = document.getNextText(endKey);

      if (_prev) {
        selection = selection.moveEndTo(_prev.key, _prev.length);
      } else if (_next) {
        selection = selection.moveEndTo(_next.key, 0);
      } else {
        selection = selection.deselect();
      }
    }
  }

  // Remove the node from the document.
  var parent = document.getParent(node.key);
  var index = parent.nodes.indexOf(node);
  var isParent = document == parent;
  parent = parent.removeNode(index);
  document = isParent ? parent : document.updateDescendant(parent);

  // Update the document and selection.
  state = state.set('document', document).set('selection', selection);
  return state;
}

/**
 * Remove text at `offset` and `length` in node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function removeText(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      length = operation.length;

  var rangeOffset = offset + length;
  var _state8 = state,
      document = _state8.document,
      selection = _state8.selection;
  var _selection4 = selection,
      anchorKey = _selection4.anchorKey,
      focusKey = _selection4.focusKey,
      anchorOffset = _selection4.anchorOffset,
      focusOffset = _selection4.focusOffset;

  var node = document.assertPath(path);

  // Update the selection
  if (anchorKey == node.key && anchorOffset >= rangeOffset) {
    selection = selection.moveAnchor(-length);
  }
  if (focusKey == node.key && focusOffset >= rangeOffset) {
    selection = selection.moveFocus(-length);
  }

  node = node.removeText(offset, length);
  document = document.updateDescendant(node);
  state = state.set('document', document).set('selection', selection);
  return state;
}

/**
 * Set `data` on `state`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function setData(state, operation) {
  var properties = operation.properties;
  var _state9 = state,
      data = _state9.data;


  data = data.merge(properties);
  state = state.set('data', data);
  return state;
}

/**
 * Set `properties` on mark on text at `offset` and `length` in node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function setMark(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      length = operation.length,
      mark = operation.mark,
      newMark = operation.newMark;
  var _state10 = state,
      document = _state10.document;

  var node = document.assertPath(path);
  node = node.updateMark(offset, length, mark, newMark);
  document = document.updateDescendant(node);
  state = state.set('document', document);
  return state;
}

/**
 * Set `properties` on a node by `path`.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function setNode(state, operation) {
  var path = operation.path,
      properties = operation.properties;
  var _state11 = state,
      document = _state11.document;

  var node = document.assertPath(path);

  // Deprecate the ability to overwite a node's children.
  if (properties.nodes && properties.nodes != node.nodes) {
    (0, _warn2.default)('Updating a Node\'s `nodes` property via `setNode()` is not allowed. Use the appropriate insertion and removal operations instead. The opeartion in question was:', operation);
    delete properties.nodes;
  }

  // Deprecate the ability to change a node's key.
  if (properties.key && properties.key != node.key) {
    (0, _warn2.default)('Updating a Node\'s `key` property via `setNode()` is not allowed. There should be no reason to do this. The opeartion in question was:', operation);
    delete properties.key;
  }

  node = node.merge(properties);
  document = node.kind === 'document' ? node : document.updateDescendant(node);
  state = state.set('document', document);
  return state;
}

/**
 * Set `properties` on the selection.
 *
 * @param {State} state
 * @param {Object} operation
 * @return {State}
 */

function setSelection(state, operation) {
  var properties = _extends({}, operation.properties);
  var _state12 = state,
      document = _state12.document,
      selection = _state12.selection;


  if (properties.anchorPath !== undefined) {
    properties.anchorKey = properties.anchorPath === null ? null : document.assertPath(properties.anchorPath).key;
    delete properties.anchorPath;
  }

  if (properties.focusPath !== undefined) {
    properties.focusKey = properties.focusPath === null ? null : document.assertPath(properties.focusPath).key;
    delete properties.focusPath;
  }

  selection = selection.merge(properties);
  selection = selection.normalize(document);
  state = state.set('selection', selection);
  return state;
}

/**
 * Split a node by `path` at `offset`.
 *
 * @param {State} state
 * @param {Object} operation
 *   @param {Array} operation.path The path of the node to split
 *   @param {Number} operation.offset (optional) Split using a relative offset
 *   @param {Number} operation.count (optional) Split after `count`
 *   children. Cannot be used in combination with offset.
 * @return {State}
 */

function splitNode(state, operation) {
  var path = operation.path,
      offset = operation.offset,
      count = operation.count;
  var _state13 = state,
      document = _state13.document,
      selection = _state13.selection;

  // If there's no offset, it's using the `count` instead.

  if (offset == null) {
    document = document.splitNodeAfter(path, count);
    state = state.set('document', document);
    return state;
  }

  // Otherwise, split using the `offset`, but calculate a few things first.
  var node = document.assertPath(path);
  var text = node.kind == 'text' ? node : node.getTextAtOffset(offset);
  var textOffset = node.kind == 'text' ? offset : offset - node.getOffset(text.key);
  var _selection5 = selection,
      anchorKey = _selection5.anchorKey,
      anchorOffset = _selection5.anchorOffset,
      focusKey = _selection5.focusKey,
      focusOffset = _selection5.focusOffset;


  document = document.splitNode(path, offset);

  // Determine whether we need to update the selection.
  var splitAnchor = text.key == anchorKey && textOffset <= anchorOffset;
  var splitFocus = text.key == focusKey && textOffset <= focusOffset;

  // If either the anchor of focus was after the split, we need to update them.
  if (splitFocus || splitAnchor) {
    var nextText = document.getNextText(text.key);

    if (splitAnchor) {
      selection = selection.merge({
        anchorKey: nextText.key,
        anchorOffset: anchorOffset - textOffset
      });
    }

    if (splitFocus) {
      selection = selection.merge({
        focusKey: nextText.key,
        focusOffset: focusOffset - textOffset
      });
    }
  }

  state = state.set('document', document).set('selection', selection);
  return state;
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = applyOperation;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9hcHBseS1vcGVyYXRpb24uanMiXSwibmFtZXMiOlsiZGVidWciLCJPUEVSQVRJT05TIiwiaW5zZXJ0X3RleHQiLCJpbnNlcnRUZXh0IiwicmVtb3ZlX3RleHQiLCJyZW1vdmVUZXh0IiwiYWRkX21hcmsiLCJhZGRNYXJrIiwicmVtb3ZlX21hcmsiLCJyZW1vdmVNYXJrIiwic2V0X21hcmsiLCJzZXRNYXJrIiwiaW5zZXJ0X25vZGUiLCJpbnNlcnROb2RlIiwiam9pbl9ub2RlIiwiam9pbk5vZGUiLCJtb3ZlX25vZGUiLCJtb3ZlTm9kZSIsInJlbW92ZV9ub2RlIiwicmVtb3ZlTm9kZSIsInNldF9ub2RlIiwic2V0Tm9kZSIsInNwbGl0X25vZGUiLCJzcGxpdE5vZGUiLCJzZXRfc2VsZWN0aW9uIiwic2V0U2VsZWN0aW9uIiwic2V0X2RhdGEiLCJzZXREYXRhIiwiYXBwbHlPcGVyYXRpb24iLCJzdGF0ZSIsIm9wZXJhdGlvbiIsInR5cGUiLCJmbiIsIkVycm9yIiwicGF0aCIsIm9mZnNldCIsImxlbmd0aCIsIm1hcmsiLCJkb2N1bWVudCIsIm5vZGUiLCJhc3NlcnRQYXRoIiwidXBkYXRlRGVzY2VuZGFudCIsInNldCIsImluZGV4IiwicmVzdCIsInNsaWNlIiwicGFyZW50IiwiaXNQYXJlbnQiLCJ0ZXh0IiwibWFya3MiLCJzZWxlY3Rpb24iLCJhbmNob3JLZXkiLCJmb2N1c0tleSIsImFuY2hvck9mZnNldCIsImZvY3VzT2Zmc2V0Iiwia2V5IiwibW92ZUFuY2hvciIsIm1vdmVGb2N1cyIsIndpdGhQYXRoIiwiZGVlcCIsImZpcnN0Iiwic2Vjb25kIiwia2luZCIsImZpcnN0VGV4dCIsImdldExhc3RUZXh0Iiwic2Vjb25kVGV4dCIsImdldEZpcnN0VGV4dCIsIm1lcmdlIiwiY2hhcmFjdGVycyIsInNpemUiLCJuZXdQYXRoIiwibmV3SW5kZXgiLCJuZXdQYXJlbnRQYXRoIiwib2xkUGFyZW50UGF0aCIsIm9sZEluZGV4IiwiZ2V0UGFyZW50IiwidGFyZ2V0IiwiZXZlcnkiLCJ4IiwiaSIsInN0YXJ0S2V5IiwiZW5kS2V5IiwiaXNTZXQiLCJoYXNTdGFydE5vZGUiLCJoYXNOb2RlIiwiaGFzRW5kTm9kZSIsInByZXYiLCJnZXRQcmV2aW91c1RleHQiLCJuZXh0IiwiZ2V0TmV4dFRleHQiLCJtb3ZlU3RhcnRUbyIsImRlc2VsZWN0IiwibW92ZUVuZFRvIiwibm9kZXMiLCJpbmRleE9mIiwicmFuZ2VPZmZzZXQiLCJwcm9wZXJ0aWVzIiwiZGF0YSIsIm5ld01hcmsiLCJ1cGRhdGVNYXJrIiwiYW5jaG9yUGF0aCIsInVuZGVmaW5lZCIsImZvY3VzUGF0aCIsIm5vcm1hbGl6ZSIsImNvdW50Iiwic3BsaXROb2RlQWZ0ZXIiLCJnZXRUZXh0QXRPZmZzZXQiLCJ0ZXh0T2Zmc2V0IiwiZ2V0T2Zmc2V0Iiwic3BsaXRBbmNob3IiLCJzcGxpdEZvY3VzIiwibmV4dFRleHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7Ozs7OztBQU1BLElBQU1BLFFBQVEscUJBQU0saUJBQU4sQ0FBZDs7QUFFQTs7Ozs7O0FBTUEsSUFBTUMsYUFBYTtBQUNqQjtBQUNBQyxlQUFhQyxVQUZJO0FBR2pCQyxlQUFhQyxVQUhJO0FBSWpCO0FBQ0FDLFlBQVVDLE9BTE87QUFNakJDLGVBQWFDLFVBTkk7QUFPakJDLFlBQVVDLE9BUE87QUFRakI7QUFDQUMsZUFBYUMsVUFUSTtBQVVqQkMsYUFBV0MsUUFWTTtBQVdqQkMsYUFBV0MsUUFYTTtBQVlqQkMsZUFBYUMsVUFaSTtBQWFqQkMsWUFBVUMsT0FiTztBQWNqQkMsY0FBWUMsU0FkSztBQWVqQjtBQUNBQyxpQkFBZUMsWUFoQkU7QUFpQmpCO0FBQ0FDLFlBQVVDO0FBbEJPLENBQW5COztBQXFCQTs7Ozs7Ozs7QUFRQSxTQUFTQyxjQUFULENBQXdCQyxLQUF4QixFQUErQkMsU0FBL0IsRUFBMEM7QUFBQSxNQUNoQ0MsSUFEZ0MsR0FDdkJELFNBRHVCLENBQ2hDQyxJQURnQzs7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ZXdCTCxTQWZ4QjtBQUFBLE1BZTNCQyxTQWYyQixlQWUzQkEsU0FmMkI7QUFBQSxNQWVoQkUsWUFmZ0IsZUFlaEJBLFlBZmdCO0FBQUEsTUFlRkQsUUFmRSxlQWVGQSxRQWZFO0FBQUEsTUFlUUUsV0FmUixlQWVRQSxXQWZSOzs7QUFpQm5DaEIsYUFBV0EsU0FBU2YsU0FBVCxDQUFtQlcsSUFBbkIsRUFBeUJDLE1BQXpCLENBQVg7O0FBRUE7QUFDQSxNQUFNMEUsY0FBYzdELEtBQUtPLEdBQUwsSUFBWUosU0FBWixJQUF5QndELGNBQWN0RCxZQUEzRDtBQUNBLE1BQU15RCxhQUFhOUQsS0FBS08sR0FBTCxJQUFZSCxRQUFaLElBQXdCdUQsY0FBY3JELFdBQXpEOztBQUVBO0FBQ0EsTUFBSXdELGNBQWNELFdBQWxCLEVBQStCO0FBQzdCLFFBQU1FLFdBQVd6RSxTQUFTbUQsV0FBVCxDQUFxQnpDLEtBQUtPLEdBQTFCLENBQWpCOztBQUVBLFFBQUlzRCxXQUFKLEVBQWlCO0FBQ2YzRCxrQkFBWUEsVUFBVWlCLEtBQVYsQ0FBZ0I7QUFDMUJoQixtQkFBVzRELFNBQVN4RCxHQURNO0FBRTFCRixzQkFBY0EsZUFBZXNEO0FBRkgsT0FBaEIsQ0FBWjtBQUlEOztBQUVELFFBQUlHLFVBQUosRUFBZ0I7QUFDZDVELGtCQUFZQSxVQUFVaUIsS0FBVixDQUFnQjtBQUMxQmYsa0JBQVUyRCxTQUFTeEQsR0FETztBQUUxQkQscUJBQWFBLGNBQWNxRDtBQUZELE9BQWhCLENBQVo7QUFJRDtBQUNGOztBQUVEOUUsVUFBUUEsTUFBTWEsR0FBTixDQUFVLFVBQVYsRUFBc0JKLFFBQXRCLEVBQWdDSSxHQUFoQyxDQUFvQyxXQUFwQyxFQUFpRFEsU0FBakQsQ0FBUjtBQUNBLFNBQU9yQixLQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztrQkFNZUQsYyIsImZpbGUiOiJhcHBseS1vcGVyYXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBEZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCB3YXJuIGZyb20gJy4uL3V0aWxzL3dhcm4nXG5cbi8qKlxuICogRGVidWcuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoJ3NsYXRlOm9wZXJhdGlvbicpXG5cbi8qKlxuICogT3BlcmF0aW9ucy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmNvbnN0IE9QRVJBVElPTlMgPSB7XG4gIC8vIFRleHQgb3BlcmF0aW9ucy5cbiAgaW5zZXJ0X3RleHQ6IGluc2VydFRleHQsXG4gIHJlbW92ZV90ZXh0OiByZW1vdmVUZXh0LFxuICAvLyBNYXJrIG9wZXJhdGlvbnMuXG4gIGFkZF9tYXJrOiBhZGRNYXJrLFxuICByZW1vdmVfbWFyazogcmVtb3ZlTWFyayxcbiAgc2V0X21hcms6IHNldE1hcmssXG4gIC8vIE5vZGUgb3BlcmF0aW9ucy5cbiAgaW5zZXJ0X25vZGU6IGluc2VydE5vZGUsXG4gIGpvaW5fbm9kZTogam9pbk5vZGUsXG4gIG1vdmVfbm9kZTogbW92ZU5vZGUsXG4gIHJlbW92ZV9ub2RlOiByZW1vdmVOb2RlLFxuICBzZXRfbm9kZTogc2V0Tm9kZSxcbiAgc3BsaXRfbm9kZTogc3BsaXROb2RlLFxuICAvLyBTZWxlY3Rpb24gb3BlcmF0aW9ucy5cbiAgc2V0X3NlbGVjdGlvbjogc2V0U2VsZWN0aW9uLFxuICAvLyBTdGF0ZSBkYXRhIG9wZXJhdGlvbnMuXG4gIHNldF9kYXRhOiBzZXREYXRhXG59XG5cbi8qKlxuICogQXBwbHkgYW4gYG9wZXJhdGlvbmAgdG8gYSBgc3RhdGVgLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3BlcmF0aW9uXG4gKiBAcmV0dXJuIHtTdGF0ZX0gc3RhdGVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseU9wZXJhdGlvbihzdGF0ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IHsgdHlwZSB9ID0gb3BlcmF0aW9uXG4gIGNvbnN0IGZuID0gT1BFUkFUSU9OU1t0eXBlXVxuXG4gIGlmICghZm4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0aW9uIHR5cGU6IFwiJHt0eXBlfVwiLmApXG4gIH1cblxuICBkZWJ1Zyh0eXBlLCBvcGVyYXRpb24pXG4gIHN0YXRlID0gZm4oc3RhdGUsIG9wZXJhdGlvbilcbiAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogQWRkIG1hcmsgdG8gdGV4dCBhdCBgb2Zmc2V0YCBhbmQgYGxlbmd0aGAgaW4gbm9kZSBieSBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcGVyYXRpb25cbiAqIEByZXR1cm4ge1N0YXRlfVxuICovXG5cbmZ1bmN0aW9uIGFkZE1hcmsoc3RhdGUsIG9wZXJhdGlvbikge1xuICBjb25zdCB7IHBhdGgsIG9mZnNldCwgbGVuZ3RoLCBtYXJrIH0gPSBvcGVyYXRpb25cbiAgbGV0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGxldCBub2RlID0gZG9jdW1lbnQuYXNzZXJ0UGF0aChwYXRoKVxuICBub2RlID0gbm9kZS5hZGRNYXJrKG9mZnNldCwgbGVuZ3RoLCBtYXJrKVxuICBkb2N1bWVudCA9IGRvY3VtZW50LnVwZGF0ZURlc2NlbmRhbnQobm9kZSlcbiAgc3RhdGUgPSBzdGF0ZS5zZXQoJ2RvY3VtZW50JywgZG9jdW1lbnQpXG4gIHJldHVybiBzdGF0ZVxufVxuXG4vKipcbiAqIEluc2VydCBhIGBub2RlYCBhdCBgaW5kZXhgIGluIGEgbm9kZSBieSBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcGVyYXRpb25cbiAqIEByZXR1cm4ge1N0YXRlfVxuICovXG5cbmZ1bmN0aW9uIGluc2VydE5vZGUoc3RhdGUsIG9wZXJhdGlvbikge1xuICBjb25zdCB7IHBhdGgsIG5vZGUgfSA9IG9wZXJhdGlvblxuICBjb25zdCBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuICBjb25zdCByZXN0ID0gcGF0aC5zbGljZSgwLCAtMSlcbiAgbGV0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGxldCBwYXJlbnQgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHJlc3QpXG4gIGNvbnN0IGlzUGFyZW50ID0gZG9jdW1lbnQgPT0gcGFyZW50XG4gIHBhcmVudCA9IHBhcmVudC5pbnNlcnROb2RlKGluZGV4LCBub2RlKVxuICBkb2N1bWVudCA9IGlzUGFyZW50ID8gcGFyZW50IDogZG9jdW1lbnQudXBkYXRlRGVzY2VuZGFudChwYXJlbnQpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBJbnNlcnQgYHRleHRgIGF0IGBvZmZzZXRgIGluIG5vZGUgYnkgYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3BlcmF0aW9uXG4gKiBAcmV0dXJuIHtTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiBpbnNlcnRUZXh0KHN0YXRlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgeyBwYXRoLCBvZmZzZXQsIHRleHQsIG1hcmtzIH0gPSBvcGVyYXRpb25cbiAgbGV0IHsgZG9jdW1lbnQsIHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgY29uc3QgeyBhbmNob3JLZXksIGZvY3VzS2V5LCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0IH0gPSBzZWxlY3Rpb25cbiAgbGV0IG5vZGUgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHBhdGgpXG5cbiAgLy8gVXBkYXRlIHRoZSBkb2N1bWVudFxuICBub2RlID0gbm9kZS5pbnNlcnRUZXh0KG9mZnNldCwgdGV4dCwgbWFya3MpXG4gIGRvY3VtZW50ID0gZG9jdW1lbnQudXBkYXRlRGVzY2VuZGFudChub2RlKVxuXG4gIC8vIFVwZGF0ZSB0aGUgc2VsZWN0aW9uXG4gIGlmIChhbmNob3JLZXkgPT0gbm9kZS5rZXkgJiYgYW5jaG9yT2Zmc2V0ID49IG9mZnNldCkge1xuICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tb3ZlQW5jaG9yKHRleHQubGVuZ3RoKVxuICB9XG4gIGlmIChmb2N1c0tleSA9PSBub2RlLmtleSAmJiBmb2N1c09mZnNldCA+PSBvZmZzZXQpIHtcbiAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24ubW92ZUZvY3VzKHRleHQubGVuZ3RoKVxuICB9XG5cbiAgc3RhdGUgPSBzdGF0ZS5zZXQoJ2RvY3VtZW50JywgZG9jdW1lbnQpLnNldCgnc2VsZWN0aW9uJywgc2VsZWN0aW9uKVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBKb2luIGEgbm9kZSBieSBgcGF0aGAgd2l0aCBhIG5vZGUgYHdpdGhQYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wZXJhdGlvblxuICogICBAcGFyYW0ge0Jvb2xlYW59IG9wZXJhdGlvbi5kZWVwIChvcHRpb25hbCkgSm9pbiByZWN1cnNpdmVseSB0aGVcbiAqICAgcmVzcGVjdGl2ZSBsYXN0IG5vZGUgYW5kIGZpcnN0IG5vZGUgb2YgdGhlIG5vZGVzJyBjaGlsZHJlbi4gTGlrZSBhIHppcHBlciA6KVxuICogQHJldHVybiB7U3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gam9pbk5vZGUoc3RhdGUsIG9wZXJhdGlvbikge1xuICBjb25zdCB7IHBhdGgsIHdpdGhQYXRoLCBkZWVwID0gZmFsc2UgfSA9IG9wZXJhdGlvblxuICBsZXQgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBjb25zdCBmaXJzdCA9IGRvY3VtZW50LmFzc2VydFBhdGgod2l0aFBhdGgpXG4gIGNvbnN0IHNlY29uZCA9IGRvY3VtZW50LmFzc2VydFBhdGgocGF0aClcblxuICBkb2N1bWVudCA9IGRvY3VtZW50LmpvaW5Ob2RlKGZpcnN0LCBzZWNvbmQsIHsgZGVlcCB9KVxuXG4gIC8vIElmIHRoZSBvcGVyYXRpb24gaXMgZGVlcCwgb3IgdGhlIG5vZGVzIGFyZSB0ZXh0IG5vZGVzLCBpdCBtZWFucyB3ZSB3aWxsIGJlXG4gIC8vIG1lcmdpbmcgdHdvIHRleHQgbm9kZXMgdG9nZXRoZXIsIHNvIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gIGlmIChkZWVwIHx8IHNlY29uZC5raW5kID09ICd0ZXh0Jykge1xuICAgIGNvbnN0IHsgYW5jaG9yS2V5LCBhbmNob3JPZmZzZXQsIGZvY3VzS2V5LCBmb2N1c09mZnNldCB9ID0gc2VsZWN0aW9uXG4gICAgY29uc3QgZmlyc3RUZXh0ID0gZmlyc3Qua2luZCA9PSAndGV4dCcgPyBmaXJzdCA6IGZpcnN0LmdldExhc3RUZXh0KClcbiAgICBjb25zdCBzZWNvbmRUZXh0ID0gc2Vjb25kLmtpbmQgPT0gJ3RleHQnID8gc2Vjb25kIDogc2Vjb25kLmdldEZpcnN0VGV4dCgpXG5cbiAgICBpZiAoYW5jaG9yS2V5ID09IHNlY29uZFRleHQua2V5KSB7XG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24ubWVyZ2Uoe1xuICAgICAgICBhbmNob3JLZXk6IGZpcnN0VGV4dC5rZXksXG4gICAgICAgIGFuY2hvck9mZnNldDogYW5jaG9yT2Zmc2V0ICsgZmlyc3RUZXh0LmNoYXJhY3RlcnMuc2l6ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoZm9jdXNLZXkgPT0gc2Vjb25kVGV4dC5rZXkpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tZXJnZSh7XG4gICAgICAgIGZvY3VzS2V5OiBmaXJzdFRleHQua2V5LFxuICAgICAgICBmb2N1c09mZnNldDogZm9jdXNPZmZzZXQgKyBmaXJzdFRleHQuY2hhcmFjdGVycy5zaXplXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KS5zZXQoJ3NlbGVjdGlvbicsIHNlbGVjdGlvbilcbiAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogTW92ZSBhIG5vZGUgYnkgYHBhdGhgIHRvIGBuZXdQYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wZXJhdGlvblxuICogQHJldHVybiB7U3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gbW92ZU5vZGUoc3RhdGUsIG9wZXJhdGlvbikge1xuICBjb25zdCB7IHBhdGgsIG5ld1BhdGggfSA9IG9wZXJhdGlvblxuICBjb25zdCBuZXdJbmRleCA9IG5ld1BhdGhbbmV3UGF0aC5sZW5ndGggLSAxXVxuICBjb25zdCBuZXdQYXJlbnRQYXRoID0gbmV3UGF0aC5zbGljZSgwLCAtMSlcbiAgY29uc3Qgb2xkUGFyZW50UGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpXG4gIGNvbnN0IG9sZEluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdXG4gIGxldCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjb25zdCBub2RlID0gZG9jdW1lbnQuYXNzZXJ0UGF0aChwYXRoKVxuXG4gIC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIGl0cyBjdXJyZW50IHBhcmVudC5cbiAgbGV0IHBhcmVudCA9IGRvY3VtZW50LmdldFBhcmVudChub2RlLmtleSlcbiAgcGFyZW50ID0gcGFyZW50LnJlbW92ZU5vZGUob2xkSW5kZXgpXG4gIGRvY3VtZW50ID0gcGFyZW50LmtpbmQgPT09ICdkb2N1bWVudCcgPyBwYXJlbnQgOiBkb2N1bWVudC51cGRhdGVEZXNjZW5kYW50KHBhcmVudClcblxuICAvLyBGaW5kIHRoZSBuZXcgdGFyZ2V0Li4uXG4gIGxldCB0YXJnZXRcblxuICAvLyBJZiB0aGUgb2xkIHBhdGggYW5kIHRoZSByZXN0IG9mIHRoZSBuZXcgcGF0aCBhcmUgdGhlIHNhbWUsIHRoZW4gdGhlIG5ld1xuICAvLyB0YXJnZXQgaXMgdGhlIG9sZCBwYXJlbnQuXG4gIGlmIChcbiAgICAob2xkUGFyZW50UGF0aC5ldmVyeSgoeCwgaSkgPT4geCA9PT0gbmV3UGFyZW50UGF0aFtpXSkpICYmXG4gICAgKG9sZFBhcmVudFBhdGgubGVuZ3RoID09PSBuZXdQYXJlbnRQYXRoLmxlbmd0aClcbiAgKSB7XG4gICAgdGFyZ2V0ID0gcGFyZW50XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGlmIHRoZSBvbGQgcGF0aCByZW1vdmFsIHJlc3VsdGVkIGluIHRoZSBuZXcgcGF0aCBiZWluZyBubyBsb25nZXJcbiAgLy8gY29ycmVjdCwgd2UgbmVlZCB0byBkZWNyZW1lbnQgdGhlIG5ldyBwYXRoIGF0IHRoZSBvbGQgcGF0aCdzIGxhc3QgaW5kZXguXG4gIGVsc2UgaWYgKFxuICAgIChvbGRQYXJlbnRQYXRoLmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSBuZXdQYXJlbnRQYXRoW2ldKSkgJiZcbiAgICAob2xkSW5kZXggPCBuZXdQYXJlbnRQYXRoW29sZFBhcmVudFBhdGgubGVuZ3RoXSlcbiAgKSB7XG4gICAgbmV3UGFyZW50UGF0aFtvbGRQYXJlbnRQYXRoLmxlbmd0aF0tLVxuICAgIHRhcmdldCA9IGRvY3VtZW50LmFzc2VydFBhdGgobmV3UGFyZW50UGF0aClcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgd2UgY2FuIGp1c3QgZ3JhYiB0aGUgdGFyZ2V0IG5vcm1hbGx5Li4uXG4gIGVsc2Uge1xuICAgIHRhcmdldCA9IGRvY3VtZW50LmFzc2VydFBhdGgobmV3UGFyZW50UGF0aClcbiAgfVxuXG4gIC8vIEluc2VydCB0aGUgbmV3IG5vZGUgdG8gaXRzIG5ldyBwYXJlbnQuXG4gIHRhcmdldCA9IHRhcmdldC5pbnNlcnROb2RlKG5ld0luZGV4LCBub2RlKVxuICBkb2N1bWVudCA9IHRhcmdldC5raW5kID09PSAnZG9jdW1lbnQnID8gdGFyZ2V0IDogZG9jdW1lbnQudXBkYXRlRGVzY2VuZGFudCh0YXJnZXQpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBSZW1vdmUgbWFyayBmcm9tIHRleHQgYXQgYG9mZnNldGAgYW5kIGBsZW5ndGhgIGluIG5vZGUgYnkgYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3BlcmF0aW9uXG4gKiBAcmV0dXJuIHtTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVNYXJrKHN0YXRlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgeyBwYXRoLCBvZmZzZXQsIGxlbmd0aCwgbWFyayB9ID0gb3BlcmF0aW9uXG4gIGxldCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBsZXQgbm9kZSA9IGRvY3VtZW50LmFzc2VydFBhdGgocGF0aClcbiAgbm9kZSA9IG5vZGUucmVtb3ZlTWFyayhvZmZzZXQsIGxlbmd0aCwgbWFyaylcbiAgZG9jdW1lbnQgPSBkb2N1bWVudC51cGRhdGVEZXNjZW5kYW50KG5vZGUpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBub2RlIGJ5IGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wZXJhdGlvblxuICogQHJldHVybiB7U3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShzdGF0ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IHsgcGF0aCB9ID0gb3BlcmF0aW9uXG4gIGxldCB7IGRvY3VtZW50LCBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIGNvbnN0IHsgc3RhcnRLZXksIGVuZEtleSB9ID0gc2VsZWN0aW9uXG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHBhdGgpXG5cbiAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBzZXQsIGNoZWNrIHRvIHNlZSBpZiBpdCBuZWVkcyB0byBiZSB1cGRhdGVkLlxuICBpZiAoc2VsZWN0aW9uLmlzU2V0KSB7XG4gICAgY29uc3QgaGFzU3RhcnROb2RlID0gbm9kZS5oYXNOb2RlKHN0YXJ0S2V5KVxuICAgIGNvbnN0IGhhc0VuZE5vZGUgPSBub2RlLmhhc05vZGUoZW5kS2V5KVxuXG4gICAgLy8gSWYgb25lIG9mIHRoZSBzZWxlY3Rpb24ncyBub2RlcyBpcyBiZWluZyByZW1vdmVkLCB3ZSBuZWVkIHRvIHVwZGF0ZSBpdC5cbiAgICBpZiAoaGFzU3RhcnROb2RlKSB7XG4gICAgICBjb25zdCBwcmV2ID0gZG9jdW1lbnQuZ2V0UHJldmlvdXNUZXh0KHN0YXJ0S2V5KVxuICAgICAgY29uc3QgbmV4dCA9IGRvY3VtZW50LmdldE5leHRUZXh0KHN0YXJ0S2V5KVxuXG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24ubW92ZVN0YXJ0VG8ocHJldi5rZXksIHByZXYubGVuZ3RoKVxuICAgICAgfSBlbHNlIGlmIChuZXh0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tb3ZlU3RhcnRUbyhuZXh0LmtleSwgMClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5kZXNlbGVjdCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc0VuZE5vZGUpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBkb2N1bWVudC5nZXRQcmV2aW91c1RleHQoZW5kS2V5KVxuICAgICAgY29uc3QgbmV4dCA9IGRvY3VtZW50LmdldE5leHRUZXh0KGVuZEtleSlcblxuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLm1vdmVFbmRUbyhwcmV2LmtleSwgcHJldi5sZW5ndGgpXG4gICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLm1vdmVFbmRUbyhuZXh0LmtleSwgMClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5kZXNlbGVjdCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIGRvY3VtZW50LlxuICBsZXQgcGFyZW50ID0gZG9jdW1lbnQuZ2V0UGFyZW50KG5vZGUua2V5KVxuICBjb25zdCBpbmRleCA9IHBhcmVudC5ub2Rlcy5pbmRleE9mKG5vZGUpXG4gIGNvbnN0IGlzUGFyZW50ID0gZG9jdW1lbnQgPT0gcGFyZW50XG4gIHBhcmVudCA9IHBhcmVudC5yZW1vdmVOb2RlKGluZGV4KVxuICBkb2N1bWVudCA9IGlzUGFyZW50ID8gcGFyZW50IDogZG9jdW1lbnQudXBkYXRlRGVzY2VuZGFudChwYXJlbnQpXG5cbiAgLy8gVXBkYXRlIHRoZSBkb2N1bWVudCBhbmQgc2VsZWN0aW9uLlxuICBzdGF0ZSA9IHN0YXRlLnNldCgnZG9jdW1lbnQnLCBkb2N1bWVudCkuc2V0KCdzZWxlY3Rpb24nLCBzZWxlY3Rpb24pXG4gIHJldHVybiBzdGF0ZVxufVxuXG4vKipcbiAqIFJlbW92ZSB0ZXh0IGF0IGBvZmZzZXRgIGFuZCBgbGVuZ3RoYCBpbiBub2RlIGJ5IGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wZXJhdGlvblxuICogQHJldHVybiB7U3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlVGV4dChzdGF0ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IHsgcGF0aCwgb2Zmc2V0LCBsZW5ndGggfSA9IG9wZXJhdGlvblxuICBjb25zdCByYW5nZU9mZnNldCA9IG9mZnNldCArIGxlbmd0aFxuICBsZXQgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBjb25zdCB7IGFuY2hvcktleSwgZm9jdXNLZXksIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQgfSA9IHNlbGVjdGlvblxuICBsZXQgbm9kZSA9IGRvY3VtZW50LmFzc2VydFBhdGgocGF0aClcblxuICAvLyBVcGRhdGUgdGhlIHNlbGVjdGlvblxuICBpZiAoYW5jaG9yS2V5ID09IG5vZGUua2V5ICYmIGFuY2hvck9mZnNldCA+PSByYW5nZU9mZnNldCkge1xuICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tb3ZlQW5jaG9yKC1sZW5ndGgpXG4gIH1cbiAgaWYgKGZvY3VzS2V5ID09IG5vZGUua2V5ICYmIGZvY3VzT2Zmc2V0ID49IHJhbmdlT2Zmc2V0KSB7XG4gICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLm1vdmVGb2N1cygtbGVuZ3RoKVxuICB9XG5cbiAgbm9kZSA9IG5vZGUucmVtb3ZlVGV4dChvZmZzZXQsIGxlbmd0aClcbiAgZG9jdW1lbnQgPSBkb2N1bWVudC51cGRhdGVEZXNjZW5kYW50KG5vZGUpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KS5zZXQoJ3NlbGVjdGlvbicsIHNlbGVjdGlvbilcbiAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogU2V0IGBkYXRhYCBvbiBgc3RhdGVgLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3BlcmF0aW9uXG4gKiBAcmV0dXJuIHtTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiBzZXREYXRhKHN0YXRlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBvcGVyYXRpb25cbiAgbGV0IHsgZGF0YSB9ID0gc3RhdGVcblxuICBkYXRhID0gZGF0YS5tZXJnZShwcm9wZXJ0aWVzKVxuICBzdGF0ZSA9IHN0YXRlLnNldCgnZGF0YScsIGRhdGEpXG4gIHJldHVybiBzdGF0ZVxufVxuXG4vKipcbiAqIFNldCBgcHJvcGVydGllc2Agb24gbWFyayBvbiB0ZXh0IGF0IGBvZmZzZXRgIGFuZCBgbGVuZ3RoYCBpbiBub2RlIGJ5IGBwYXRoYC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wZXJhdGlvblxuICogQHJldHVybiB7U3RhdGV9XG4gKi9cblxuZnVuY3Rpb24gc2V0TWFyayhzdGF0ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IHsgcGF0aCwgb2Zmc2V0LCBsZW5ndGgsIG1hcmssIG5ld01hcmsgfSA9IG9wZXJhdGlvblxuICBsZXQgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgbGV0IG5vZGUgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHBhdGgpXG4gIG5vZGUgPSBub2RlLnVwZGF0ZU1hcmsob2Zmc2V0LCBsZW5ndGgsIG1hcmssIG5ld01hcmspXG4gIGRvY3VtZW50ID0gZG9jdW1lbnQudXBkYXRlRGVzY2VuZGFudChub2RlKVxuICBzdGF0ZSA9IHN0YXRlLnNldCgnZG9jdW1lbnQnLCBkb2N1bWVudClcbiAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogU2V0IGBwcm9wZXJ0aWVzYCBvbiBhIG5vZGUgYnkgYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3BlcmF0aW9uXG4gKiBAcmV0dXJuIHtTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiBzZXROb2RlKHN0YXRlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgeyBwYXRoLCBwcm9wZXJ0aWVzIH0gPSBvcGVyYXRpb25cbiAgbGV0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIGxldCBub2RlID0gZG9jdW1lbnQuYXNzZXJ0UGF0aChwYXRoKVxuXG4gIC8vIERlcHJlY2F0ZSB0aGUgYWJpbGl0eSB0byBvdmVyd2l0ZSBhIG5vZGUncyBjaGlsZHJlbi5cbiAgaWYgKHByb3BlcnRpZXMubm9kZXMgJiYgcHJvcGVydGllcy5ub2RlcyAhPSBub2RlLm5vZGVzKSB7XG4gICAgd2FybignVXBkYXRpbmcgYSBOb2RlXFwncyBgbm9kZXNgIHByb3BlcnR5IHZpYSBgc2V0Tm9kZSgpYCBpcyBub3QgYWxsb3dlZC4gVXNlIHRoZSBhcHByb3ByaWF0ZSBpbnNlcnRpb24gYW5kIHJlbW92YWwgb3BlcmF0aW9ucyBpbnN0ZWFkLiBUaGUgb3BlYXJ0aW9uIGluIHF1ZXN0aW9uIHdhczonLCBvcGVyYXRpb24pXG4gICAgZGVsZXRlIHByb3BlcnRpZXMubm9kZXNcbiAgfVxuXG4gIC8vIERlcHJlY2F0ZSB0aGUgYWJpbGl0eSB0byBjaGFuZ2UgYSBub2RlJ3Mga2V5LlxuICBpZiAocHJvcGVydGllcy5rZXkgJiYgcHJvcGVydGllcy5rZXkgIT0gbm9kZS5rZXkpIHtcbiAgICB3YXJuKCdVcGRhdGluZyBhIE5vZGVcXCdzIGBrZXlgIHByb3BlcnR5IHZpYSBgc2V0Tm9kZSgpYCBpcyBub3QgYWxsb3dlZC4gVGhlcmUgc2hvdWxkIGJlIG5vIHJlYXNvbiB0byBkbyB0aGlzLiBUaGUgb3BlYXJ0aW9uIGluIHF1ZXN0aW9uIHdhczonLCBvcGVyYXRpb24pXG4gICAgZGVsZXRlIHByb3BlcnRpZXMua2V5XG4gIH1cblxuICBub2RlID0gbm9kZS5tZXJnZShwcm9wZXJ0aWVzKVxuICBkb2N1bWVudCA9IG5vZGUua2luZCA9PT0gJ2RvY3VtZW50JyA/IG5vZGUgOiBkb2N1bWVudC51cGRhdGVEZXNjZW5kYW50KG5vZGUpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdkb2N1bWVudCcsIGRvY3VtZW50KVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBTZXQgYHByb3BlcnRpZXNgIG9uIHRoZSBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcGVyYXRpb25cbiAqIEByZXR1cm4ge1N0YXRlfVxuICovXG5cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihzdGF0ZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7IC4uLm9wZXJhdGlvbi5wcm9wZXJ0aWVzIH1cbiAgbGV0IHsgZG9jdW1lbnQsIHNlbGVjdGlvbiB9ID0gc3RhdGVcblxuICBpZiAocHJvcGVydGllcy5hbmNob3JQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBwcm9wZXJ0aWVzLmFuY2hvcktleSA9IHByb3BlcnRpZXMuYW5jaG9yUGF0aCA9PT0gbnVsbFxuICAgICAgPyBudWxsXG4gICAgICA6IGRvY3VtZW50LmFzc2VydFBhdGgocHJvcGVydGllcy5hbmNob3JQYXRoKS5rZXlcbiAgICBkZWxldGUgcHJvcGVydGllcy5hbmNob3JQYXRoXG4gIH1cblxuICBpZiAocHJvcGVydGllcy5mb2N1c1BhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIHByb3BlcnRpZXMuZm9jdXNLZXkgPSBwcm9wZXJ0aWVzLmZvY3VzUGF0aCA9PT0gbnVsbFxuICAgICAgPyBudWxsXG4gICAgICA6IGRvY3VtZW50LmFzc2VydFBhdGgocHJvcGVydGllcy5mb2N1c1BhdGgpLmtleVxuICAgIGRlbGV0ZSBwcm9wZXJ0aWVzLmZvY3VzUGF0aFxuICB9XG5cbiAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLm1lcmdlKHByb3BlcnRpZXMpXG4gIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5ub3JtYWxpemUoZG9jdW1lbnQpXG4gIHN0YXRlID0gc3RhdGUuc2V0KCdzZWxlY3Rpb24nLCBzZWxlY3Rpb24pXG4gIHJldHVybiBzdGF0ZVxufVxuXG4vKipcbiAqIFNwbGl0IGEgbm9kZSBieSBgcGF0aGAgYXQgYG9mZnNldGAuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcGVyYXRpb25cbiAqICAgQHBhcmFtIHtBcnJheX0gb3BlcmF0aW9uLnBhdGggVGhlIHBhdGggb2YgdGhlIG5vZGUgdG8gc3BsaXRcbiAqICAgQHBhcmFtIHtOdW1iZXJ9IG9wZXJhdGlvbi5vZmZzZXQgKG9wdGlvbmFsKSBTcGxpdCB1c2luZyBhIHJlbGF0aXZlIG9mZnNldFxuICogICBAcGFyYW0ge051bWJlcn0gb3BlcmF0aW9uLmNvdW50IChvcHRpb25hbCkgU3BsaXQgYWZ0ZXIgYGNvdW50YFxuICogICBjaGlsZHJlbi4gQ2Fubm90IGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBvZmZzZXQuXG4gKiBAcmV0dXJuIHtTdGF0ZX1cbiAqL1xuXG5mdW5jdGlvbiBzcGxpdE5vZGUoc3RhdGUsIG9wZXJhdGlvbikge1xuICBjb25zdCB7IHBhdGgsIG9mZnNldCwgY291bnQgfSA9IG9wZXJhdGlvblxuICBsZXQgeyBkb2N1bWVudCwgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gb2Zmc2V0LCBpdCdzIHVzaW5nIHRoZSBgY291bnRgIGluc3RlYWQuXG4gIGlmIChvZmZzZXQgPT0gbnVsbCkge1xuICAgIGRvY3VtZW50ID0gZG9jdW1lbnQuc3BsaXROb2RlQWZ0ZXIocGF0aCwgY291bnQpXG4gICAgc3RhdGUgPSBzdGF0ZS5zZXQoJ2RvY3VtZW50JywgZG9jdW1lbnQpXG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cblxuICAvLyBPdGhlcndpc2UsIHNwbGl0IHVzaW5nIHRoZSBgb2Zmc2V0YCwgYnV0IGNhbGN1bGF0ZSBhIGZldyB0aGluZ3MgZmlyc3QuXG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5hc3NlcnRQYXRoKHBhdGgpXG4gIGNvbnN0IHRleHQgPSBub2RlLmtpbmQgPT0gJ3RleHQnID8gbm9kZSA6IG5vZGUuZ2V0VGV4dEF0T2Zmc2V0KG9mZnNldClcbiAgY29uc3QgdGV4dE9mZnNldCA9IG5vZGUua2luZCA9PSAndGV4dCcgPyBvZmZzZXQgOiBvZmZzZXQgLSBub2RlLmdldE9mZnNldCh0ZXh0LmtleSlcbiAgY29uc3QgeyBhbmNob3JLZXksIGFuY2hvck9mZnNldCwgZm9jdXNLZXksIGZvY3VzT2Zmc2V0IH0gPSBzZWxlY3Rpb25cblxuICBkb2N1bWVudCA9IGRvY3VtZW50LnNwbGl0Tm9kZShwYXRoLCBvZmZzZXQpXG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHNlbGVjdGlvbi5cbiAgY29uc3Qgc3BsaXRBbmNob3IgPSB0ZXh0LmtleSA9PSBhbmNob3JLZXkgJiYgdGV4dE9mZnNldCA8PSBhbmNob3JPZmZzZXRcbiAgY29uc3Qgc3BsaXRGb2N1cyA9IHRleHQua2V5ID09IGZvY3VzS2V5ICYmIHRleHRPZmZzZXQgPD0gZm9jdXNPZmZzZXRcblxuICAvLyBJZiBlaXRoZXIgdGhlIGFuY2hvciBvZiBmb2N1cyB3YXMgYWZ0ZXIgdGhlIHNwbGl0LCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGVtLlxuICBpZiAoc3BsaXRGb2N1cyB8fCBzcGxpdEFuY2hvcikge1xuICAgIGNvbnN0IG5leHRUZXh0ID0gZG9jdW1lbnQuZ2V0TmV4dFRleHQodGV4dC5rZXkpXG5cbiAgICBpZiAoc3BsaXRBbmNob3IpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tZXJnZSh7XG4gICAgICAgIGFuY2hvcktleTogbmV4dFRleHQua2V5LFxuICAgICAgICBhbmNob3JPZmZzZXQ6IGFuY2hvck9mZnNldCAtIHRleHRPZmZzZXRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHNwbGl0Rm9jdXMpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5tZXJnZSh7XG4gICAgICAgIGZvY3VzS2V5OiBuZXh0VGV4dC5rZXksXG4gICAgICAgIGZvY3VzT2Zmc2V0OiBmb2N1c09mZnNldCAtIHRleHRPZmZzZXRcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgc3RhdGUgPSBzdGF0ZS5zZXQoJ2RvY3VtZW50JywgZG9jdW1lbnQpLnNldCgnc2VsZWN0aW9uJywgc2VsZWN0aW9uKVxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBFeHBvcnQuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGFwcGx5T3BlcmF0aW9uXG4iXX0=