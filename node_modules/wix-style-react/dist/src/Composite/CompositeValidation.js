'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.children = exports.oneOf = exports.any = exports.multiple = exports.optional = exports.once = undefined;

var _react = require('react');

var validators = {
  ONCE: function ONCE(types, i, type) {
    return types[i] && types[i].type === type ? i + 1 : false;
  },

  OPTIONAL: function OPTIONAL(types, i, type) {
    return types[i] && types[i].type === type ? i + 1 : i;
  },

  ANY: function ANY(types) {
    return types.length;
  },

  ONEOF: function ONEOF(types, i, possibleTypes) {
    if (!types.length) {
      return false;
    }

    return possibleTypes.includes(types[i].type) ? i + 1 : false;
  },

  MULTIPLE: function MULTIPLE(types, i, type) {
    if (!types[i] || types[i].type !== type) {
      return false;
    }
    while (types[i] && types[i].type === type) {
      ++i;
    }
    return i;
  }
};

var error = function error(componentName, rules) {
  var orderedTypes = rules.map(function (rule) {
    var validation = rule.validation,
        type = rule.type;

    if (validation === 'ANY') {
      return '* (' + validation + ')';
    }

    if (validation === 'ONEOF') {
      var types = type.map(function (t) {
        return t.name;
      }).join(', ');
      return validation + '(' + types + ')';
    }

    return type.name + ' (' + validation + ')';
  }).join(', ');
  return new Error(componentName + ' should have children of the following types in this order: ' + orderedTypes);
};

var once = exports.once = function once(type) {
  return { validation: 'ONCE', type: type };
};
var optional = exports.optional = function optional(type) {
  return { validation: 'OPTIONAL', type: type };
};
var multiple = exports.multiple = function multiple(type) {
  return { validation: 'MULTIPLE', type: type };
};
var any = exports.any = function any() {
  return { validation: 'ANY' };
};
var oneOf = exports.oneOf = function oneOf() {
  for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {
    types[_key] = arguments[_key];
  }

  return { validation: 'ONEOF', type: types };
};

var children = exports.children = function children() {
  for (var _len2 = arguments.length, rules = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    rules[_key2] = arguments[_key2];
  }

  return function (props, propName, componentName) {
    if (!rules || rules.length === 0) {
      return new Error(componentName + ' should have at least a single child declaration rule');
    }
    var childrenAsArray = _react.Children.toArray(props[propName]);
    var result = rules.reduce(function (acc, curr) {
      if (acc === false) {
        return acc;
      }
      return validators[curr.validation](childrenAsArray, acc, curr.type);
    }, 0);
    if (result === false || childrenAsArray[result]) {
      return error(componentName, rules);
    }
  };
};