'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _omit = require('lodash/omit');

var _omit2 = _interopRequireDefault(_omit);

var _Ticker = require('./Ticker');

var _Ticker2 = _interopRequireDefault(_Ticker);

var _Unit = require('./Unit');

var _Unit2 = _interopRequireDefault(_Unit);

var _Group = require('./Group');

var _Group2 = _interopRequireDefault(_Group);

var _InputSuffix = require('./InputSuffix');

var _InputSuffix2 = _interopRequireDefault(_InputSuffix);

var _Input = require('./Input.scss');

var _Input2 = _interopRequireDefault(_Input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** General input container */
var Input = function (_Component) {
  _inherits(Input, _Component);

  function Input() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Input);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Input.__proto__ || Object.getPrototypeOf(Input)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focus: false
    }, _this.onCompositionChange = function (isComposing) {
      if (_this.props.onCompositionChange) {
        _this.props.onCompositionChange(isComposing);
      }

      _this.isComposing = isComposing;
    }, _this.focus = function () {
      _this._onFocus();
      _this.input && _this.input.focus();
    }, _this.blur = function () {
      _this.input && _this.input.blur();
    }, _this.select = function () {
      _this.input && _this.input.select();
    }, _this._onFocus = function (e) {
      _this.setState({ focus: true });
      _this.props.onFocus && _this.props.onFocus(e);

      if (_this.props.autoSelect) {
        // Set timeout is needed here since onFocus is called before react
        // gets the reference for the input (specifically when autoFocus
        // is on. So setTimeout ensures we have the ref.input needed in select)
        setTimeout(function () {
          return _this.select();
        }, 0);
      }
    }, _this._onBlur = function (e) {
      _this.setState({ focus: false });
      if (_this.props.onBlur) {
        _this.props.onBlur(e);
      }
    }, _this._onClick = function (e) {
      _this.props.onInputClicked && _this.props.onInputClicked(e);
    }, _this._onKeyDown = function (e) {
      if (_this.isComposing) {
        return;
      }

      _this.props.onKeyDown && _this.props.onKeyDown(e);

      if (e.keyCode === 13 /* enter */) {
          _this.props.onEnterPressed && _this.props.onEnterPressed(e);
        } else if (e.keyCode === 27 /* esc */) {
          _this.props.onEscapePressed && _this.props.onEscapePressed(e);
        }
    }, _this._onChange = function (e) {
      if (_this.props.type === 'number' && !/^[\d.,\-+]*$/.test(e.target.value)) {
        return;
      }

      _this.props.onChange && _this.props.onChange(e);
    }, _this._onClear = function (e) {
      var onClear = _this.props.onClear;


      _this.input.value = '';

      e.target = _extends({}, e.target, {
        value: ''
      });
      _this._onChange(e);
      _this.focus();

      onClear && onClear();
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Input, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _props = this.props,
          autoFocus = _props.autoFocus,
          value = _props.value;


      if (autoFocus) {
        this._onFocus();
        // Multiply by 2 to ensure the cursor always ends up at the end;
        // Opera sometimes sees a carriage return as 2 characters.
        value && this.input.setSelectionRange(value.length * 2, value.length * 2);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this,
          _classNames;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _props2 = this.props,
          id = _props2.id,
          name = _props2.name,
          value = _props2.value,
          placeholder = _props2.placeholder,
          help = _props2.help,
          helpMessage = _props2.helpMessage,
          unit = _props2.unit,
          magnifyingGlass = _props2.magnifyingGlass,
          menuArrow = _props2.menuArrow,
          defaultValue = _props2.defaultValue,
          tabIndex = _props2.tabIndex,
          clearButton = _props2.clearButton,
          onClear = _props2.onClear,
          autoFocus = _props2.autoFocus,
          onKeyUp = _props2.onKeyUp,
          onPaste = _props2.onPaste,
          readOnly = _props2.readOnly,
          prefix = _props2.prefix,
          suffix = _props2.suffix,
          type = _props2.type,
          maxLength = _props2.maxLength,
          textOverflow = _props2.textOverflow,
          theme = _props2.theme,
          disabled = _props2.disabled,
          status = _props2.status,
          statusMessage = _props2.statusMessage,
          tooltipPlacement = _props2.tooltipPlacement,
          onTooltipShow = _props2.onTooltipShow,
          autocomplete = _props2.autocomplete,
          required = _props2.required,
          error = _props2.error,
          errorMessage = _props2.errorMessage;


      var onIconClicked = function onIconClicked(e) {
        if (!disabled) {
          _this2.input.focus();
          _this2._onFocus();
          _this2._onClick(e);
        }
      };

      var suffixStatus = status;
      var suffixStatusMessage = statusMessage && statusMessage !== '' ? statusMessage : '';

      // Check for deprecated fields and use them if provided
      if (error) {
        suffixStatus = Input.StatusError;
        suffixStatusMessage = errorMessage;
      }

      var hasErrors = suffixStatus === Input.StatusError;

      var isClearButtonVisible = (!!clearButton || !!onClear) && !!value && !hasErrors && !disabled;

      var visibleSuffixCount = (0, _InputSuffix.getVisibleSuffixCount)({
        status: suffixStatus, statusMessage: suffixStatusMessage, disabled: disabled, help: help, magnifyingGlass: magnifyingGlass, isClearButtonVisible: isClearButtonVisible, menuArrow: menuArrow, unit: unit, suffix: suffix
      });

      var inputClassNames = (0, _classnames2.default)(_Input2.default.input, (_classNames = {}, _defineProperty(_classNames, _Input2.default.withPrefix, !!prefix), _defineProperty(_classNames, _Input2.default.withSuffix, visibleSuffixCount), _defineProperty(_classNames, _Input2.default.withSuffixes, visibleSuffixCount > 1), _classNames));

      var ariaAttribute = {};
      Object.keys(this.props).filter(function (key) {
        return key.startsWith('aria');
      }).map(function (key) {
        return ariaAttribute['aria-' + key.substr(4).toLowerCase()] = _this2.props[key];
      });

      var inputElement = _react2.default.createElement('input', _extends({
        style: { textOverflow: textOverflow },
        ref: function ref(input) {
          return _this2.input = input;
        },
        className: inputClassNames,
        id: id,
        name: name,
        disabled: disabled,
        defaultValue: defaultValue,
        value: value,
        onChange: this._onChange,
        maxLength: maxLength,
        onFocus: this._onFocus,
        onBlur: this._onBlur,
        onKeyDown: this._onKeyDown,
        onDoubleClick: this._onDoubleClick,
        onPaste: onPaste,
        placeholder: placeholder,
        tabIndex: tabIndex,
        autoFocus: autoFocus,
        onClick: this._onClick,
        onKeyUp: onKeyUp,
        readOnly: readOnly,
        type: type,
        required: required,
        autoComplete: autocomplete,
        onCompositionStart: function onCompositionStart() {
          return _this2.onCompositionChange(true);
        },
        onCompositionEnd: function onCompositionEnd() {
          return _this2.onCompositionChange(false);
        }
      }, ariaAttribute, (0, _omit2.default)(props, 'className')));

      //needs additional wrapper with class .prefixSuffixWrapper to fix inputs with prefix in ie11
      //https://github.com/wix/wix-style-react/issues/1693
      //https://github.com/wix/wix-style-react/issues/1691
      return _react2.default.createElement(
        'div',
        { className: _Input2.default.inputWrapper },
        prefix && _react2.default.createElement(
          'div',
          { className: _Input2.default.prefixSuffixWrapper },
          _react2.default.createElement(
            'div',
            { className: _Input2.default.prefix },
            prefix
          )
        ),
        inputElement,
        visibleSuffixCount > 0 && _react2.default.createElement(
          'div',
          { className: _Input2.default.prefixSuffixWrapper },
          _react2.default.createElement(_InputSuffix2.default, {
            status: suffixStatus,
            statusMessage: suffixStatusMessage,
            theme: theme,
            disabled: disabled,
            help: help,
            helpMessage: helpMessage,
            onIconClicked: onIconClicked,
            magnifyingGlass: magnifyingGlass,
            isClearButtonVisible: isClearButtonVisible,
            onClear: this._onClear,
            menuArrow: menuArrow,
            unit: unit,
            focused: this.state.focus,
            suffix: suffix,
            tooltipPlacement: tooltipPlacement,
            onTooltipShow: onTooltipShow
          })
        )
      );
    }
  }]);

  return Input;
}(_react.Component);

Input.Ticker = _Ticker2.default;
Input.Unit = _Unit2.default;
Input.Group = _Group2.default;
Input.StatusError = 'error';
Input.StatusLoading = 'loading';


Input.displayName = 'Input';

Input.defaultProps = {
  autoSelect: true,
  size: 'normal',
  theme: 'normal',
  statusMessage: '',
  errorMessage: '',
  helpMessage: '',
  roundInput: false,
  textOverflow: 'clip',
  maxLength: 524288,
  withSelection: false,
  clearButton: false
};

var borderRadiusValidator = function borderRadiusValidator(props, propName) {
  var value = props[propName];
  if (typeof value === 'string') {
    throw new Error('Passing a string (for className) is deprecated. Use new className prop.');
  } else if (typeof value === 'undefined' || typeof value === 'boolean') {
    return null;
  } else {
    return new Error('Invalid type. boolean expected.');
  }
};

Input.propTypes = {
  ariaControls: _propTypes2.default.string,
  ariaDescribedby: _propTypes2.default.string,
  ariaLabel: _propTypes2.default.string,

  /** Standard React Input autoFocus (focus the element on mount) */
  autoFocus: _propTypes2.default.bool,

  /** Standard React Input autoSelect (select the entire text of the element on focus) */
  autoSelect: _propTypes2.default.bool,

  /** Sets value of autocomplete attribute (consult the [HTML spec](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#attr-fe-autocomplete) for possible values  */
  autocomplete: _propTypes2.default.string,

  /** Specifies a data-hook for tests */
  dataHook: _propTypes2.default.string,

  /** Default value for those who wants to use this component un-controlled */
  defaultValue: _propTypes2.default.string,

  /** when set to true this component is disabled */
  disabled: _propTypes2.default.bool,

  /** Input status - use to display an status indication for the user. for example: 'error' or 'loading' */
  status: _propTypes2.default.oneOf([Input.StatusError, Input.StatusLoading]),

  /** The status (error/loading) message to display when hovering the status icon, if not given or empty there will be no tooltip */
  statusMessage: _propTypes2.default.node,

  /** Is input has errors
   * @deprecated
   * @see status
   */
  error: _propTypes2.default.bool,

  /** Error message to display
   * @deprecated
   * @see statusMessage
   */
  errorMessage: _propTypes2.default.node,

  forceFocus: _propTypes2.default.bool,
  forceHover: _propTypes2.default.bool,

  /** Adding a suffix help icon */
  help: _propTypes2.default.bool,

  /** The help message to display when hovering the help icon, if not given or empty there will be no tooltip */
  helpMessage: _propTypes2.default.node,
  id: _propTypes2.default.string,

  /** Should the component include a magnifyingGlass */
  magnifyingGlass: _propTypes2.default.bool,

  /** Input max length */
  maxLength: _propTypes2.default.number,

  /** Should the component include a menu arrow */
  menuArrow: _propTypes2.default.bool,

  /** Displays clear button (X) on a non-empty input */
  clearButton: _propTypes2.default.bool,

  /** A single CSS class name to be appended to ther Input's wrapper element. */
  className: _propTypes2.default.string,

  name: _propTypes2.default.string,

  /** When set to true, this input will have no rounded corners on its left */
  noLeftBorderRadius: borderRadiusValidator,

  /** When set to true, this input will have no rounded corners on its right */
  noRightBorderRadius: borderRadiusValidator,

  /** Standard input onBlur callback */
  onBlur: _propTypes2.default.func,

  /** Standard input onChange callback */
  onChange: _propTypes2.default.func,

  /** Displays clear button (X) on a non-empty input and calls callback with no arguments */
  onClear: _propTypes2.default.func,
  onCompositionChange: _propTypes2.default.func,

  /** Called when user presses -enter- */
  onEnterPressed: _propTypes2.default.func,

  /** Called when user presses -escape- */
  onEscapePressed: _propTypes2.default.func,

  /** Standard input onFocus callback */
  onFocus: _propTypes2.default.func,

  /** Standard input onClick callback */
  onInputClicked: _propTypes2.default.func,

  /** Standard input onKeyDown callback */
  onKeyDown: _propTypes2.default.func,
  onKeyUp: _propTypes2.default.func,

  /** called when user pastes text from clipboard (using mouse or keyboard shortcut) */
  onPaste: _propTypes2.default.func,

  /** onShow prop for the error and help tooltips (supported only for amaterial theme for now) */
  onTooltipShow: _propTypes2.default.func,

  /** Placeholder to display */
  placeholder: _propTypes2.default.string,

  /** Component you want to show as the prefix of the input */
  prefix: _propTypes2.default.node,

  /** Sets the input to readOnly */
  readOnly: _propTypes2.default.bool,

  /** When set to true, this input will be rounded */
  roundInput: _propTypes2.default.bool,

  /** Flip the magnify glass image so it be more suitable to rtl */
  rtl: _propTypes2.default.bool,

  /** Specifies the size of the input */
  size: _propTypes2.default.oneOf(['small', 'normal', 'large']),

  /** Component you want to show as the suffix of the input */
  suffix: _propTypes2.default.node,

  /** Standard component tabIndex */
  tabIndex: _propTypes2.default.number,

  /** Text overflow behaviour */
  textOverflow: _propTypes2.default.string,

  /** The theme of the input */
  theme: _propTypes2.default.oneOf(['normal', 'tags', 'paneltitle', 'material', 'amaterial', 'flat', 'flatdark']),

  /** The material design style floating label for input (supported only for amaterial theme for now) */
  title: _propTypes2.default.string,

  /** Placement of the error and help tooltips (supported only for amaterial theme for now) */
  tooltipPlacement: _propTypes2.default.string,
  type: _propTypes2.default.string,
  unit: _propTypes2.default.string,

  /** Inputs value */
  value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  withSelection: _propTypes2.default.bool,
  required: _propTypes2.default.bool
};

exports.default = Input;