'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BulkSelection = exports.BulkSelectionContextPropTypes = exports.ChangeType = exports.BulkSelectionState = exports.BulkSelectionContext = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _createReactContext = require('create-react-context');

var _createReactContext2 = _interopRequireDefault(_createReactContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BulkSelectionContext = exports.BulkSelectionContext = (0, _createReactContext2.default)();

var BulkSelectionState = exports.BulkSelectionState = Object.freeze({
  ALL: 'ALL',
  NONE: 'NONE',
  SOME: 'SOME'
});

var ChangeType = exports.ChangeType = Object.freeze({
  ALL: 'ALL',
  NONE: 'NONE',
  SINGLE_TOGGLE: 'SINGLE_TOGGLE'
});

/** Helper for PropTypes for componenst which consume the BulkSelection context */
var BulkSelectionContextPropTypes = exports.BulkSelectionContextPropTypes = {
  isSelected: _propTypes.func,
  selectedCount: _propTypes.number,
  getSelectedIds: _propTypes.func,
  bulkSelectionState: _propTypes.string,
  toggleSelectionById: _propTypes.func,
  toggleAll: _propTypes.func,
  selectAll: _propTypes.func,
  deselectAll: _propTypes.func,
  setSelectedIds: _propTypes.func
};

/**
 * BulkSelection manages the state and logic of bulk selection.
 * Given an array of selectable items, it manages a bulk selection state (ALL, SOME, NONE),
 * and provides helper methods for modifying the state.
 *
 * toggleBulkSelection(): changes the bulk state according to these state changes: ALL->NONE, SOME->ALL, NONE->ALL
 */

var BulkSelection = exports.BulkSelection = function (_React$Component) {
  _inherits(BulkSelection, _React$Component);

  function BulkSelection(props) {
    _classCallCheck(this, BulkSelection);

    var _this = _possibleConstructorReturn(this, (BulkSelection.__proto__ || Object.getPrototypeOf(BulkSelection)).call(this, props));

    _initialiseProps.call(_this);

    var selectedIds = (props.selectedIds || []).slice();
    _this.state = {
      selectedIds: selectedIds, // not exposed to context consumers
      helpers: _this.createHelpers(selectedIds)
    };
    return _this;
  }

  _createClass(BulkSelection, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.selectedIds && !(0, _isEqual2.default)(nextProps.selectedIds, this.state.selectedIds)) {
        this.setSelectedIds(nextProps.selectedIds.slice());
      }
    }
  }, {
    key: 'createHelpers',
    value: function createHelpers(selectedIds) {
      var _this2 = this;

      var totalCount = this.props.allIds.length;
      var selectedCount = selectedIds.length;
      var bulkSelectionState = selectedCount === 0 ? BulkSelectionState.NONE : selectedCount === totalCount ? BulkSelectionState.ALL : BulkSelectionState.SOME;

      return {
        // Getters
        /** Is the item with the given id selected. (id comes from the rowData.id if exists, if not then it is the rowIndex) */
        isSelected: function isSelected(id) {
          return selectedIds.indexOf(id) !== -1;
        },
        /** Number of selected items */
        selectedCount: selectedCount,
        /** Get a copy (array) of selected ids */
        getSelectedIds: function getSelectedIds() {
          return selectedIds.slice();
        },
        /** A string representing the BulkSelection state (not a React state).
        * Possible values: ALL, SOME, NONE
        */
        bulkSelectionState: bulkSelectionState,

        // Modifiers
        /** Toggle the selection state (selected/not-selected) of an item by id */
        toggleSelectionById: this.toggleSelectionById,
        /** Toggles the bulk selection state: NONE -> ALL, SOME -> ALL, ALL -> NONE */
        toggleAll: this.toggleBulkSelection,
        /** Select all items */
        selectAll: function selectAll() {
          return _this2.toggleAll(true);
        },
        /** Deselect all items (clear selection) */
        deselectAll: function deselectAll() {
          return _this2.toggleAll(false);
        },
        /** Set the selection.
        * An optional `change` argument will be passed "as is" to the Table's onSelectionChanged callback.
        */
        setSelectedIds: this.setSelectedIds
      };
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        BulkSelectionContext.Provider,
        {
          value: this.state.helpers
        },
        this.props.children
      );
    }
  }]);

  return BulkSelection;
}(_react2.default.Component);

var _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this.toggleAll = function (enable) {
    if (enable) {
      _this3.setSelectedIds(_this3.props.allIds, { type: ChangeType.ALL });
    } else {
      _this3.setSelectedIds([], { type: ChangeType.NONE });
    }
  };

  this.toggleBulkSelection = function () {
    var bulkSelectionState = _this3.state.helpers.bulkSelectionState;
    if (bulkSelectionState === BulkSelectionState.SOME) {
      _this3.toggleAll(true);
    } else if (bulkSelectionState === BulkSelectionState.ALL) {
      _this3.toggleAll(false);
    } else {
      _this3.toggleAll(true);
    }
  };

  this.toggleSelectionById = function (id) {
    var newSelectionValue = !_this3.state.helpers.isSelected(id);
    _this3.setSelectedIds(newSelectionValue ? _this3.state.selectedIds.concat(id) : _this3.state.selectedIds.filter(function (_id) {
      return _id !== id;
    }), {
      type: ChangeType.SINGLE_TOGGLE,
      id: id,
      value: newSelectionValue
    });
  };

  this.setSelectedIds = function (selectedIds, change) {
    if (!Array.isArray(selectedIds)) {
      throw new Error('selectedIds must be an array');
    }
    _this3.setState({ selectedIds: selectedIds, helpers: _this3.createHelpers(selectedIds) }, function () {
      _this3.props.onSelectionChanged && _this3.props.onSelectionChanged(selectedIds.slice(), change);
    });
  };
};

BulkSelection.propTypes = {
  /** Array of item selection boolean states. Should correspond in length to the data prop */
  selectedIds: (0, _propTypes.oneOfType)([(0, _propTypes.arrayOf)(_propTypes.string), (0, _propTypes.arrayOf)(_propTypes.number)]),
  /** An array of all item ids (string ids) */
  allIds: (0, _propTypes.oneOfType)([(0, _propTypes.arrayOf)(_propTypes.string), (0, _propTypes.arrayOf)(_propTypes.number)]).isRequired,
  /** Called when item selection changes.
   * Receives 2 arguments, the updated selectedIds array, and a `change` object.
   * `change` object has a `type` property with the following possible values: 'ALL', 'NONE', 'SINGLE_TOGGLE'.
   * In case of 'SINGLE_TOGGLE' the `change` object will also include an `id` prop with the item's id,
   * and a `value` prop with the new boolean selection state of the item. */
  onSelectionChanged: _propTypes.func,
  /** Any - can consume the BulkSelectionProvider context */
  children: _propTypes.any
};