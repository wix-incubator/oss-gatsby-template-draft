'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.INTERNAL_DRIVER_SYMBOL = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.mergeDrivers = mergeDrivers;
exports.flattenInternalDriver = flattenInternalDriver;

var _omit = require('lodash/omit');

var _omit2 = _interopRequireDefault(_omit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Symbol for accessing driver methods which are internal
 * (we don't want to expose them to WSR consumers)
 */
var INTERNAL_DRIVER_SYMBOL = exports.INTERNAL_DRIVER_SYMBOL = Symbol('internal-driver');

/**
 * Merge driver 2 into driver 1
 *
 * It should take care of merging Internal methods into the target'shidden internal driver
 * (which sits under the [INTERNAL_DRIVER] property). Currently not supported.
 */
function mergeDrivers(target, source) {
  // TODO: merge driver2's internal methods into driver1's internal methods.
  // TODO: make this a reduce that accepts a list of drivers.
  if (target[INTERNAL_DRIVER_SYMBOL]) {
    throw new Error('mergeDrivers(): Merging into a driver with INTERNAL_DRIVER methods, is currently not supported yet.');
  }

  return _extends({}, target, source);
}

/**
 * Flatten driver by spreading all internal methods,
 * and removing the INTERNAL_DRIVER property.
 * Does not mutate the given driver.
 */
function flattenInternalDriver(driver) {
  if (driver[INTERNAL_DRIVER_SYMBOL]) {
    return _extends({}, (0, _omit2.default)(driver, INTERNAL_DRIVER_SYMBOL), driver[INTERNAL_DRIVER_SYMBOL]);
  } else {
    return driver;
  }
}