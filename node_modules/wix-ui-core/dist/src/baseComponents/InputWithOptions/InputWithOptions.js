"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var InputWithOptions_st_css_1 = require("./InputWithOptions.st.css");
var Dropdown_1 = require("../Dropdown");
var DropdownOption_1 = require("../DropdownOption");
var prop_types_1 = require("prop-types");
var Input_1 = require("../../components/Input");
/**
 * InputWithOptions
 */
var InputWithOptions = /** @class */ (function (_super) {
    __extends(InputWithOptions, _super);
    function InputWithOptions(props) {
        var _this = _super.call(this, props) || this;
        _this.isEditing = false;
        _this._onFocus = _this._onFocus.bind(_this);
        _this._onSelect = _this._onSelect.bind(_this);
        _this._onKeyDown = _this._onKeyDown.bind(_this);
        return _this;
    }
    InputWithOptions.prototype._filterOptions = function () {
        var _a = this.props, highlightMatches = _a.highlightMatches, inputProps = _a.inputProps, options = _a.options;
        if (!inputProps.value || !this.isEditing) {
            return options;
        }
        var lowerValue = inputProps.value.toLowerCase();
        var filteredOptions = options
            .filter(function (option) {
            return (!option.isSelectable && option.value) ||
                (option.isSelectable && option.value && option.value.toLowerCase().includes(lowerValue));
        });
        if (!highlightMatches) {
            return filteredOptions;
        }
        return filteredOptions.map(function (option) {
            return option.isSelectable && option.value ? DropdownOption_1.OptionFactory.createHighlighted(option, inputProps.value) : option;
        });
    };
    InputWithOptions.prototype._onSelect = function (option) {
        this.isEditing = false;
        var _a = this.props, onSelect = _a.onSelect, onManualInput = _a.onManualInput, inputProps = _a.inputProps;
        if (option) {
            onSelect(option);
        }
        else {
            onManualInput(inputProps.value);
        }
    };
    InputWithOptions.prototype._onKeyDown = function (event) {
        if (!event.key.startsWith('Arrow')) {
            this.isEditing = true;
        }
        var onKeyDown = this.props.inputProps.onKeyDown;
        onKeyDown && onKeyDown(event);
    };
    InputWithOptions.prototype._onFocus = function (event) {
        this.isEditing = false;
        var onFocus = this.props.inputProps.onFocus;
        onFocus && onFocus(event);
    };
    InputWithOptions.prototype.render = function () {
        var _a = this.props, placement = _a.placement, options = _a.options, openTrigger = _a.openTrigger, initialSelectedIds = _a.initialSelectedIds, onInitialSelectedOptionsSet = _a.onInitialSelectedOptionsSet, multi = _a.multi, fixedFooter = _a.fixedFooter, fixedHeader = _a.fixedHeader, timeout = _a.timeout, onDeselect = _a.onDeselect, inputProps = _a.inputProps, forceContentElementVisibility = _a.forceContentElementVisibility, inlineStyles = _a.style, id = _a.id;
        return (React.createElement(Dropdown_1.Dropdown, __assign({}, InputWithOptions_st_css_1.default('root', {}, this.props), { placement: placement, openTrigger: openTrigger, disabled: inputProps.disabled, onSelect: this._onSelect, showArrow: false, fixedFooter: fixedFooter, fixedHeader: fixedHeader, onDeselect: onDeselect, initialSelectedIds: initialSelectedIds, onInitialSelectedOptionsSet: onInitialSelectedOptionsSet, options: this._filterOptions(), timeout: timeout, multi: multi, forceContentElementVisibility: forceContentElementVisibility, style: inlineStyles, id: id }),
            React.createElement(Input_1.Input, __assign({ "data-hook": "input" }, inputProps, { onKeyDown: this._onKeyDown, onFocus: this._onFocus, className: InputWithOptions_st_css_1.default.inputComponent }))));
    };
    InputWithOptions.displayName = 'InputWithOptions';
    InputWithOptions.defaultProps = {
        openTrigger: 'click',
        placement: 'bottom-start',
        multi: false,
        initialSelectedIds: [],
        highlightMatches: true,
        onSelect: function () { return null; },
        onDeselect: function () { return null; },
        onManualInput: function () { return null; },
        onInitialSelectedOptionsSet: function () { return null; }
    };
    InputWithOptions.propTypes = {
        /** The location to display the content */
        placement: prop_types_1.oneOf(['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']),
        /** The dropdown options array */
        options: prop_types_1.arrayOf(DropdownOption_1.optionPropType).isRequired,
        /** Trigger type to open the content */
        openTrigger: prop_types_1.oneOf(['click', 'hover']),
        /** Handler for when an option is selected */
        onSelect: prop_types_1.func,
        /** Handler for when an option is deselected */
        onDeselect: prop_types_1.func,
        /** initial selected option ids */
        initialSelectedIds: prop_types_1.arrayOf(prop_types_1.oneOfType([prop_types_1.number, prop_types_1.string])),
        /** A callback for when initial selected options are set */
        onInitialSelectedOptionsSet: prop_types_1.func,
        /** set true for multiple selection, false for single */
        multi: prop_types_1.bool,
        /** An element that always appears at the top of the options */
        fixedHeader: prop_types_1.node,
        /** An element that always appears at the bottom of the options */
        fixedFooter: prop_types_1.node,
        /** Animation timer */
        timeout: prop_types_1.number,
        /** Callback when the user pressed the Enter key or Tab key after he wrote in the Input field - meaning the user selected something not in the list. If the component is controlled then the value will be the Input value. if not it will be `undefined`  */
        onManualInput: prop_types_1.func,
        /** Should mark the text that matched the filter */
        highlightMatches: prop_types_1.bool,
        /** If set to true, content element will always be visible, used for preview mode */
        forceContentElementVisibility: prop_types_1.bool,
        /** Input prop types */
        inputProps: prop_types_1.object.isRequired,
        /** Inline styles */
        style: prop_types_1.object,
        /** Id */
        Id: prop_types_1.string
    };
    return InputWithOptions;
}(React.PureComponent));
exports.InputWithOptions = InputWithOptions;
//# sourceMappingURL=InputWithOptions.js.map