"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var test_utils_1 = require("react-dom/test-utils");
var dom_test_container_1 = require("../../../test/dom-test-container");
var AddressInput_driver_1 = require("./AddressInput.driver");
var AddressInput_1 = require("./AddressInput");
var GoogleMapsClientStub_1 = require("./GoogleMapsClientStub");
var waitForCond = require("wait-for-cond");
var eventually = require("wix-eventually");
var helper = require("./AddressInputTestHelper");
var react_helpers_1 = require("wix-ui-test-utils/react-helpers");
var vanilla_1 = require("wix-ui-test-utils/vanilla");
var enzyme_1 = require("wix-ui-test-utils/enzyme");
var enzyme_2 = require("enzyme");
var testkit_1 = require("../../testkit");
var enzyme_3 = require("../../testkit/enzyme");
describe('AddressInput', function () {
    var container = new dom_test_container_1.ReactDOMTestContainer().unmountAfterEachTest();
    var createDriver = container.createLegacyRenderer(AddressInput_driver_1.addressInputDriverFactory);
    var driver, onSelectSpy;
    var init = function (_a) {
        if (_a === void 0) { _a = {}; }
        var handler = _a.handler, rest = __rest(_a, ["handler"]);
        GoogleMapsClientStub_1.GoogleMapsClientStub.reset();
        GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.autocomplete.mockClear();
        GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.geocode.mockClear();
        GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.placeDetails.mockClear();
        onSelectSpy = jest.fn();
        driver = createDriver(React.createElement(AddressInput_1.AddressInput, __assign({ apiKey: helper.API_KEY, lang: "en", Client: GoogleMapsClientStub_1.GoogleMapsClientStub, onSelect: onSelectSpy, handler: handler || AddressInput_1.Handler.geocode, throttleInterval: 0 }, rest)));
    };
    beforeAll(function () {
        jest.spyOn(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype, 'autocomplete');
        jest.spyOn(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype, 'geocode');
        jest.spyOn(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype, 'placeDetails');
    });
    it('Should instantiate client', function () {
        var Client = jest.fn();
        createDriver(React.createElement(AddressInput_1.AddressInput, { apiKey: "api-key", lang: "en", Client: Client, onSelect: function () { return null; } }));
        expect(Client.mock.instances.length).toBe(1);
    });
    it('Should call MapsClient.autocomplete upon typing', function () {
        init();
        driver.setValue('n');
        expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.autocomplete).toHaveBeenCalledWith(helper.API_KEY, 'en', { input: 'n' });
    });
    it('Should throttle calls to MapsClient.autocomplete', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init({ throttleInterval: 30 });
                    // For some reason updating the component takes a long time, and we need
                    // to use a large throttle interval to make sure it doesn't expire faster
                    // than it takes us to update three times.
                    driver.setValue('n');
                    driver.setValue('ne');
                    driver.setValue('new');
                    return [4 /*yield*/, eventually(function () {
                            expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.autocomplete).toHaveBeenCalledWith(helper.API_KEY, 'en', { input: 'n' });
                            expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.autocomplete).toHaveBeenCalledWith(helper.API_KEY, 'en', { input: 'new' });
                        }, { interval: 5 })];
                case 1:
                    _a.sent();
                    expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.autocomplete).toHaveBeenCalledTimes(2);
                    return [2 /*return*/];
            }
        });
    }); });
    it('Should call MapsClient.autocomplete upon typing, with types', function () {
        var types = ['hello', 'world'];
        init({ types: types });
        driver.setValue('n');
        expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.autocomplete)
            .toHaveBeenCalledWith(helper.API_KEY, 'en', { input: 'n', types: types });
    });
    it('Should not display results until user typed', function () {
        init();
        driver.click();
        expect(driver.isContentElementExists()).toBeFalsy();
    });
    it('Should display results', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init();
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1, helper.ADDRESS_2]);
                    driver.click();
                    driver.setValue('n');
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    expect(helper.getOptionsText(driver)).toEqual([helper.ADDRESS_DESC_1, helper.ADDRESS_DESC_2]);
                    return [2 /*return*/];
            }
        });
    }); });
    it('Should not render location icon by default', function () { return __awaiter(_this, void 0, void 0, function () {
        var element;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init();
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1, helper.ADDRESS_2]);
                    driver.click();
                    driver.setValue('n');
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    element = driver.optionAt(0).getElement();
                    expect(element.querySelector('[data-hook="location-icon-wrapper"]')).toBe(null);
                    return [2 /*return*/];
            }
        });
    }); });
    it('Should render location icon if provided', function () { return __awaiter(_this, void 0, void 0, function () {
        var element;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init({ locationIcon: React.createElement("div", { "data-hook": "location-icon" }) });
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1, helper.ADDRESS_2]);
                    driver.click();
                    driver.setValue('n');
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    element = driver.optionAt(0).getElement();
                    expect(element.querySelector('[data-hook="location-icon"]')).not.toBe(null);
                    return [2 /*return*/];
            }
        });
    }); });
    it('Should empty suggestion immediately list if string is empty', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init();
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1]);
                    driver.click();
                    driver.setValue('n');
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    driver.setValue('');
                    expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.autocomplete).toHaveBeenCalledTimes(1);
                    expect(driver.isContentElementExists()).toBeFalsy();
                    return [2 /*return*/];
            }
        });
    }); });
    it('Should display results filtered results', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init({ filterTypes: ['airport'] });
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1, helper.ADDRESS_2]);
                    driver.click();
                    driver.setValue('n');
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    expect(helper.getOptionsText(driver)).toEqual([helper.ADDRESS_DESC_2]);
                    return [2 /*return*/];
            }
        });
    }); });
    it('Should return all addresses in case filterTypes is an empty array', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init({ filterTypes: [] });
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1, helper.ADDRESS_2]);
                    driver.click();
                    driver.setValue('n');
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    expect(helper.getOptionsText(driver)).toEqual([helper.ADDRESS_DESC_1, helper.ADDRESS_DESC_2]);
                    return [2 /*return*/];
            }
        });
    }); });
    it('Should issue a geocode request once an option is chosen', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init();
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1, helper.ADDRESS_2]);
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setGeocode(helper.GEOCODE_2);
                    driver.click();
                    driver.setValue('n');
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    driver.optionAt(1).click();
                    expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.geocode).toHaveBeenCalledWith(helper.API_KEY, 'en', { placeId: helper.ADDRESS_2.place_id });
                    return [2 /*return*/, eventually(function () {
                            expect(onSelectSpy).toHaveBeenCalledWith({
                                originValue: helper.ADDRESS_DESC_2,
                                googleResult: helper.GEOCODE_2,
                                address: helper.INTERNAL_ADDRESS_GEOCODE_2
                            });
                        }, { interval: 5 })];
            }
        });
    }); });
    it('Should append region to geocode request if countryCode prop is set', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init({ countryCode: 'IL' });
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1]);
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setGeocode(helper.GEOCODE_1);
                    driver.click();
                    driver.setValue('n');
                    expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.autocomplete)
                        .toHaveBeenCalledWith(helper.API_KEY, 'en', { input: 'n', componentRestrictions: { country: 'il' } });
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    driver.optionAt(0).click();
                    expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.geocode).toHaveBeenCalledWith(helper.API_KEY, 'en', {
                        placeId: helper.ADDRESS_1.place_id,
                        region: 'IL'
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it('Should not append region to placeDetails request even if countryCode prop is set', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init({ handler: AddressInput_1.Handler.places, countryCode: 'IL' });
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1]);
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setPlaceDetails(helper.PLACE_DETAILS_1);
                    driver.click();
                    driver.setValue('n');
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    driver.optionAt(0).click();
                    expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.placeDetails).toHaveBeenCalledWith(helper.API_KEY, 'en', {
                        placeId: helper.ADDRESS_1.place_id
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    it('Should issue a placeDetails request once an option is chosen', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init({ handler: AddressInput_1.Handler.places });
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1, helper.ADDRESS_2]);
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setPlaceDetails(helper.PLACE_DETAILS_2);
                    driver.click();
                    driver.setValue('n');
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    driver.optionAt(1).click();
                    expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.placeDetails).toHaveBeenCalledWith(helper.API_KEY, 'en', { placeId: helper.ADDRESS_2.place_id });
                    return [2 /*return*/, eventually(function () {
                            expect(onSelectSpy).toHaveBeenCalledWith({
                                originValue: helper.ADDRESS_DESC_2,
                                googleResult: helper.PLACE_DETAILS_2,
                                address: helper.INTERNAL_ADDRESS_PLACE_DETAILS_2
                            });
                        }, { interval: 5 })];
            }
        });
    }); });
    it('Should try and street number', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    init();
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1]);
                    GoogleMapsClientStub_1.GoogleMapsClientStub.setGeocode(helper.PLACE_DETAILS_1);
                    driver.click();
                    driver.setValue('11 n');
                    return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                case 1:
                    _a.sent();
                    driver.optionAt(0).click();
                    return [2 /*return*/, eventually(function () {
                            var firstCallArgument = onSelectSpy.mock.calls[0][0];
                            var address_components = firstCallArgument.googleResult.address_components;
                            expect(firstCallArgument.address.number).toBe('11');
                            expect(address_components).toEqual([{
                                    long_name: '11',
                                    short_name: '11',
                                    types: [
                                        'street_number'
                                    ]
                                }]);
                        }, { interval: 5 })];
            }
        });
    }); });
    describe('State management', function () {
        it('Should update input value as user types, even if value is set', function () {
            init({ value: '1 Ibn Gabirol st.' });
            driver.setValue('n');
            expect(driver.getValue()).toBe('n');
        });
        it('Should update input value upon value prop change', function () {
            var wrapper = enzyme_2.mount(React.createElement(AddressInput_1.AddressInput, { Client: GoogleMapsClientStub_1.GoogleMapsClientStub, apiKey: "a", lang: "en", onSelect: function () { return null; }, value: "123 Ibn Gabirol st." }));
            var addressInputDriver = AddressInput_driver_1.addressInputDriverFactory({ element: wrapper.getDOMNode(), eventTrigger: test_utils_1.Simulate });
            addressInputDriver.setValue('n');
            expect(addressInputDriver.getValue()).toBe('n');
            var newValue = '321 Ibn Gabirol st.';
            wrapper.setProps({ value: newValue });
            expect(addressInputDriver.getValue()).toBe(newValue);
            addressInputDriver.setValue('n');
            expect(addressInputDriver.getValue()).toBe('n');
            wrapper.setProps({ value: newValue });
            expect(addressInputDriver.getValue()).toBe('n');
        });
    });
    describe('Fallback to manual', function () {
        it('Should call onSet (with handler) with raw input if there are no suggestions', function () {
            init({ fallbackToManual: true });
            GoogleMapsClientStub_1.GoogleMapsClientStub.setGeocode(helper.GEOCODE_1);
            driver.click();
            driver.setValue('n');
            driver.keyDown('Enter');
            return eventually(function () {
                expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.geocode).toHaveBeenCalledWith(helper.API_KEY, 'en', { address: 'n' });
                expect(onSelectSpy).toHaveBeenCalledWith(expect.objectContaining({
                    googleResult: helper.GEOCODE_1
                }));
            }, { interval: 5 });
        });
        it('Should call onSet with null if there are no suggestions and user input is empty', function () {
            init({ fallbackToManual: true });
            driver.click();
            driver.setValue('');
            driver.keyDown('Enter');
            return eventually(function () {
                expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.geocode).not.toHaveBeenCalledWith();
                expect(onSelectSpy).toHaveBeenCalledWith(null);
            }, { interval: 5 });
        });
        it('Should not should fall back to geocode when places api is selected and using raw input', function () {
            init({ fallbackToManual: true, handler: AddressInput_1.Handler.places });
            GoogleMapsClientStub_1.GoogleMapsClientStub.setGeocode(helper.GEOCODE_1);
            driver.click();
            driver.setValue('n');
            driver.keyDown('Enter');
            return eventually(function () {
                expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.geocode).toHaveBeenCalledWith(helper.API_KEY, 'en', { address: 'n' });
                expect(onSelectSpy).toHaveBeenCalledWith(expect.objectContaining({
                    googleResult: helper.GEOCODE_1
                }));
            }, { interval: 5 });
        });
        it('Should not call onSet in case there are suggestions', function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        init({ fallbackToManual: true });
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1]);
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setGeocode(helper.GEOCODE_1);
                        driver.click();
                        driver.setValue('n');
                        return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                    case 1:
                        _a.sent();
                        driver.keyDown('Enter');
                        expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.geocode).not.toHaveBeenCalled();
                        expect(onSelectSpy).not.toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should not call onSet in case there are pending suggestions', function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        init({ fallbackToManual: true });
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1], 100);
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setGeocode(helper.GEOCODE_1);
                        driver.click();
                        driver.setValue('n');
                        driver.keyDown('Enter');
                        return [4 /*yield*/, react_helpers_1.sleep(10)];
                    case 1:
                        _a.sent();
                        expect(GoogleMapsClientStub_1.GoogleMapsClientStub.prototype.geocode).not.toHaveBeenCalled();
                        expect(onSelectSpy).not.toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('Stale requests', function () {
        it('Should ignore stale requests - autocomplete', function () { return __awaiter(_this, void 0, void 0, function () {
            var firstRequest, secondRequest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        init({ throttleInterval: 0 });
                        firstRequest = GoogleMapsClientStub_1.GoogleMapsClientStub.setAddressesPromise([helper.ADDRESS_1]);
                        driver.click();
                        driver.setValue('n');
                        secondRequest = GoogleMapsClientStub_1.GoogleMapsClientStub.setAddressesPromise([helper.ADDRESS_2]);
                        driver.click();
                        driver.setValue('ne');
                        secondRequest.resolve();
                        return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                    case 1:
                        _a.sent();
                        expect(helper.getOptionsText(driver)).toEqual([helper.ADDRESS_DESC_2]);
                        firstRequest.resolve();
                        return [4 /*yield*/, waitForCond.assertHold(function () {
                                expect(helper.getOptionsText(driver)).toEqual([helper.ADDRESS_DESC_2]);
                            }, 10, 'Address description changed')];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should ignore stale requests - geocode', function () { return __awaiter(_this, void 0, void 0, function () {
            var firstRequest, secondRequest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        init({ throttleInterval: 0 });
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1]);
                        firstRequest = GoogleMapsClientStub_1.GoogleMapsClientStub.setGeocodePromise(helper.GEOCODE_1);
                        driver.click();
                        driver.setValue('n');
                        return [4 /*yield*/, helper.waitForSingleOption(helper.ADDRESS_DESC_1, driver)];
                    case 1:
                        _a.sent();
                        driver.optionAt(0).click();
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_2]);
                        secondRequest = GoogleMapsClientStub_1.GoogleMapsClientStub.setGeocodePromise(helper.GEOCODE_2);
                        driver.click();
                        driver.setValue('ne');
                        return [4 /*yield*/, helper.waitForSingleOption(helper.ADDRESS_DESC_2, driver)];
                    case 2:
                        _a.sent();
                        driver.optionAt(0).click();
                        secondRequest.resolve();
                        firstRequest.resolve();
                        return [2 /*return*/, eventually(function () {
                                expect(onSelectSpy).toHaveBeenCalledWith({
                                    originValue: helper.ADDRESS_DESC_2,
                                    googleResult: helper.GEOCODE_2,
                                    address: helper.INTERNAL_ADDRESS_GEOCODE_2
                                });
                                expect(onSelectSpy).toHaveBeenCalledTimes(1);
                            }, { interval: 5 })];
                }
            });
        }); });
        it('Should ignore stale requests - placeDetails', function () { return __awaiter(_this, void 0, void 0, function () {
            var firstRequest, secondRequest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        init({ handler: AddressInput_1.Handler.places });
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1]);
                        firstRequest = GoogleMapsClientStub_1.GoogleMapsClientStub.setPlaceDetailsPromise(helper.PLACE_DETAILS_1);
                        driver.click();
                        driver.setValue('n');
                        return [4 /*yield*/, helper.waitForSingleOption(helper.ADDRESS_DESC_1, driver)];
                    case 1:
                        _a.sent();
                        driver.optionAt(0).click();
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_2]);
                        secondRequest = GoogleMapsClientStub_1.GoogleMapsClientStub.setPlaceDetailsPromise(helper.PLACE_DETAILS_2);
                        driver.click();
                        driver.setValue('ne');
                        return [4 /*yield*/, helper.waitForSingleOption(helper.ADDRESS_DESC_2, driver)];
                    case 2:
                        _a.sent();
                        driver.optionAt(0).click();
                        secondRequest.resolve();
                        firstRequest.resolve();
                        return [2 /*return*/, eventually(function () {
                                expect(onSelectSpy).toHaveBeenCalledWith({
                                    originValue: helper.ADDRESS_DESC_2,
                                    googleResult: helper.PLACE_DETAILS_2,
                                    address: helper.INTERNAL_ADDRESS_PLACE_DETAILS_2
                                });
                                expect(onSelectSpy).toHaveBeenCalledTimes(1);
                            }, { interval: 5 })];
                }
            });
        }); });
    });
    describe('Integration with InputWithOptions', function () {
        it('Should pass value prop', function () {
            init({ value: 'value' });
            expect(driver.getValue()).toBe('value');
        });
        it('Should pass placeholder prop', function () {
            init({ placeholder: 'placeholder' });
            expect(driver.getPlaceholder()).toBe('placeholder');
        });
        it('Should pass readOnly prop (true)', function () {
            init({ readOnly: true });
            expect(driver.isReadOnly()).toBeTruthy();
        });
        it('Should pass readOnly prop (false)', function () {
            init({});
            expect(driver.isReadOnly()).toBeFalsy();
        });
        it('Should pass disabled prop (true)', function () {
            init({ disabled: true });
            expect(driver.isDisabled()).toBeTruthy();
        });
        it('Should pass disabled prop (false)', function () {
            init({});
            expect(driver.isDisabled()).toBeFalsy();
        });
        it('Should handle onChange event', function () {
            var onChange = jest.fn();
            init({ onChange: onChange });
            driver.setValue('a');
            expect(onChange).toHaveBeenCalledWith(expect.objectContaining({ target: { value: 'a' } }));
        });
        it('Should handle onKeyDown event', function () {
            var onKeyDown = jest.fn();
            init({ onKeyDown: onKeyDown });
            driver.keyDown('a');
            expect(onKeyDown).toHaveBeenCalledWith(expect.objectContaining({ key: 'a' }));
        });
        it('Should handle onFocus event', function () {
            var onFocus = jest.fn();
            init({ onFocus: onFocus });
            driver.focus();
            expect(onFocus).toHaveBeenCalled();
        });
        it('Should handle onBlur event', function () {
            var onBlur = jest.fn();
            init({ onBlur: onBlur });
            driver.blur();
            expect(onBlur).toHaveBeenCalled();
        });
        it('Should have a focus and blur method', function () {
            var wrapper = enzyme_2.mount(React.createElement(AddressInput_1.AddressInput, { Client: GoogleMapsClientStub_1.GoogleMapsClientStub, apiKey: "a", lang: "en", onSelect: function () { return null; } }), { attachTo: container.node });
            var input = wrapper.find('input').getDOMNode();
            var instance = wrapper.instance();
            expect(document.activeElement).not.toBe(input);
            instance.focus();
            expect(document.activeElement).toBe(input);
            instance.blur();
            expect(document.activeElement).not.toBe(input);
        });
        it('Should clear suggestions on blur', function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        init({ clearSuggestionsOnBlur: true });
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1, helper.ADDRESS_2]);
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setGeocode(helper.GEOCODE_1);
                        driver.click();
                        driver.setValue('n');
                        return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                    case 1:
                        _a.sent();
                        driver.optionAt(0).click();
                        driver.blur();
                        return [4 /*yield*/, waitForCond(function () { return !driver.isContentElementExists(); })];
                    case 2:
                        _a.sent();
                        driver.click();
                        expect(driver.isContentElementExists()).toBeFalsy();
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should handle onManualInput', function () { return __awaiter(_this, void 0, void 0, function () {
            var onManualInput;
            return __generator(this, function (_a) {
                onManualInput = jest.fn();
                init({ onManualInput: onManualInput });
                driver.click();
                driver.setValue('n');
                driver.keyDown('Enter');
                expect(onManualInput).toHaveBeenCalled();
                return [2 /*return*/];
            });
        }); });
        it('Should pass inline styles', function () {
            var style = { backgroundColor: 'green' };
            init({ style: style });
            expect(driver.inlineStyles()['background-color']).toBe('green');
        });
        it('Should pass ID prop', function () {
            var id = 'my-address-input-id';
            init({ id: id });
            expect(driver.getElementId()).toBe(id);
        });
    });
    describe('Preview states', function () {
        it('Should display content element', function () {
            init({ forceContentElementVisibility: true });
            expect(driver.isContentElementExists()).toBeTruthy();
        });
        it('Should display content element', function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        init({ forceOptions: [{ place_id: 0, description: 'a' }] });
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1]);
                        driver.click();
                        driver.setValue('n');
                        return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                    case 1:
                        _a.sent();
                        expect(helper.getOptionsText(driver)).toEqual(['a']);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('suffix', function () {
        it('Should show suffix', function () {
            init({ suffix: React.createElement("div", null) });
            expect(driver.getSuffix()).toBeTruthy();
        });
        it('Should NOT show suffix', function () {
            init();
            expect(driver.getSuffix()).toBeFalsy();
        });
    });
    describe('fixedFooter', function () {
        it('Should show fixedFooter', function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        init({ fixedFooter: React.createElement("div", { "data-hook": "fixed-footer" }) });
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1]);
                        driver.click();
                        driver.setValue('n');
                        return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                    case 1:
                        _a.sent();
                        expect(driver.getContentElement().querySelector('[data-hook="fixed-footer"]')).toBeTruthy();
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should NOT show fixedFooter', function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        init();
                        GoogleMapsClientStub_1.GoogleMapsClientStub.setAddresses([helper.ADDRESS_1]);
                        driver.click();
                        driver.setValue('n');
                        return [4 /*yield*/, waitForCond(function () { return driver.isContentElementExists(); })];
                    case 1:
                        _a.sent();
                        expect(driver.getContentElement().querySelector('[data-hook="fixed-footer"]')).toBeFalsy();
                        return [2 /*return*/];
                }
            });
        }); });
        it('Should not show fixedFooter when there are no options', function () {
            init({ fixedFooter: React.createElement("div", { "data-hook": "fixed-footer" }) });
            driver.click();
            expect(driver.isContentElementExists()).toBeFalsy();
        });
    });
    describe('testkit', function () {
        it('should exist', function () {
            expect(vanilla_1.isTestkitExists(React.createElement(AddressInput_1.AddressInput, { lang: "en", Client: GoogleMapsClientStub_1.GoogleMapsClientStub, apiKey: "", onSelect: function () { return null; } }), testkit_1.addressInputTestkitFactory)).toBe(true);
        });
    });
    describe('enzyme testkit', function () {
        it('should exist', function () {
            expect(enzyme_1.isEnzymeTestkitExists(React.createElement(AddressInput_1.AddressInput, { lang: "en", Client: GoogleMapsClientStub_1.GoogleMapsClientStub, apiKey: "", onSelect: function () { return null; } }), enzyme_3.addressInputTestkitFactory, enzyme_2.mount)).toBe(true);
        });
    });
});
//# sourceMappingURL=AddressInput.spec.js.map