"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var page_strip_layout_1 = require("./page-strip-layout");
var Pagination_st_css_1 = require("./Pagination.st.css");
var PageStrip = /** @class */ (function (_super) {
    __extends(PageStrip, _super);
    function PageStrip() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.responsiveLayoutIsFresh = false;
        _this.unmounted = false;
        _this.state = { responsiveLayout: null };
        return _this;
    }
    PageStrip.prototype.componentDidMount = function () {
        var _this = this;
        if (this.props.updateResponsiveLayout) {
            // We can't do this in componentWillMount because the caller might need to access DOM here,
            // and SSR wouldn't work.
            this.props.updateResponsiveLayout(function () {
                _this.responsiveLayoutIsFresh = false;
                // Even though we register a noop callback for `this.props.updateResponsiveLayout`
                // in `componentWillUnmount`, we cannot guarantee that the user will not hold onto
                // the old callback and invoke it after unmount, which is the reason for checking
                // `this.unmounted`.
                if (!_this.unmounted) {
                    _this.updateLayoutIfNeeded();
                }
            });
        }
        else {
            this.updateLayoutIfNeeded();
        }
    };
    PageStrip.prototype.componentWillReceiveProps = function () {
        this.responsiveLayoutIsFresh = false;
    };
    PageStrip.prototype.componentDidUpdate = function () {
        if (!this.props.updateResponsiveLayout) {
            this.updateLayoutIfNeeded();
        }
        this.forceRepaintInMsEdge();
    };
    PageStrip.prototype.componentWillUnmount = function () {
        this.unmounted = true;
        if (this.props.updateResponsiveLayout) {
            this.props.updateResponsiveLayout(function () { return null; });
        }
    };
    PageStrip.prototype.render = function () {
        var _this = this;
        return (React.createElement("div", { ref: function (el) { return _this.rootNode = el; }, "data-hook": "page-strip", id: this.props.id ? this.props.id + 'pageStrip' : null, className: Pagination_st_css_1.default.pageStrip, "data-aid": "qa-page-strip" },
            React.createElement("div", { className: Pagination_st_css_1.default.pageStripInner }, this.renderLayout(this.getLayout(), false)),
            this.isResponsive() &&
                React.createElement("div", { className: Pagination_st_css_1.default.pageStripInner + ' ' + Pagination_st_css_1.default.pageStripTemplate }, this.renderLayout(page_strip_layout_1.createResponsiveLayoutTemplate(this.props), true))));
    };
    PageStrip.prototype.forceRepaintInMsEdge = function () {
        // MS Edge has a glitch that makes page numbers invisible when switching to the preview
        // mode in Santa editor. As a workaround we need to force text re-rendering.
        // Changing font-variant to small-caps should do the trick without actually affecting
        // the appearance of digits.
        var inlineStyle = this.rootNode.style;
        inlineStyle.fontVariant = inlineStyle.fontVariant ? '' : 'small-caps';
    };
    // We can't use page numbers as keys, because we might need to render the same page twice
    // for responsive layout. We also can't use index as a key, because React might reuse the
    // node for another page, and keep keyboard focus on it, which we don't want.
    PageStrip.prototype.renderLayout = function (layout, isDummy) {
        var _this = this;
        var _a = this.props, currentPage = _a.currentPage, pageUrl = _a.pageUrl, disabled = _a.disabled;
        return layout.map(function (pageNumber, index) {
            if (!pageNumber) {
                return (React.createElement("span", { key: index, className: Pagination_st_css_1.default.gap }, _this.props.gapLabel));
            }
            if (pageNumber === currentPage) {
                return (React.createElement("span", { key: pageNumber + '-' + index, "data-hook": "page-" + pageNumber + " current-page", "aria-label": "Page " + pageNumber, className: Pagination_st_css_1.default.currentPage }, pageNumber));
            }
            if (isDummy) {
                return React.createElement("a", { key: pageNumber + '-' + index, className: Pagination_st_css_1.default.pageButton }, pageNumber);
            }
            return (React.createElement("a", { key: pageNumber + '-' + index, "data-hook": "page-" + pageNumber, "aria-label": "Page " + pageNumber, className: Pagination_st_css_1.default.pageButton, tabIndex: disabled || pageUrl ? null : 0, onClick: disabled ? null : (function (e) { return _this.props.onPageClick(e, pageNumber); }), onKeyDown: disabled ? null : (function (e) { return _this.props.onPageKeyDown(e, pageNumber); }), href: !disabled && pageUrl ? pageUrl(pageNumber) : null }, pageNumber));
        });
    };
    PageStrip.prototype.isResponsive = function () {
        return this.props.responsive && this.props.totalPages > 0 && this.props.maxPagesToShow > 1;
    };
    PageStrip.prototype.getLayout = function () {
        if (!this.isResponsive()) {
            return page_strip_layout_1.createStaticLayout(this.props);
        }
        if (this.state.responsiveLayout) {
            return this.state.responsiveLayout;
        }
        return page_strip_layout_1.createStaticLayout({
            totalPages: this.props.totalPages,
            currentPage: this.props.currentPage,
            showFirstPage: this.props.showFirstPage,
            showLastPage: this.props.showLastPage,
            // This is pretty arbitrary. 5 is the minimum space required to show the first, current, and last page.
            maxPagesToShow: 5
        });
    };
    PageStrip.prototype.updateLayoutIfNeeded = function () {
        if (!this.isResponsive() || this.responsiveLayoutIsFresh) {
            return;
        }
        this.responsiveLayoutIsFresh = true;
        this.setState({
            responsiveLayout: page_strip_layout_1.createResponsiveLayout({
                container: this.rootNode.children[1],
                totalPages: this.props.totalPages,
                currentPage: this.props.currentPage,
                maxPagesToShow: this.props.maxPagesToShow,
                showFirstPage: this.props.showFirstPage,
                showLastPage: this.props.showLastPage
            })
        });
    };
    return PageStrip;
}(React.Component));
exports.PageStrip = PageStrip;
//# sourceMappingURL=PageStrip.js.map