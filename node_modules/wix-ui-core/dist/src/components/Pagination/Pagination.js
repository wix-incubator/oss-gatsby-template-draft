"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var prop_types_1 = require("prop-types");
var PageStrip_1 = require("./PageStrip");
var Pagination_st_css_1 = require("./Pagination.st.css");
var root_min_width_1 = require("./root-min-width");
var upperCaseFirst = function (str) { return str[0].toUpperCase() + str.slice(1); };
exports.getId = function (idPrefix, name) {
    if (idPrefix === void 0) { idPrefix = ''; }
    if (name === void 0) { name = ''; }
    return idPrefix ? idPrefix + name : null;
};
exports.calculateWidth = function (totalPages) { return totalPages.toString().length + "em"; };
var ButtonType;
(function (ButtonType) {
    ButtonType["Prev"] = "previous";
    ButtonType["Next"] = "next";
    ButtonType["First"] = "first";
    ButtonType["Last"] = "last";
})(ButtonType || (ButtonType = {}));
var Pagination = /** @class */ (function (_super) {
    __extends(Pagination, _super);
    function Pagination() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            pageInputValue: String(_this.props.currentPage),
            pageInputHasError: false
        };
        _this.handlePageInputChange = function (e) {
            _this.setState({
                pageInputValue: e.target.value,
                pageInputHasError: false
            });
        };
        _this.handlePageInputKeyDown = function (event) {
            // Enter
            if (event.keyCode === 13) {
                var page = Number(_this.state.pageInputValue);
                if (page !== _this.props.currentPage) {
                    if (1 <= page && page <= _this.props.totalPages) {
                        _this.props.onChange({ event: event, page: page });
                    }
                    else {
                        _this.setState({ pageInputHasError: true });
                    }
                }
            }
        };
        _this.handlePageInputBlur = function (event) {
            _this.setState({
                pageInputValue: String(_this.props.currentPage),
                pageInputHasError: false
            });
        };
        _this.handlePageClick = function (event, page) {
            _this.props.onChange({ event: event, page: page });
        };
        _this.handlePageKeyDown = function (event, page) {
            // Enter or Space
            if (event.keyCode === 13 || event.keyCode === 32) {
                _this.props.onChange({ event: event, page: page });
            }
        };
        return _this;
    }
    Pagination.prototype.updateRootMinWidth = function () {
        root_min_width_1.measureAndSetRootMinWidth(this.rootNode, this.props.paginationMode, this.props.id);
    };
    Pagination.prototype.componentDidMount = function () {
        this.props.updateResponsiveLayout && this.updateRootMinWidth();
    };
    Pagination.prototype.componentDidUpdate = function () {
        this.props.updateResponsiveLayout && this.updateRootMinWidth();
    };
    Pagination.prototype.getId = function (elementName) {
        if (elementName === void 0) { elementName = ''; }
        return exports.getId(this.props.id, elementName);
    };
    Object.defineProperty(Pagination.prototype, "maxPagesToShow", {
        get: function () {
            if (this.props.maxPagesToShow) {
                return this.props.maxPagesToShow;
            }
            else if (this.props.responsive) {
                return 20;
            }
            else {
                return 7;
            }
        },
        enumerable: true,
        configurable: true
    });
    Pagination.prototype.renderPageStrip = function () {
        return (React.createElement(PageStrip_1.PageStrip, { id: this.props.id, totalPages: this.props.totalPages, currentPage: this.props.currentPage, maxPagesToShow: this.maxPagesToShow, showFirstPage: this.props.showFirstPage, showLastPage: this.props.showLastPage, responsive: this.props.responsive, pageUrl: this.props.pageUrl, gapLabel: this.props.gapLabel, onPageClick: this.handlePageClick, onPageKeyDown: this.handlePageKeyDown, updateResponsiveLayout: this.props.updateResponsiveLayout, disabled: this.props.disabled }));
    };
    Pagination.prototype.renderPageForm = function () {
        return (React.createElement("div", { "data-hook": "page-form", id: this.getId('pageForm'), className: Pagination_st_css_1.default.pageForm, dir: "ltr" },
            React.createElement("input", { id: this.getId('pageInput'), "data-hook": "page-input", type: "number", className: Pagination_st_css_1.default.pageInput, min: 1, max: this.props.totalPages, value: this.state.pageInputValue, disabled: this.props.disabled, onChange: this.handlePageInputChange, onKeyDown: this.handlePageInputKeyDown, "aria-label": 'Page number, select a number between 1 and ' + this.props.totalPages, onBlur: this.handlePageInputBlur, style: { width: exports.calculateWidth(this.props.totalPages) } }),
            this.props.showInputModeTotalPages && [
                React.createElement("span", { key: "slash", id: this.getId('slash'), className: Pagination_st_css_1.default.slash }, this.props.slashLabel),
                React.createElement("span", { key: "total-pages", id: this.getId('totalPages'), "data-hook": "total-pages", className: Pagination_st_css_1.default.totalPages }, this.props.totalPages)
            ]));
    };
    Pagination.prototype.renderNavButton = function (type) {
        var _this = this;
        var _a = this.props, currentPage = _a.currentPage, totalPages = _a.totalPages, pageUrl = _a.pageUrl;
        var disabled = this.props.disabled || (((type === ButtonType.First || type === ButtonType.Prev) && currentPage <= 1) ||
            ((type === ButtonType.Last || type === ButtonType.Next) && currentPage >= totalPages));
        var _b = (_c = {},
            _c[ButtonType.Prev] = [Pagination_st_css_1.default.navButtonPrevious, this.props.previousLabel, currentPage - 1],
            _c[ButtonType.Next] = [Pagination_st_css_1.default.navButtonNext, this.props.nextLabel, currentPage + 1],
            _c[ButtonType.First] = [Pagination_st_css_1.default.navButtonFirst, this.props.firstLabel, 1],
            _c[ButtonType.Last] = [Pagination_st_css_1.default.navButtonLast, this.props.lastLabel, totalPages],
            _c)[type], btnClass = _b[0], label = _b[1], page = _b[2];
        return (React.createElement("a", __assign({ "data-hook": type, id: this.getId('navButton' + upperCaseFirst(type)) }, Pagination_st_css_1.default('navButton ' + btnClass, { disabled: disabled }), { "aria-label": upperCaseFirst(type) + ' Page', tabIndex: disabled || pageUrl ? null : 0, onClick: disabled ? null : function (event) { return _this.handlePageClick(event, page); }, onKeyDown: disabled ? null : function (event) { return _this.handlePageKeyDown(event, page); }, href: !disabled && pageUrl ? pageUrl(page) : null }), label));
        var _c;
    };
    Pagination.prototype.componentWillReceiveProps = function (nextProps) {
        this.setState({
            pageInputValue: String(nextProps.currentPage),
            pageInputHasError: false
        });
    };
    Pagination.prototype.render = function () {
        var _this = this;
        var _a = this.props, showFirstLastNavButtons = _a.showFirstLastNavButtons, paginationMode = _a.paginationMode, width = _a.width, style = _a.style;
        var styleStates = {
            disabled: this.props.disabled,
            error: this.state.pageInputHasError
        };
        return (React.createElement("nav", __assign({ ref: function (el) { return _this.rootNode = el; }, id: this.getId(''), role: "navigation", "aria-label": "Pagination Navigation", dir: this.props.rtl ? 'rtl' : null, onClick: this.props.onClick, onDoubleClick: this.props.onDoubleClick, onMouseEnter: this.props.onMouseEnter, onMouseLeave: this.props.onMouseLeave, style: style || { width: width } }, Pagination_st_css_1.default('root', styleStates, this.props)),
            this.renderNavButton(ButtonType.Next),
            this.renderNavButton(ButtonType.Prev),
            paginationMode === 'input' ? this.renderPageForm() : this.renderPageStrip(),
            showFirstLastNavButtons && this.renderNavButton(ButtonType.First),
            showFirstLastNavButtons && this.renderNavButton(ButtonType.Last)));
    };
    Pagination.displayName = 'Pagination';
    // this is a technical debt - remove once we have support for typescript props in autodocs
    Pagination.propTypes = {
        /** The number of pages available to paginate */
        totalPages: prop_types_1.number.isRequired,
        /** Current page to be shown as current. defaults to 1 */
        currentPage: prop_types_1.number,
        /** Function that generates URLs for page links. If onitted, pages don't link anywhere. */
        pageUrl: prop_types_1.func,
        /** Callback to be called when pagination happens - structure ({event, page: number}) => void */
        onChange: prop_types_1.func,
        /** Called when the pagination is clicked*/
        onClick: prop_types_1.func,
        /** Called when the pagination is double clicked*/
        onDoubleClick: prop_types_1.func,
        /** Called when mouse enters pagination*/
        onMouseEnter: prop_types_1.func,
        /** Called when mouse leaves pagination*/
        onMouseLeave: prop_types_1.func,
        /** Changes page selection mode between page selection and input field. defaults to 'pages'*/
        paginationMode: prop_types_1.oneOf(['pages', 'input']),
        /** Shows the 'first' and 'last' navigation buttons. defaults to false */
        showFirstLastNavButtons: prop_types_1.bool,
        /** Text to appear for the 'first' navigation button */
        firstLabel: prop_types_1.node,
        /** Text to appear for the 'previous' navigation button */
        previousLabel: prop_types_1.node,
        /** Text to appear for the 'next' navigation button */
        nextLabel: prop_types_1.node,
        /** Text to appear for the 'last' navigation button */
        lastLabel: prop_types_1.node,
        /** Text to appear in the gap between page numbers */
        gapLabel: prop_types_1.node,
        /** Text to appear between the input and the total number of pages in paginationMode="input" */
        slashLabel: prop_types_1.node,
        /**  Whether the component layout is right to left */
        rtl: prop_types_1.bool,
        /** The pixel width the component will render in  */
        width: prop_types_1.number,
        /** Whether the page numbers always show the first page  */
        showFirstPage: prop_types_1.bool,
        /** Whether the page numbers always show the last page  */
        showLastPage: prop_types_1.bool,
        /** Whether the to show the total amount of pages next to the input field in "input" paginationMode */
        showInputModeTotalPages: prop_types_1.bool,
        /** In 'pages' mode automatically limits the number of pages such that they don't overflow the container */
        responsive: prop_types_1.bool,
        /** In 'pages' mode defines the maximum number of pages to show */
        maxPagesToShow: prop_types_1.number,
        /** Component class name */
        className: prop_types_1.string,
        /** Component ID */
        id: prop_types_1.string,
        /** Allows to trigger responsive layout update on window dimensions change, font load, etc. */
        updateResponsiveLayout: prop_types_1.func,
        /** Makes pagination non-interactive */
        disabled: prop_types_1.bool
    };
    Pagination.defaultProps = {
        currentPage: 1,
        showFirstLastNavButtons: false,
        showFirstPage: false,
        showLastPage: false,
        responsive: false,
        paginationMode: 'pages',
        showInputModeTotalPages: false,
        disabled: false,
        // dir="rtl" automatically flips the direction of less-than and more-than signs.
        // If we decide to use different labels we need to add conditional logic.
        firstLabel: '<<',
        lastLabel: '>>',
        previousLabel: '<',
        nextLabel: '>',
        gapLabel: '...',
        slashLabel: '\u00A0/\u00A0'
    };
    return Pagination;
}(React.Component));
exports.Pagination = Pagination;
//# sourceMappingURL=Pagination.js.map