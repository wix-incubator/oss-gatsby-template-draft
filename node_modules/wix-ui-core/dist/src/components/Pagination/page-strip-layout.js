"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function createStaticLayout(_a) {
    var totalPages = _a.totalPages, currentPage = _a.currentPage, maxPagesToShow = _a.maxPagesToShow, showFirstPage = _a.showFirstPage, showLastPage = _a.showLastPage;
    return createLayout({
        totalPages: totalPages,
        currentPage: currentPage,
        lowerBound: 1,
        upperBound: totalPages,
        pageRangeCost: function (a, b) { return b - a + 1; },
        showFirstPage: showFirstPage,
        showLastPage: showLastPage,
        rewindToFirstCost: 2,
        rewindToLastCost: 2,
        budget: maxPagesToShow
    });
}
exports.createStaticLayout = createStaticLayout;
function rangeToPreRenderForResponsiveLayout(totalPages, currentPage, maxPagesToShow) {
    return [
        Math.max(currentPage - maxPagesToShow, 1),
        Math.min(currentPage + maxPagesToShow, totalPages)
    ];
}
function createResponsiveLayoutTemplate(_a) {
    var totalPages = _a.totalPages, currentPage = _a.currentPage, maxPagesToShow = _a.maxPagesToShow;
    var _b = rangeToPreRenderForResponsiveLayout(totalPages, currentPage, maxPagesToShow), lowerBound = _b[0], upperBound = _b[1];
    return [1, 0].concat(closedRange(lowerBound, upperBound), [0, totalPages]);
}
exports.createResponsiveLayoutTemplate = createResponsiveLayoutTemplate;
// Takes a container with children rendered using createResponsiveLayoutTemplate,
// measures the children, and decides how many can be shown without overflowing the container.
// For measurements to work correctly the pages must not have any dynamic spacing between them
// such as justify-content: space-evenly, but they can have static spacing such as margins.
// As long as we're using flexbox with centered pages we don't need to worry about the outer
// margins of the first and last page, they will be trimmed by flexbox automatically.
// maxPagesToShow is not really taken into account, it's used to derive the range of pages
// that was pre-rendered by createResponsiveLayoutTemplate().
function createResponsiveLayout(_a) {
    var container = _a.container, totalPages = _a.totalPages, currentPage = _a.currentPage, maxPagesToShow = _a.maxPagesToShow, showFirstPage = _a.showFirstPage, showLastPage = _a.showLastPage;
    var children = Array.from(container.children);
    var pages = children.slice(2, -2);
    var containerWidth = container.getBoundingClientRect().width;
    var firstRect = children[0].getBoundingClientRect();
    var lastRect = children[children.length - 1].getBoundingClientRect();
    var lowerRect = pages[0].getBoundingClientRect();
    var upperRect = pages[pages.length - 1].getBoundingClientRect();
    var rewindToFirstCost = mergeBoundingRects(firstRect, lowerRect).width - lowerRect.width;
    var rewindToLastCost = mergeBoundingRects(lastRect, upperRect).width - upperRect.width;
    var _b = rangeToPreRenderForResponsiveLayout(totalPages, currentPage, maxPagesToShow), lowerBound = _b[0], upperBound = _b[1];
    var pageRangeCost = function (a, b) {
        var aRect = pages[a - lowerBound].getBoundingClientRect();
        var bRect = pages[b - lowerBound].getBoundingClientRect();
        return mergeBoundingRects(aRect, bRect).width;
    };
    return createLayout({
        totalPages: totalPages,
        currentPage: currentPage,
        lowerBound: lowerBound,
        upperBound: upperBound,
        pageRangeCost: pageRangeCost,
        showFirstPage: showFirstPage,
        showLastPage: showLastPage,
        rewindToFirstCost: rewindToFirstCost,
        rewindToLastCost: rewindToLastCost,
        budget: containerWidth
    });
}
exports.createResponsiveLayout = createResponsiveLayout;
function createLayoutByExpandingPageRange(_a) {
    var totalPages = _a.totalPages, low = _a.low, high = _a.high, lowerBound = _a.lowerBound, upperBound = _a.upperBound, pageRangeCost = _a.pageRangeCost, budget = _a.budget, showRewindToFirst = _a.showRewindToFirst, showRewindToLast = _a.showRewindToLast, rewindToFirstCost = _a.rewindToFirstCost, rewindToLastCost = _a.rewindToLastCost;
    var safeLowerBound = showRewindToFirst ? Math.max(lowerBound, 4) : lowerBound;
    var safeUpperBound = showRewindToLast ? Math.min(upperBound, totalPages - 3) : upperBound;
    if (!isNondecreasing([lowerBound, safeLowerBound, low, high, safeUpperBound, upperBound])) {
        return null;
    }
    lowerBound = safeLowerBound;
    upperBound = safeUpperBound;
    budget -= (showRewindToFirst ? rewindToFirstCost : 0) + (showRewindToLast ? rewindToLastCost : 0);
    var acceptableLow = 0;
    var acceptableHigh = 0;
    while (lowerBound <= low && high <= upperBound && pageRangeCost(low, high) <= budget) {
        acceptableLow = low;
        acceptableHigh = high;
        if (low === lowerBound && high === upperBound) {
            break;
        }
        low = Math.max(low - 1, lowerBound);
        high = Math.min(high + 1, upperBound);
    }
    return acceptableLow && acceptableHigh
        ? (showRewindToFirst ? [1, 0] : []).concat(closedRange(acceptableLow, acceptableHigh), (showRewindToLast ? [0, totalPages] : [])) : null;
}
function createLayout(_a) {
    var totalPages = _a.totalPages, currentPage = _a.currentPage, lowerBound = _a.lowerBound, upperBound = _a.upperBound, pageRangeCost = _a.pageRangeCost, showFirstPage = _a.showFirstPage, showLastPage = _a.showLastPage, rewindToFirstCost = _a.rewindToFirstCost, rewindToLastCost = _a.rewindToLastCost, budget = _a.budget;
    var prevOrLowerBound = Math.max(currentPage - 1, lowerBound);
    var nextOrUpperBound = Math.min(currentPage + 1, upperBound);
    var expand = function (low, high, showRewindToFirst, showRewindToLast) {
        return createLayoutByExpandingPageRange({
            totalPages: totalPages,
            low: low,
            high: high,
            lowerBound: lowerBound,
            upperBound: upperBound,
            pageRangeCost: pageRangeCost,
            budget: budget,
            showRewindToFirst: showRewindToFirst,
            showRewindToLast: showRewindToLast,
            rewindToFirstCost: rewindToFirstCost,
            rewindToLastCost: rewindToLastCost
        });
    };
    return (
    // Try to show the entire range.
    (lowerBound === 1 || !showFirstPage) && (upperBound === totalPages || !showLastPage) &&
        expand(lowerBound, upperBound, false, false) ||
        // Ellipsis only in the end. Show at least one page after the current.
        (showLastPage && lowerBound === 1) &&
            expand(lowerBound, nextOrUpperBound, false, true) ||
        // Ellipsis only in the beginning. Show at least one page before the current.
        (showFirstPage && upperBound === totalPages) &&
            expand(prevOrLowerBound, upperBound, true, false) ||
        // Ellipses on both sides. Show at least one page before the current and one after.
        (showFirstPage && showLastPage) &&
            expand(prevOrLowerBound, nextOrUpperBound, true, true) ||
        // Ellipsis only in the end. Don't try to include the next page.
        (showLastPage && lowerBound === 1) &&
            expand(lowerBound, currentPage, false, true) ||
        // Ellipsis only in the beginning. Don't try to include the previous page.
        (showFirstPage && upperBound === totalPages) &&
            expand(currentPage, upperBound, true, false) ||
        // Ellipses on both sides. Don't try to include the previous and the next page.
        (showFirstPage && showLastPage) &&
            expand(currentPage, currentPage, true, true) ||
        // Cut off both sides without adding ellipses.
        expand(currentPage, currentPage, false, false) ||
        // If there's not enough space even for the current page, still show it.
        [currentPage]);
}
function closedRange(start, stop, step) {
    if (step === void 0) { step = 1; }
    var result = [];
    for (var i = start; i <= stop; i += step) {
        result.push(i);
    }
    return result;
}
function isNondecreasing(sequence) {
    for (var i = 1; i < sequence.length; i++) {
        if (sequence[i] < sequence[i - 1]) {
            return false;
        }
    }
    return true;
}
function mergeBoundingRects(a, b) {
    var top = Math.min(a.top, b.top);
    var right = Math.max(a.right, b.right);
    var bottom = Math.max(a.bottom, b.bottom);
    var left = Math.min(a.left, b.left);
    var width = right - left;
    var height = bottom - top;
    return { top: top, right: right, bottom: bottom, left: left, width: width, height: height };
}
//# sourceMappingURL=page-strip-layout.js.map