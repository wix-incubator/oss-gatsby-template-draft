"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var popper_utils_1 = require("popper.js/dist/umd/popper-utils");
var Popover_st_css_1 = require("./Popover.st.css");
var react_popper_1 = require("react-popper");
var react_transition_group_1 = require("react-transition-group");
var react_portal_1 = require("react-portal");
var utils_1 = require("../../utils");
var stylableUtils_1 = require("../../utils/stylableUtils");
var classNames = require("classnames");
var isElement = require("lodash/isElement");
var prop_types_1 = require("prop-types");
// This is here and not in the test setup because we don't want consumers to need to run it as well
var isTestEnv = process.env.NODE_ENV === 'test';
if (isTestEnv) {
    if (!document.createRange) {
        document.createRange = function () { return ({
            setStart: function () { return null; },
            setEnd: function () { return null; },
            commonAncestorContainer: document.documentElement.querySelector('body')
        }); };
    }
}
exports.AppendToPropType = prop_types_1.oneOfType([
    prop_types_1.oneOf(['scrollParent', 'viewport', 'window']),
    prop_types_1.any
]);
exports.PlacementsType = prop_types_1.oneOf(['auto-start',
    'auto',
    'auto-end',
    'top-start',
    'top',
    'top-end',
    'right-start',
    'right',
    'right-end',
    'bottom-end',
    'bottom',
    'bottom-start',
    'left-end',
    'left',
    'left-start']);
var getArrowShift = function (shift, direction) {
    if (!shift && !isTestEnv) {
        return {};
    }
    return _a = {},
        _a[direction === 'top' || direction === 'bottom' ? 'left' : 'top'] = shift + "px",
        _a;
    var _a;
};
var createModifiers = function (_a) {
    var moveBy = _a.moveBy, appendTo = _a.appendTo;
    var modifiers = {
        offset: {
            offset: (moveBy ? moveBy.x : 0) + "px, " + (moveBy ? moveBy.y : 0) + "px"
        }
    };
    if (isTestEnv) {
        modifiers.computeStyle = { enabled: false };
    }
    if (appendTo) {
        modifiers.preventOverflow = {
            boundariesElement: appendTo
        };
    }
    return modifiers;
};
function getAppendToNode(_a) {
    var appendTo = _a.appendTo, targetRef = _a.targetRef;
    var appendToNode;
    if (appendTo === 'window' || appendTo === 'viewport') {
        appendToNode = document.body;
    }
    else if (appendTo === 'scrollParent') {
        appendToNode = popper_utils_1.getScrollParent(targetRef);
    }
    else if (isElement(appendTo)) {
        appendToNode = appendTo;
    }
    else {
        appendToNode = null;
    }
    return appendToNode;
}
;
var shouldAnimatePopover = function (_a) {
    var timeout = _a.timeout;
    return !!timeout;
};
/**
 * Popover
 */
var Popover = /** @class */ (function (_super) {
    __extends(Popover, _super);
    function Popover() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.targetRef = null;
        _this.portalNode = null;
        _this.stylesObj = null;
        _this.appendToNode = null;
        _this.state = { isMounted: false };
        return _this;
    }
    Popover.prototype.getPopperContentStructure = function (childrenObject) {
        var _a = this.props, moveBy = _a.moveBy, appendTo = _a.appendTo, placement = _a.placement, showArrow = _a.showArrow, moveArrowTo = _a.moveArrowTo;
        var modifiers = createModifiers({ moveBy: moveBy, appendTo: appendTo });
        var popper = (React.createElement(react_popper_1.Popper, { "data-hook": "popover-content", modifiers: modifiers, placement: placement, className: classNames(Popover_st_css_1.default.popover, (_b = {}, _b[Popover_st_css_1.default.withArrow] = showArrow, _b[Popover_st_css_1.default.popoverContent] = !showArrow, _b)) }, showArrow ?
            [
                React.createElement(react_popper_1.Arrow, { key: "popover-arrow", "data-hook": "popover-arrow", className: Popover_st_css_1.default.arrow, style: getArrowShift(moveArrowTo, placement) }),
                React.createElement("div", { key: "popover-content", className: Popover_st_css_1.default.popoverContent }, childrenObject.Content)
            ] :
            React.createElement("div", { key: "popover-content" }, childrenObject.Content)));
        return this.wrapWithAnimations(popper);
        var _b;
    };
    Popover.prototype.applyStylesToPortaledNode = function () {
        var shown = this.props.shown;
        var shouldAnimate = shouldAnimatePopover(this.props);
        if (shouldAnimate || shown) {
            stylableUtils_1.attachStylesToNode(this.portalNode, this.stylesObj);
        }
        else {
            stylableUtils_1.detachStylesFromNode(this.portalNode, this.stylesObj);
        }
    };
    Popover.prototype.wrapWithAnimations = function (popper) {
        var _this = this;
        var _a = this.props, timeout = _a.timeout, shown = _a.shown;
        var shouldAnimate = shouldAnimatePopover(this.props);
        return shouldAnimate ? (React.createElement(react_transition_group_1.CSSTransition, { in: shown, timeout: Number(timeout), unmountOnExit: true, classNames: Popover_st_css_1.default.popoverAnimation, onExited: function () { return stylableUtils_1.detachStylesFromNode(_this.portalNode, _this.stylesObj); } }, popper)) :
            popper;
    };
    Popover.prototype.renderPopperContent = function (childrenObject) {
        var popper = this.getPopperContentStructure(childrenObject);
        return (this.portalNode ? (React.createElement(react_portal_1.Portal, { node: this.portalNode }, popper)) :
            popper);
    };
    Popover.prototype.componentDidMount = function () {
        this.initAppendToNode();
        this.setState({ isMounted: true });
    };
    Popover.prototype.initAppendToNode = function () {
        var appendTo = this.props.appendTo;
        this.appendToNode = getAppendToNode({ appendTo: appendTo, targetRef: this.targetRef });
        if (this.appendToNode) {
            this.portalNode = document.createElement('div');
            this.portalNode.setAttribute('data-hook', 'popover-portal');
            this.appendToNode.appendChild(this.portalNode);
            // Why do we do this here ?(in componentDidMount and not ONLY in render? or when we actually attachStylesToNode)
            this.stylesObj = Popover_st_css_1.default('root', {}, this.props);
            // TODO: remove this, it is called in render
            this.applyStylesToPortaledNode();
        }
    };
    Popover.prototype.componentWillUnmount = function () {
        if (this.portalNode) {
            // FIXME: What if component is updated with a different appendTo? It is a far-fetched use-case,
            // but we would need to remove the portaled node, and created another one.
            this.appendToNode.removeChild(this.portalNode);
        }
        this.portalNode = null;
    };
    Popover.prototype.render = function () {
        var _this = this;
        var _a = this.props, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, onKeyDown = _a.onKeyDown, onClick = _a.onClick, children = _a.children, shown = _a.shown, inlineStyles = _a.style, id = _a.id;
        var isMounted = this.state.isMounted;
        var childrenObject = utils_1.buildChildrenObject(children, { Element: null, Content: null });
        var shouldAnimate = shouldAnimatePopover(this.props);
        var shouldRenderPopper = isMounted && (shouldAnimate || shown);
        if (this.portalNode) {
            this.applyStylesToPortaledNode();
        }
        return (React.createElement(react_popper_1.Manager, __assign({}, Popover_st_css_1.default('root manager', {}, this.props), { onClick: onClick, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, style: inlineStyles, id: id }),
            React.createElement(react_popper_1.Target, { onKeyDown: onKeyDown, "data-hook": "popover-element", innerRef: function (r) { return _this.targetRef = r; } }, childrenObject.Element),
            shouldRenderPopper && this.renderPopperContent(childrenObject)));
    };
    Popover.displayName = 'Popover';
    Popover.Element = utils_1.createComponentThatRendersItsChildren('Popover.Element');
    Popover.Content = utils_1.createComponentThatRendersItsChildren('Popover.Content');
    Popover.propTypes = {
        className: prop_types_1.string,
        placement: exports.PlacementsType,
        shown: prop_types_1.bool,
        onClick: prop_types_1.func,
        onMouseEnter: prop_types_1.func,
        onMouseLeave: prop_types_1.func,
        onKeyDown: prop_types_1.func,
        showArrow: prop_types_1.bool,
        moveBy: prop_types_1.shape({ x: prop_types_1.number, y: prop_types_1.number }),
        hideDelay: prop_types_1.number,
        showDelay: prop_types_1.number,
        moveArrowTo: prop_types_1.number,
        appendTo: exports.AppendToPropType,
        timeout: prop_types_1.number,
        style: prop_types_1.object,
        id: prop_types_1.string
    };
    return Popover;
}(React.Component));
exports.Popover = Popover;
//# sourceMappingURL=Popover.js.map