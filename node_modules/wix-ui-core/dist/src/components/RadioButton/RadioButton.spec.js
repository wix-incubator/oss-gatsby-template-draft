"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var RadioButton_driver_1 = require("./RadioButton.driver");
var dom_test_container_1 = require("../../../test/dom-test-container");
var RadioButton_1 = require("./RadioButton");
function createRadio(props) {
    if (props === void 0) { props = {}; }
    return (React.createElement(RadioButton_1.RadioButton, __assign({ label: React.createElement("span", null, "Horsie"), checkedIcon: React.createElement("span", null, "\uD83E\uDD84"), uncheckedIcon: React.createElement("span", null, "\uD83E\uDD84"), value: "horsie" }, props)));
}
describe('RadioButton', function () {
    var createDriver = new dom_test_container_1.ReactDOMTestContainer()
        .unmountAfterEachTest()
        .createLegacyRenderer(RadioButton_driver_1.radioButtonDriverFactory);
    it('renders to the screen', function () {
        var radio = createDriver(createRadio());
        expect(radio.exists()).toBeTruthy();
    });
    it('invokes callback for onChange with the correct value', function () {
        var onChange = jest.fn();
        var radio = createDriver(createRadio({ onChange: onChange }));
        expect(radio.isInputFocused()).toBeFalsy();
        radio.select();
        expect(onChange.mock.calls.length).toEqual(1);
        expect(onChange.mock.calls[0][0].value).toEqual('horsie');
        expect(radio.isInputFocused()).toBeTruthy();
    });
    it('is checked correctly', function () {
        var radio = createDriver(createRadio({ checked: true }));
        expect(radio.isChecked()).toBeTruthy();
    });
    it('is disabled correctly', function () {
        var radio = createDriver(createRadio({ disabled: true }));
        expect(radio.isDisabled()).toBeTruthy();
    });
    it('does not invoke callback function when disabled and clicked', function () {
        var onChange = jest.fn();
        var radio = createDriver(createRadio({ onChange: onChange, disabled: true }));
        radio.select();
        expect(onChange).not.toHaveBeenCalled();
    });
    it('is required correctly', function () {
        var radio = createDriver(createRadio({ required: true }));
        expect(radio.isRequired()).toBeTruthy();
    });
    it('accepts correct value', function () {
        var radio = createDriver(createRadio({ value: 'unicorn' }));
        expect(radio.value()).toEqual('unicorn');
    });
    it('accepts correct name', function () {
        var radio = createDriver(createRadio({ name: 'unicorns' }));
        expect(radio.name()).toEqual('unicorns');
    });
    it('renders label correctly', function () {
        var radio = createDriver(createRadio());
        expect(radio.labelExists()).toBeTruthy();
    });
    it('renders icon correctly', function () {
        var radio = createDriver(createRadio());
        expect(radio.iconExists()).toBeTruthy();
    });
    it('gets NON VISIBLE focus if clicked', function () {
        var radio = createDriver(createRadio());
        radio.click();
        expect(radio.isFocused()).toBeTruthy();
        expect(radio.isFocusVisible()).toBeFalsy();
    });
    it('gets VISIBLE focus if changed without clicking', function () {
        var radio = createDriver(createRadio());
        radio.select();
        expect(radio.isFocused()).toBeTruthy();
        expect(radio.isFocusVisible()).toBeTruthy();
    });
});
//# sourceMappingURL=RadioButton.spec.js.map