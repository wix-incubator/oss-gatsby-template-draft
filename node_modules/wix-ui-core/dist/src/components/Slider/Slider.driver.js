"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sliderDriverFactory = function (_a) {
    var element = _a.element, eventTrigger = _a.eventTrigger;
    function getByDataHook(hook) {
        return element.querySelector("[data-hook='" + hook + "']");
    }
    function getAllByDataHook(hook) {
        return element.querySelectorAll("[data-hook='" + hook + "']");
    }
    var driver = {
        /** Checks if element exists */
        exists: function () { return !!element; },
        /** Returns the current slider value */
        value: function () { return Number(element.getAttribute('data-value')); },
        /** Returns the minimum slider value */
        min: function () { return Number(element.getAttribute('data-min')); },
        /** Returns the maximum slider value */
        max: function () { return Number(element.getAttribute('data-max')); },
        /** Returns whether the slider is vertical or not */
        vertical: function () { return element.getAttribute('data-orientation') === 'vertical'; },
        /** Returns the thumb element */
        thumb: function () { return getByDataHook('thumb'); },
        /** Returns the tooltip element */
        tooltip: function () { return getByDataHook('tooltip'); },
        /** Returns the tick mark elements */
        ticks: function () { return getAllByDataHook('tick'); },
        /** Returns the track elements */
        track: function () { return getByDataHook('track'); },
        /** Returns whether the slider goes from right to left */
        rtl: function () { return element.getAttribute('data-dir') === 'rtl'; },
        /** Returns the root element */
        root: function () { return element; },
        role: function () { return element.getAttribute('role'); },
        ariaValueMin: function () { return element.getAttribute('aria-valuemin'); },
        ariaValueMax: function () { return element.getAttribute('aria-valuemax'); },
        ariaValueNow: function () { return element.getAttribute('aria-valuenow'); },
        mouseMove: function (value) {
            var mouseMove = new Event('mousemove');
            mouseMove[driver.vertical() ? 'clientY' : 'clientX'] = value;
            document.dispatchEvent(mouseMove);
        },
        mouseDown: function () {
            eventTrigger.mouseDown(element);
        },
        mouseUp: function () {
            var mouseUp = new Event('mouseup');
            document.dispatchEvent(mouseUp);
        },
        focus: function () {
            eventTrigger.focus(element);
        },
        blur: function () {
            eventTrigger.blur(element);
        },
        arrowLeft: function () {
            eventTrigger.keyDown(element, { key: 'ArrowLeft' });
        },
        arrowRight: function () {
            eventTrigger.keyDown(element, { key: 'ArrowRight' });
        },
        arrowUp: function () {
            eventTrigger.keyDown(element, { key: 'ArrowUp' });
        },
        arrowDown: function () {
            eventTrigger.keyDown(element, { key: 'ArrowDown' });
        },
        pageUp: function () {
            eventTrigger.keyDown(element, { key: 'PageUp' });
        },
        pageDown: function () {
            eventTrigger.keyDown(element, { key: 'PageDown' });
        },
        home: function () {
            eventTrigger.keyDown(element, { key: 'Home' });
        },
        end: function () {
            eventTrigger.keyDown(element, { key: 'End' });
        },
        stubTrackBoundingRect: function (rect) {
            rect = rect || (driver.vertical() ? {
                bottom: 400,
                top: 0,
                left: 0,
                right: 0,
                width: 50,
                height: 400
            } : {
                bottom: 0,
                top: 0,
                left: 0,
                right: 0,
                width: 400,
                height: 50
            });
            var el = driver.track();
            el.getBoundingClientRect = function () { return rect; };
            driver.forceUpdate();
        },
        stubRootBoundingRect: function (rect) {
            rect = rect || (driver.vertical() ? {
                bottom: 400,
                top: 0,
                left: 0,
                right: 100,
                width: 100,
                height: 400
            } : {
                bottom: 0,
                top: 0,
                left: 0,
                right: 0,
                width: 400,
                height: 100
            });
            var el = driver.root();
            el.getBoundingClientRect = function () { return rect; };
            driver.forceUpdate();
        },
        getTrackBoundingRect: function () {
            return driver.track().getBoundingClientRect();
        },
        getRootBoundingRect: function () {
            return driver.root().getBoundingClientRect();
        },
        getThumbSize: function () {
            return driver.root().getBoundingClientRect().height;
        },
        getOffsetByValue: function (value) {
            var rect = driver.getTrackBoundingRect();
            var min = driver.min();
            var max = driver.max();
            if (!driver.vertical()) {
                var thumbSize = driver.getRootBoundingRect().height;
                var offset = (value - min) * ((rect.width + thumbSize / 2) / (max - min + 1));
                if (driver.rtl()) {
                    return rect.width - offset;
                }
                else {
                    return offset;
                }
            }
            else {
                var thumbSize = driver.getRootBoundingRect().width;
                var offset = (value - min) * ((rect.height + thumbSize / 2) / (max - min + 1));
                return offset;
            }
        },
        change: function (value) {
            driver.mouseDown();
            driver.mouseMove(driver.getOffsetByValue(value));
            driver.mouseUp();
        },
        hoverThumb: function () {
            eventTrigger.mouseEnter(driver.thumb());
        },
        unhoverThumb: function () {
            eventTrigger.mouseLeave(driver.thumb());
        },
        dragThumb: function (offset) {
            driver.hoverThumb();
            driver.mouseDown();
            driver.mouseMove(offset);
        },
        thumbTooltipValue: function () {
            var tooltip = driver.tooltip();
            return tooltip && tooltip.textContent;
        },
        clickTick: function (tickIdx) {
            var tick = driver.ticks()[tickIdx];
            var offset = driver.getOffsetByValue(driver.min() + tickIdx);
            eventTrigger.click(tick, (_a = {}, _a[driver.vertical() ? 'clientY' : 'clientX'] = offset, _a));
            var _a;
        },
        clickSlider: function (value) {
            var offset = driver.getOffsetByValue(value);
            eventTrigger.click(driver.track(), (_a = {}, _a[driver.vertical() ? 'clientY' : 'clientX'] = offset, _a));
            var _a;
        },
        forceUpdate: function () {
            driver.hoverThumb();
            driver.unhoverThumb();
        }
    };
    return driver;
};
//# sourceMappingURL=Slider.driver.js.map