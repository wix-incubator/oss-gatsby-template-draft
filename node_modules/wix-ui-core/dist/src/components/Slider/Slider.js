"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var prop_types_1 = require("prop-types");
var Ticks_1 = require("./Ticks");
var Thumb_1 = require("./Thumb");
var Slider_st_css_1 = require("./Slider.st.css");
var omit = require('lodash/omit');
var noop = require('lodash/noop');
var CONTINUOUS_STEP = 0.01;
var Slider = /** @class */ (function (_super) {
    __extends(Slider, _super);
    function Slider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            dragging: false,
            mouseDown: false,
            thumbHover: false,
            inKeyPress: false,
        };
        _this.setTrackNode = function (track) {
            _this.track = track;
        };
        _this.handleBlur = function () {
            _this.setState({ inKeyPress: false });
            _this.props.onBlur();
        };
        _this.handleMouseDown = function () {
            _this.setState({ mouseDown: true });
        };
        _this.handleMouseUp = function () {
            _this.setState({ mouseDown: false, dragging: false });
        };
        _this.handleKeyDown = function (ev) {
            var _a = _this.props, min = _a.min, max = _a.max, value = _a.value, disabled = _a.disabled, readOnly = _a.readOnly, dir = _a.dir;
            var ltr = dir === 'ltr';
            if (disabled || readOnly) {
                return;
            }
            var step = _this.getStepValue();
            var nextValue;
            switch (ev.key) {
                case 'ArrowDown':
                    nextValue = value - step;
                    break;
                case 'ArrowLeft':
                    if (ltr) {
                        nextValue = value - step;
                    }
                    else {
                        nextValue = value + step;
                    }
                    break;
                case 'ArrowUp':
                    nextValue = value + step;
                    break;
                case 'ArrowRight':
                    if (ltr) {
                        nextValue = value + step;
                    }
                    else {
                        nextValue = value - step;
                    }
                    break;
                case 'PageDown':
                    nextValue = value - 0.1 * (max - min);
                    break;
                case 'PageUp':
                    nextValue = value + 0.1 * (max - min);
                    break;
                case 'Home':
                    nextValue = min;
                    break;
                case 'End':
                    nextValue = max;
                    break;
                default:
                    nextValue = undefined;
            }
            if (typeof nextValue !== 'undefined') {
                _this.handleChange(nextValue);
                _this.setState({
                    inKeyPress: true
                });
                ev.preventDefault();
            }
        };
        _this.handleMouseMove = function (ev) {
            if (_this.state.mouseDown && !_this.state.dragging) {
                _this.setState({ dragging: true });
            }
            if (_this.state.dragging) {
                _this.moveThumbByMouse(ev);
            }
        };
        _this.handleThumbEnter = function () {
            _this.setState({ thumbHover: true });
        };
        _this.handleThumbLeave = function () {
            _this.setState({ thumbHover: false });
        };
        _this.moveThumbByMouse = function (ev) {
            if (ev.touches) {
                ev.preventDefault();
                ev = ev.touches[0];
            }
            var _a = _this.props, min = _a.min, max = _a.max, disabled = _a.disabled, readOnly = _a.readOnly, dir = _a.dir;
            var rtl = _this.isRtl();
            if (disabled || readOnly) {
                return;
            }
            var isVertical = _this.isVertical();
            var step = _this.getStepValue();
            var thumbSize = _this.getThumbSizeMainAxis();
            var totalSteps = Math.ceil((max - min) / step);
            var rect = _this.track.getBoundingClientRect();
            var value, pxStep, sliderPos;
            if (isVertical) {
                sliderPos = rect.bottom - (ev.clientY + thumbSize / 2);
                pxStep = (rect.height - thumbSize) / totalSteps;
            }
            else {
                if (rtl) {
                    sliderPos = (rect.left + rect.width - thumbSize / 2) - ev.clientX;
                }
                else {
                    sliderPos = ev.clientX - (rect.left + thumbSize / 2);
                }
                pxStep = (rect.width - thumbSize) / totalSteps;
            }
            value = min + step * Math.round(sliderPos / pxStep);
            _this.handleChange(value);
        };
        return _this;
    }
    Slider.prototype.componentDidMount = function () {
        document.addEventListener('mouseup', this.handleMouseUp);
        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('touchend', this.handleMouseUp);
        document.addEventListener('touchmove', this.handleMouseMove, { passive: false });
    };
    Slider.prototype.componentWillUnmount = function () {
        document.removeEventListener('mouseup', this.handleMouseUp);
        document.removeEventListener('mousemove', this.handleMouseMove);
        document.removeEventListener('touchend', this.handleMouseUp);
        document.removeEventListener('touchmove', this.handleMouseMove);
    };
    Slider.prototype.focus = function () {
        this.root.focus();
        this.props.onFocus();
    };
    Slider.prototype.blur = function () {
        this.root.blur();
        this.props.onBlur();
    };
    Slider.prototype.getStartPos = function () {
        return this.props.dir === 'rtl' ? 'right' : 'left';
    };
    Slider.prototype.calcDiscreteStepValue = function (min, max, step, stepType) {
        if (stepType === 'count') {
            return (max - min) / step;
        }
        return step;
    };
    Slider.prototype.getStepValue = function () {
        var _a = this.props, min = _a.min, max = _a.max, step = _a.step, stepType = _a.stepType;
        if (step > 0) {
            return this.calcDiscreteStepValue(min, max, step, stepType);
        }
        return CONTINUOUS_STEP;
    };
    Slider.prototype.isShallowEqual = function (v, o) {
        for (var key in v) {
            if (!(key in o) || v[key] !== o[key]) {
                return false;
            }
        }
        for (var key in o) {
            if (!(key in v) || v[key] !== o[key]) {
                return false;
            }
        }
        return true;
    };
    Slider.prototype.getSliderSize = function () {
        var _a = this.props.style, width = _a.width, height = _a.height;
        var isVertical = this.isVertical();
        var val = isVertical ? width : height;
        return Math.min(val, Math.min(width, height));
    };
    Slider.prototype.getSliderLength = function () {
        return this.isVertical() ? this.props.style.height : this.props.style.width;
    };
    Slider.prototype.getThumbSize = function () {
        var size = Thumb_1.getThumbSize(this.props.thumbShape, this.getSliderSize(), this.isVertical());
        var offsets = this.getInnerOffsets();
        var offset = offsets.offsetHeight || offsets.offsetWidth || 0;
        return {
            width: size.width - offset,
            height: size.height - offset
        };
    };
    Slider.prototype.getThumbSizeMainAxis = function () {
        var size = this.getThumbSize();
        return this.isVertical() ? size.height : size.width;
    };
    Slider.prototype.getThumbSizeCrossAxis = function () {
        var size = this.getThumbSize();
        return this.isVertical() ? size.width : size.height;
    };
    Slider.prototype.handleChange = function (value) {
        value = this.floorValue(this.clamp(value, this.props.min, this.props.max), 2);
        if (value !== this.props.value) {
            this.props.onChange(value);
        }
    };
    Slider.prototype.clamp = function (val, min, max) {
        return Math.min(Math.max(val, min), max);
    };
    Slider.prototype.isRtl = function () {
        return this.props.dir === 'rtl';
    };
    Slider.prototype.isVertical = function () {
        return this.props.orientation === 'vertical';
    };
    Slider.prototype.isContinuous = function () {
        return !this.props.step;
    };
    Slider.prototype.shouldShowTooltip = function () {
        switch (this.props.tooltipVisibility) {
            case 'always':
                return true;
            case 'none':
                return false;
            default:
            case 'hover':
                return this.state.dragging || this.state.thumbHover || this.state.inKeyPress;
        }
    };
    Slider.prototype.calcThumbProgressPosition = function () {
        var thumbSize = this.getThumbSizeMainAxis();
        var _a = this.props, value = _a.value, min = _a.min, max = _a.max;
        var pct = (value - min) / (max - min);
        var clampedPct = this.clamp(pct, 0, 1);
        return "calc(" + clampedPct + " *(100% - " + thumbSize + "px))";
    };
    Slider.prototype.calcTrackFillPosition = function () {
        var thumbSize = this.getThumbSizeMainAxis();
        var _a = this.props, value = _a.value, min = _a.min, max = _a.max;
        var pct = (value - min) / (max - min);
        var clampedPct = this.clamp(pct, 0, 1);
        return "calc(" + clampedPct + " *(100% - " + thumbSize + "px) + " + thumbSize + "px - 2px)";
    };
    Slider.prototype.calcThumbCrossPosition = function () {
        var thumbSize = this.getThumbSizeCrossAxis();
        return "calc(50% - " + thumbSize / 2 + "px)";
    };
    Slider.prototype.calcThumbPosition = function () {
        var progressVal = this.calcThumbProgressPosition();
        var crossVal = this.calcThumbCrossPosition();
        if (this.isVertical()) {
            return { bottom: progressVal, left: 0 };
        }
        return _a = {}, _a[this.getStartPos()] = progressVal, _a.top = 0, _a;
        var _a;
    };
    Slider.prototype.floorValue = function (value, precision) {
        if (precision === void 0) { precision = 1; }
        var clampedValue = Math.floor(Math.pow(10, precision) * value) / Math.pow(10, precision);
        return clampedValue;
    };
    Slider.prototype.renderTooltip = function () {
        if (!this.shouldShowTooltip()) {
            return null;
        }
        var tooltipPosition = this.props.tooltipPosition;
        var positionClassname = tooltipPosition + 'Position';
        var clampedValue = this.floorValue(this.props.value);
        return (React.createElement("div", __assign({ "data-hook": "tooltip" }, Slider_st_css_1.default('tooltip', (_a = {}, _a[positionClassname] = true, _a))),
            this.props.tooltipPrefix,
            clampedValue,
            this.props.tooltipSuffix));
        var _a;
    };
    Slider.prototype.ticksShown = function () {
        return !this.isContinuous() && this.props.tickMarksShape !== 'none';
    };
    Slider.prototype.getInnerOffsets = function () {
        var showTicks = this.ticksShown();
        if (!showTicks) {
            return {};
        }
        var isHorizontal = !this.isVertical();
        var tickSize = this.props.tickMarksShape === 'line' ? 10 : 3;
        var tickMarksPos = this.props.tickMarksPosition;
        var tickMarksGap = 12;
        var offsetWidth, offsetHeight, offsetLeft, offsetTop;
        if (tickMarksPos === 'normal') {
            offsetHeight = tickSize + tickMarksGap;
        }
        else if (tickMarksPos === 'across') {
            offsetTop = tickSize + tickMarksGap;
            offsetHeight = tickSize + tickMarksGap;
        }
        if (isHorizontal) {
            return { offsetHeight: offsetHeight, offsetTop: offsetTop };
        }
        else {
            return { offsetWidth: offsetHeight, offsetLeft: offsetTop };
        }
    };
    Slider.prototype.getInnerDims = function () {
        var offsets = this.getInnerOffsets();
        var style = {};
        if (offsets.offsetTop) {
            style.top = offsets.offsetTop;
        }
        if (offsets.offsetLeft) {
            style.left = offsets.offsetLeft;
        }
        if (offsets.offsetHeight) {
            style.height = "calc(100% - " + offsets.offsetHeight + "px)";
        }
        if (offsets.offsetWidth) {
            style.width = "calc(100% - " + offsets.offsetWidth + "px)";
        }
        return style;
    };
    Slider.prototype.render = function () {
        var _this = this;
        var _a = this.props, value = _a.value, min = _a.min, max = _a.max, trackSize = _a.trackSize, disabled = _a.disabled, dir = _a.dir, onFocus = _a.onFocus, tickMarksPosition = _a.tickMarksPosition, tickMarksShape = _a.tickMarksShape, thumbShape = _a.thumbShape, orientation = _a.orientation, style = _a.style;
        var vertical = this.isVertical();
        var thumbSize = this.getThumbSize();
        var crossThumbSize = this.getThumbSizeCrossAxis();
        var mainThumbSize = this.getThumbSizeMainAxis();
        var showTicks = this.ticksShown();
        var step = this.getStepValue();
        var thumbPosition = this.calcThumbPosition();
        var trackStyle = vertical ? { width: trackSize + '%' } : { height: trackSize + '%' };
        var trackFillPosition = vertical ? {
            bottom: 0,
            height: this.calcTrackFillPosition()
        } : {
            width: this.calcTrackFillPosition()
        };
        return (React.createElement("div", __assign({}, Slider_st_css_1.default('root', {
            orientation: vertical ? 'vertical' : 'horizontal',
            dir: dir,
            tickMarksPosition: tickMarksPosition,
            tickMarksShape: tickMarksShape,
            disabled: disabled,
        }, this.props), { onMouseDown: this.handleMouseDown, onTouchStart: this.handleMouseDown, onKeyDown: this.handleKeyDown, onFocus: onFocus, onBlur: this.handleBlur, "data-value": value, "data-min": min, "data-max": max, "data-orientation": orientation, "data-dir": dir, tabIndex: 0, style: style, ref: function (root) { return _this.root = root; }, role: "slider", "aria-valuemin": min, "aria-valuemax": max, "aria-valuenow": value }),
            React.createElement("div", { className: Slider_st_css_1.default.inner, style: this.getInnerDims() },
                React.createElement("div", { "data-hook": "track", ref: this.setTrackNode, className: Slider_st_css_1.default.track, onClick: this.moveThumbByMouse, style: trackStyle },
                    React.createElement("div", { className: Slider_st_css_1.default.trackFill, style: trackFillPosition })),
                React.createElement(Thumb_1.Thumb, { shape: thumbShape, thumbPosition: thumbPosition, thumbSize: thumbSize, onMouseEnter: this.handleThumbEnter, onMouseLeave: this.handleThumbLeave }, this.renderTooltip())),
            showTicks && (React.createElement(Ticks_1.Ticks, { pStyle: Slider_st_css_1.default, step: step, min: min, max: max, thumbSize: mainThumbSize, vertical: vertical, trackSize: vertical ? this.props.style.height - mainThumbSize : this.props.style.width - crossThumbSize, tickMarksShape: tickMarksShape, onTickClick: this.moveThumbByMouse }))));
    };
    Slider.displayName = 'Slider';
    Slider.propTypes = {
        /** The minimum value of the slider */
        min: prop_types_1.number,
        /** The maximum value of the slider */
        max: prop_types_1.number,
        /** The current value of the slider */
        value: prop_types_1.number,
        /** Callback for handling value changes */
        onChange: prop_types_1.func,
        /** Callback for handling focus events */
        onFocus: prop_types_1.func,
        /** Callback for handling blur events */
        onBlur: prop_types_1.func,
        /** Whether the slider has a horizontal or a vertical layout */
        orientation: prop_types_1.oneOf(['horizontal', 'vertical']),
        /** If stepType = 'value', 'step' determines the value of each slider step. If stepType = 'count', 'step' determines the total number of jumps */
        step: prop_types_1.number,
        /** If stepType = 'value', 'step' determines the value of each slider step. If stepType = 'count', 'step' determines the total number of jumps */
        stepType: prop_types_1.oneOf(['value', 'count']),
        /** Determines the tooltip position */
        tooltipPosition: prop_types_1.oneOf(['normal', 'across']),
        /** Determines what triggers the tooltip pop */
        tooltipVisibility: prop_types_1.oneOf(['none', 'always', 'hover']),
        /** Determines the tick marks position */
        tickMarksPosition: prop_types_1.oneOf(['normal', 'middle', 'across']),
        /** A prefix for the value inside the tooltip */
        tooltipPrefix: prop_types_1.string,
        /** A suffix for the value inside the tooltip */
        tooltipSuffix: prop_types_1.string,
        /** The track size as a percentage of the bounding box height */
        trackSize: prop_types_1.number,
        /** The shape of the thumb */
        thumbShape: prop_types_1.oneOf(['circle', 'square', 'rectangle', 'bar']),
        /** The shape of the tick marks */
        tickMarksShape: prop_types_1.oneOf(['none', 'line', 'dot']),
        /** Determines whether the slider is disabled or not */
        disabled: prop_types_1.bool,
        /** Determines whether the slider is in read-only mode or not (disabled is temporary, readOnly is permanent) */
        readOnly: prop_types_1.bool,
        /** Determines whether values go from right to left in a horizontal position */
        dir: prop_types_1.oneOf(['rtl', 'ltr']),
        /** Sets the width and height of the slider */
        style: prop_types_1.object.isRequired
    };
    Slider.defaultProps = {
        min: 0,
        max: 10,
        value: 5,
        stepType: 'value',
        thumbShape: 'circle',
        orientation: 'horizontal',
        disabled: false,
        readOnly: false,
        tooltipVisibility: 'hover',
        tooltipPosition: 'normal',
        tooltipPrefix: '',
        tooltipSuffix: '',
        tickMarksPosition: 'normal',
        tickMarksShape: 'line',
        dir: 'ltr',
        onFocus: noop,
        onBlur: noop,
        style: {
            width: 0,
            height: 0
        }
    };
    return Slider;
}(React.PureComponent));
exports.Slider = Slider;
//# sourceMappingURL=Slider.js.map