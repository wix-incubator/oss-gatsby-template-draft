"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var Slider_driver_1 = require("./Slider.driver");
var dom_test_container_1 = require("../../../test/dom-test-container");
var index_1 = require("./index");
var sinon = require("sinon");
var enzyme_1 = require("enzyme");
describe('Slider', function () {
    var container = new dom_test_container_1.ReactDOMTestContainer().unmountAfterEachTest();
    var createDriver = container.createLegacyRenderer(Slider_driver_1.sliderDriverFactory);
    var noop = function () { return null; };
    it('should exist', function () {
        var driver = createDriver(React.createElement(index_1.Slider, null));
        expect(driver.exists()).toBe(true);
    });
    it('should render props', function () {
        var driver = render({
            orientation: 'vertical',
            min: 4,
            max: 20,
            value: 7,
            onChange: noop
        });
        expect(driver.value()).toBe(7);
        expect(driver.min()).toBe(4);
        expect(driver.max()).toBe(20);
        expect(driver.vertical()).toBe(true);
    });
    it('should trigger onChange', function () {
        var onChange = sinon.spy();
        var driver = render({ onChange: onChange });
        driver.change();
        sinon.assert.called(onChange);
    });
    it('should change to a specific value', function () {
        var onChange = sinon.spy();
        var driver = render({ onChange: onChange, step: 1 });
        driver.change(5);
        sinon.assert.calledWith(onChange, 5);
    });
    it('should show tooltip upon thumb hover', function () {
        var driver = render({ value: 3 });
        driver.hoverThumb();
        expect(driver.thumbTooltipValue()).toEqual('3');
    });
    it('should not show tooltip if thumb is not hovered or dragged', function () {
        var driver = render();
        expect(driver.tooltip()).toEqual(null);
    });
    it('should show tooltip when dragging', function () {
        var driver = render({ value: 3 });
        driver.dragThumb(1);
        expect(driver.thumbTooltipValue()).toEqual('3');
    });
    it('should show tooltip when pressing keys', function () {
        var driver = render({ value: 3 });
        driver.arrowRight();
        expect(driver.thumbTooltipValue()).toEqual('3');
    });
    it('should hide the tooltip upon blur, given key pressed', function () {
        var driver = render({ value: 3 });
        driver.arrowRight();
        driver.blur();
        expect(driver.thumbTooltipValue()).toBeFalsy();
    });
    it('does not show tooltip, given tooltipVisibility=none', function () {
        var driver = render({ tooltipVisibility: 'none' });
        driver.hoverThumb();
        expect(driver.tooltip()).not.toBeTruthy();
    });
    it('shows tooltip only on hover, given tooltipVisibility=hover', function () {
        var driver = render({ tooltipVisibility: 'hover' });
        expect(driver.tooltip()).toBeFalsy();
        driver.hoverThumb();
        expect(driver.tooltip()).toBeTruthy();
    });
    it('shows tooltip by normal, given tooltipVisibility=always', function () {
        var driver = render({ tooltipVisibility: 'always' });
        expect(driver.tooltip()).toBeTruthy();
    });
    it('should render tooltip prefix', function () {
        var onChange = sinon.spy();
        var driver = render({
            tooltipPrefix: '$'
        });
        driver.hoverThumb();
        expect(driver.thumbTooltipValue()).toBe('$0');
    });
    it('should render tooltip suffix', function () {
        var onChange = sinon.spy();
        var driver = render({
            tooltipSuffix: '$'
        });
        driver.hoverThumb();
        expect(driver.thumbTooltipValue()).toBe('0$');
    });
    it('should render ticks', function () {
        var driver = render({
            min: 1,
            step: 1,
            max: 10,
            value: 3,
            style: {
                width: 500,
                height: 40
            }
        });
        expect(driver.ticks().length).toEqual(10);
    });
    it('should render the max tick, given max % step !== 0', function () {
        var driver = render({
            min: 1,
            step: 5,
            max: 20,
            value: 3,
            style: {
                width: 500,
                height: 40
            }
        });
        expect(driver.ticks().length).toEqual(5);
    });
    it('should not render the ticks, given tickMarksShape = none', function () {
        var driver = render({
            min: 1,
            step: 5,
            max: 20,
            value: 3,
            tickMarksShape: 'none'
        });
        driver.stubTrackBoundingRect({ width: 500 });
        expect(driver.ticks().length).toEqual(0);
    });
    it('should not render the ticks, given tickMarksShape = none', function () {
        var driver = render({
            min: 1,
            step: 5,
            max: 20,
            value: 3,
            tickMarksShape: 'none'
        });
        driver.stubTrackBoundingRect({ width: 500 });
        expect(driver.ticks().length).toEqual(0);
    });
    it('should not render the ticks, given a continuous slider', function () {
        var driver = render({
            min: 1,
            step: undefined,
            max: 20,
            value: 3
        });
        driver.stubTrackBoundingRect({ width: 500 });
        expect(driver.ticks().length).toEqual(0);
    });
    it('should change the value when clicking a tick', function () {
        var onChange = sinon.spy();
        var driver = render({
            step: 1,
            min: 1,
            max: 10,
            value: 3,
            style: {
                width: 100,
                height: 20
            },
            onChange: onChange
        });
        driver.clickTick(5);
        sinon.assert.calledWith(onChange, 6);
    });
    it('should change the value when clicking the slider', function () {
        var onChange = sinon.spy();
        var driver = render({
            step: 1,
            onChange: onChange
        });
        driver.clickSlider(3);
        sinon.assert.calledWith(onChange, 3);
    });
    it('should change the value when clicking the slider, given vertical orientation', function () {
        var onChange = sinon.spy();
        var driver = render({
            step: 1,
            orientation: 'vertical',
            onChange: onChange
        });
        driver.clickSlider(3);
        sinon.assert.calledWith(onChange, 3);
    });
    it('should change the value when clicking the slider, given rtl', function () {
        var onChange = sinon.spy();
        var driver = render({
            dir: 'rtl',
            step: 1,
            onChange: onChange
        });
        driver.clickSlider(3);
        sinon.assert.calledWith(onChange, 3);
    });
    describe('key presses', function () {
        var onChange, driver;
        function _render(mixin) {
            if (mixin === void 0) { mixin = {}; }
            onChange = sinon.spy();
            driver = render(__assign({ step: 0.1, min: 50, max: 100, value: 60, onChange: onChange }, mixin));
            driver.focus();
        }
        it('should increase the value when clicking the right arrow, given ltr', function () {
            _render();
            driver.arrowRight();
            sinon.assert.calledWith(onChange, 60.1);
        });
        it('should decrease the value when clicking the right arrow, given rtl', function () {
            _render({ dir: 'rtl' });
            driver.arrowRight();
            sinon.assert.calledWith(onChange, 59.9);
        });
        it('should increase the value when clicking the up arrow', function () {
            _render();
            driver.arrowRight();
            sinon.assert.calledWith(onChange, 60.1);
        });
        it('should decrease the value when clicking the left arrow, given ltr', function () {
            _render();
            driver.arrowLeft();
            sinon.assert.calledWith(onChange, 59.9);
        });
        it('should increase the value when clicking the left arrow, given rtl', function () {
            _render({ dir: 'rtl' });
            driver.arrowLeft();
            sinon.assert.calledWith(onChange, 60.1);
        });
        it('should decrease the value when clicking the down arrow', function () {
            _render();
            driver.arrowDown();
            sinon.assert.calledWith(onChange, 59.9);
        });
        it('should increase the value by 0.1 * (max - min) when clicking Page Up', function () {
            _render();
            driver.pageUp();
            sinon.assert.calledWith(onChange, 65);
        });
        it('should decrease the value by 0.1 * (max - min) when clicking Page Down', function () {
            _render();
            driver.pageDown();
            sinon.assert.calledWith(onChange, 55);
        });
        it('should set the value to maximum when clicking End', function () {
            _render();
            driver.end();
            sinon.assert.calledWith(onChange, 100);
        });
        it('should set the value to minimum when clicking Home', function () {
            _render();
            driver.home();
            sinon.assert.calledWith(onChange, 50);
        });
        it('should not decrease below the minimum', function () {
            onChange = sinon.spy();
            driver = render({
                step: 0.1,
                min: 1,
                max: 10,
                value: 1,
                onChange: onChange
            });
            driver.focus();
            driver.arrowLeft();
            sinon.assert.notCalled(onChange);
        });
        it('should not increase above the maximum', function () {
            onChange = sinon.spy();
            driver = render({
                step: 0.1,
                min: 1,
                max: 10,
                value: 10,
                onChange: onChange
            });
            driver.focus();
            driver.arrowRight();
            sinon.assert.notCalled(onChange);
        });
    });
    it('cannot move thumb, given disabled', function () {
        var onChange = sinon.spy();
        var driver = render({
            disabled: true,
            onChange: onChange
        });
        driver.focus();
        driver.arrowRight();
        driver.clickSlider(3);
        sinon.assert.notCalled(onChange);
    });
    it('cannot move thumb, given readonly', function () {
        var onChange = sinon.spy();
        var driver = render({
            readOnly: true,
            onChange: onChange
        });
        driver.focus();
        driver.arrowRight();
        driver.clickSlider(3);
        sinon.assert.notCalled(onChange);
    });
    it('should have 3 steps, given stepType = \'count\' and step = 3', function () {
        var onChange = sinon.spy();
        var driver = render({
            min: 0,
            max: 6,
            value: 0,
            step: 3,
            stepType: 'count',
            onChange: onChange
        });
        driver.focus();
        driver.arrowRight();
        sinon.assert.calledWith(onChange, 2);
    });
    it('continuous mode - step is 0.01', function () {
        var onChange = sinon.spy();
        var driver = render({
            min: 1,
            max: 6,
            value: 1,
            step: null,
            onChange: onChange
        });
        driver.stubTrackBoundingRect({ width: 500 });
        driver.focus();
        driver.arrowRight();
        sinon.assert.calledWith(onChange, 1.01);
    });
    it('onChange value is clamped by 2 decimal points', function () {
        var onChange = sinon.spy();
        var driver = render({
            min: 1,
            max: 6,
            value: 1,
            step: 0.123456,
            onChange: onChange
        });
        driver.focus();
        driver.arrowRight();
        sinon.assert.calledWith(onChange, 1.12);
    });
    it('tooltip numeric value precision should be clamped to 3 decimal places', function () {
        var onChange = sinon.spy();
        var driver = render({
            min: 1000,
            max: 1300,
            value: 1200.444,
            step: null,
            tooltipPrefix: '$',
            tooltipSuffix: '%',
            onChange: onChange
        });
        driver.hoverThumb();
        expect(driver.thumbTooltipValue()).toEqual('$1200.4%');
    });
    it('should propagate onFocus when slider is focused', function () {
        var onFocus = sinon.spy();
        var driver = render({
            onFocus: onFocus
        });
        driver.focus();
        sinon.assert.called(onFocus);
    });
    it('should focus', function () {
        var onFocus = sinon.spy();
        var wrapper = enzyme_1.mount(React.createElement(index_1.Slider, { onFocus: onFocus }), {
            attachTo: container.node
        });
        wrapper.instance().focus();
        expect(document.activeElement).toEqual(wrapper.getDOMNode());
        sinon.assert.called(onFocus);
        wrapper.unmount();
    });
    it('should blur', function () {
        var onBlur = sinon.spy();
        var wrapper = enzyme_1.mount(React.createElement(index_1.Slider, { onBlur: onBlur }), {
            attachTo: container.node
        });
        wrapper.instance().focus();
        wrapper.instance().blur();
        expect(document.activeElement).not.toEqual(wrapper.getDOMNode());
        sinon.assert.called(onBlur);
        wrapper.unmount();
    });
    it('should propagate onBlur when slider is blurred', function () {
        var onFocus = sinon.spy();
        var onBlur = sinon.spy();
        var driver = render({
            onFocus: onFocus,
            onBlur: onBlur
        });
        driver.focus();
        driver.blur();
        sinon.assert.called(onBlur);
    });
    describe('a11y', function () {
        it('should have a slider role', function () {
            var driver = render();
            expect(driver.role()).toEqual('slider');
        });
        it('should have an aria-valuemin attribute', function () {
            var driver = render();
            expect(driver.ariaValueMin()).toEqual(driver.min().toString());
        });
        it('should have an aria-valuemax attribute', function () {
            var driver = render();
            expect(driver.ariaValueMax()).toEqual(driver.max().toString());
        });
        it('should have an aria-valuenow attribute', function () {
            var driver = render();
            expect(driver.ariaValueNow()).toEqual(driver.value().toString());
        });
    });
    function floorValue(value, precision) {
        if (precision === void 0) { precision = 1; }
        return Math.floor(Math.pow(10, precision) * value) / Math.pow(10, precision);
    }
    function render(props) {
        if (props === void 0) { props = {}; }
        props = __assign({ min: 0, max: 6, value: 0, step: null, onChange: noop }, props);
        var driver = createDriver(React.createElement(index_1.Slider, __assign({}, props)));
        driver.stubRootBoundingRect();
        driver.stubTrackBoundingRect();
        return driver;
    }
});
//# sourceMappingURL=Slider.spec.js.map