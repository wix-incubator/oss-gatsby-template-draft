"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var prop_types_1 = require("prop-types");
var playable_1 = require("playable");
var Video_st_css_1 = require("./Video.st.css");
var noop = function () { return null; };
var mapPropsToMethods = {
    src: 'setSrc',
    width: 'setWidth',
    height: 'setHeight',
    title: 'setTitle',
    fillAllSpace: 'setFillAllSpace',
    loop: 'setLoop',
    logoUrl: 'setLogo',
    alwaysShowLogo: 'setLogoAlwaysShowFlag',
    onLogoClick: 'setLogoClickCallback',
    volume: 'setVolume',
    controls: function (instance, player, isShow) {
        // TODO: replace it after playable API update
        if (isShow) {
            player.showPlayControl();
            player.showVolumeControl();
            player.showTimeControl();
            player.showFullScreenControl();
            player.showProgressControl();
        }
        else {
            player.hidePlayControl();
            player.hideVolumeControl();
            player.hideTimeControl();
            player.hideFullScreenControl();
            player.hideProgressControl();
        }
    },
    preload: 'setPreload',
    playing: function (instance, player, nextPlaying) {
        if (!instance.props.playing && nextPlaying && !instance._isPlaying()) {
            player.play();
        }
        if (instance.props.playing && !nextPlaying && instance._isPlaying()) {
            player.pause();
        }
    },
    muted: function (instance, player, nextMuted) {
        if (!instance.props.muted && nextMuted && !player.getMute()) {
            player.setMute(true);
        }
        if (instance.props.muted && !nextMuted && player.getMute()) {
            player.setMute(false);
        }
    }
};
var Video = /** @class */ (function (_super) {
    __extends(Video, _super);
    function Video() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { hasBeenPlayed: false };
        _this._play = function () {
            _this.player.play();
        };
        return _this;
    }
    Video.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, src = _a.src, playing = _a.playing, muted = _a.muted, width = _a.width, height = _a.height, title = _a.title, fillAllSpace = _a.fillAllSpace, loop = _a.loop, volume = _a.volume, controls = _a.controls, preload = _a.preload, logoUrl = _a.logoUrl, onLogoClick = _a.onLogoClick, alwaysShowLogo = _a.alwaysShowLogo, playableRef = _a.playableRef, onPlay = _a.onPlay, onPause = _a.onPause, onEnd = _a.onEnd;
        var logo;
        if (logoUrl || onLogoClick || alwaysShowLogo) {
            logo = {
                src: logoUrl,
                callback: onLogoClick,
                showAlways: alwaysShowLogo,
            };
        }
        this.player = playable_1.create({
            src: src,
            autoPlay: !!playing,
            muted: muted,
            size: {
                width: width,
                height: height,
            },
            title: {
                text: title,
            },
            controls: controls,
            preload: preload,
            logo: logo,
            fillAllSpace: fillAllSpace,
            loop: loop,
            volume: volume,
            overlay: false
        });
        playableRef(this.player);
        this.player.attachToElement(this.containerRef);
        this.player.on(playable_1.VIDEO_EVENTS.PLAY_REQUEST_TRIGGERED, function () {
            _this.setState({ hasBeenPlayed: true });
        });
        this.player.on(playable_1.ENGINE_STATES.PLAYING, function () {
            _this.setState({ hasBeenPlayed: true });
            onPlay();
        });
        this.player.on(playable_1.ENGINE_STATES.PAUSED, function () {
            onPause();
        });
        this.player.on(playable_1.ENGINE_STATES.ENDED, function () {
            _this.setState({ hasBeenPlayed: false });
            onEnd();
        });
        this.player.on(playable_1.ENGINE_STATES.SRC_SET, function () {
            _this.setState({ hasBeenPlayed: false });
        });
        this.player.on(playable_1.VIDEO_EVENTS.RESET, function () {
            _this.setState({ hasBeenPlayed: false });
        });
    };
    Video.prototype.componentWillReceiveProps = function (nextProps) {
        var currentProps = this.props;
        for (var propKey in nextProps) {
            var method = mapPropsToMethods[propKey];
            var isPropChanged = nextProps[propKey] !== currentProps[propKey];
            if (method && isPropChanged) {
                if (typeof method === 'string') {
                    this.player[method](nextProps[propKey]);
                }
                else {
                    method(this, this.player, nextProps[propKey]);
                }
            }
        }
    };
    Video.prototype.componentWillUnmount = function () {
        this.player.destroy();
    };
    Video.prototype._isPlaying = function () {
        return this.player.getCurrentPlaybackState() === playable_1.ENGINE_STATES.PLAYING;
    };
    Video.prototype.render = function () {
        var _this = this;
        var _a = this.props, id = _a.id, title = _a.title, poster = _a.poster, playButton = _a.playButton;
        var coverStyles = {
            backgroundImage: poster ? "url(" + poster + ")" : 'none'
        };
        var _b = this.props, width = _b.width, height = _b.height;
        if (this.props.fillAllSpace) {
            width = '100%';
            height = '100%';
        }
        return (React.createElement("div", __assign({ id: id, style: { width: width, height: height } }, Video_st_css_1.default('root', {}, this.props)),
            React.createElement("div", { ref: function (el) { return _this.containerRef = el; }, style: { width: width, height: height }, className: Video_st_css_1.default.playerContainer }),
            !this.state.hasBeenPlayed && poster && (React.createElement("div", { className: Video_st_css_1.default.cover, style: coverStyles, onClick: this._play, "data-hook": "cover" },
                React.createElement("div", { className: Video_st_css_1.default.overlay },
                    title && React.createElement("div", { "data-hook": "title", title: title, className: Video_st_css_1.default.title }, title),
                    playButton)))));
    };
    Video.displayName = 'Video';
    Video.propTypes = {
        /** Element ID */
        id: prop_types_1.string,
        /** A string or array with source of the video. For more information see this [page](https://wix.github.io/playable/video-source) */
        src: prop_types_1.oneOfType([
            prop_types_1.string,
            prop_types_1.array,
        ]),
        /** Width of video player */
        width: prop_types_1.oneOfType([
            prop_types_1.string,
            prop_types_1.number,
        ]),
        /** Height of video player */
        height: prop_types_1.oneOfType([
            prop_types_1.string,
            prop_types_1.number,
        ]),
        /** String that would be shown as title of video. */
        title: prop_types_1.string,
        /** React Component to appear for the "Play" button on poster */
        playButton: prop_types_1.node,
        /** Pass `true` to alow player fill all space of it container. */
        fillAllSpace: prop_types_1.bool,
        /** Loop video playback. */
        loop: prop_types_1.bool,
        /** Start value of volume for audio, `0..100`. */
        volume: prop_types_1.number,
        /** URL to image that would be used as logo on video */
        logoUrl: prop_types_1.string,
        /** Function that will be evaluated after click on logo */
        onLogoClick: prop_types_1.func,
        /** Pass true to set the logo to be visible no matter what */
        alwaysShowLogo: prop_types_1.bool,
        /** Pass false to hide controls */
        controls: prop_types_1.bool,
        /** Type of preloading. For more info check [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video) */
        preload: prop_types_1.oneOf(['auto', 'metadata', 'none']),
        /** URL to image that would be used as poster on overlay */
        poster: prop_types_1.string,
        /** Set to `true` or `false` to pause or play the media */
        playing: prop_types_1.bool,
        /** Mutes the player */
        muted: prop_types_1.bool,
        /** Called when media starts or resumes playing after pausing or buffering */
        onPlay: prop_types_1.func,
        /** Called when media is paused */
        onPause: prop_types_1.func,
        /** Called when media finishes playing */
        onEnd: prop_types_1.func,
        /** Use `playableRef` to call instance methods on the [playable](https://wix.github.io/playable/api). */
        playableRef: prop_types_1.func,
    };
    Video.defaultProps = {
        controls: true,
        onPlay: noop,
        onPause: noop,
        onEnd: noop,
        playableRef: noop,
    };
    return Video;
}(React.PureComponent));
exports.Video = Video;
//# sourceMappingURL=Video.js.map