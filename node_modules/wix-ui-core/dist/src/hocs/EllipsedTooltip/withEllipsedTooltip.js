"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var ReactDOM = require("react-dom");
var prop_types_1 = require("prop-types");
var shallowequal = require("shallowequal");
var Tooltip_1 = require("../../components/Tooltip");
var Text_st_css_1 = require("./Text.st.css");
var EllipsedTooltip_st_css_1 = require("./EllipsedTooltip.st.css");
var utils_1 = require("../utils");
var debounce = require("lodash/debounce");
var StateFullComponentWrap = /** @class */ (function (_super) {
    __extends(StateFullComponentWrap, _super);
    function StateFullComponentWrap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StateFullComponentWrap.prototype.render = function () {
        var _a = this.props, children = _a.children, props = __rest(_a, ["children"]);
        return React.cloneElement(children, props);
    };
    return StateFullComponentWrap;
}(React.Component));
var EllipsedTooltip = /** @class */ (function (_super) {
    __extends(EllipsedTooltip, _super);
    function EllipsedTooltip() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { isEllipsisActive: false };
        _this._updateEllipsisState = function () {
            _this.setState({
                isEllipsisActive: _this.textNode && _this.textNode.offsetWidth < _this.textNode.scrollWidth
            });
        };
        _this._debouncedUpdate = debounce(_this._updateEllipsisState, 100);
        return _this;
    }
    EllipsedTooltip.prototype.componentDidMount = function () {
        window.addEventListener('resize', this._debouncedUpdate);
        this._updateEllipsisState();
    };
    EllipsedTooltip.prototype.componentWillUnmount = function () {
        this._debouncedUpdate.cancel();
        window.removeEventListener('resize', this._debouncedUpdate);
    };
    EllipsedTooltip.prototype.componentDidUpdate = function (prevProps) {
        // if props changed, then we want to re-check node for ellipsis state
        // and we can not do such check in render, because we want to check already rendered node
        if (!shallowequal(prevProps, this.props)) {
            this._updateEllipsisState();
        }
    };
    EllipsedTooltip.prototype._renderText = function () {
        var _this = this;
        var component = this.props.component;
        return (React.createElement(StateFullComponentWrap, __assign({}, Text_st_css_1.default('root', {}, component.props), { style: { whiteSpace: 'nowrap' }, ref: function (n) { return _this.textNode = ReactDOM.findDOMNode(n); } }), component));
    };
    EllipsedTooltip.prototype.render = function () {
        if (!this.state.isEllipsisActive || !this.props.showTooltip) {
            return this._renderText();
        }
        return (React.createElement(Tooltip_1.Tooltip, __assign({}, EllipsedTooltip_st_css_1.default('root', {}, this.props), { appendTo: "scrollParent", content: React.createElement("div", null, this.props.component.props.children), showArrow: true }), this._renderText()));
    };
    EllipsedTooltip.propTypes = {
        component: prop_types_1.node.isRequired,
        showTooltip: prop_types_1.bool
    };
    EllipsedTooltip.defaultProps = { showTooltip: true };
    return EllipsedTooltip;
}(React.Component));
exports.withEllipsedTooltip = function (_a) {
    var showTooltip = (_a === void 0 ? {} : _a).showTooltip;
    return function (Comp) {
        var WrapperComponent = function (props) { return (React.createElement(EllipsedTooltip, __assign({}, props, { component: React.createElement(Comp, props), showTooltip: showTooltip, "data-hook": "ellipsed-tooltip-wrapper" }))); };
        WrapperComponent.displayName = utils_1.getDisplayName(Comp);
        return WrapperComponent;
    };
};
//# sourceMappingURL=withEllipsedTooltip.js.map