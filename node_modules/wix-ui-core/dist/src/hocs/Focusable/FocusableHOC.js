"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var hoist_non_react_methods_1 = require("hoist-non-react-methods");
var utils_1 = require("../utils");
var Focusable_st_css_1 = require("./Focusable.st.css");
/**
 * Singleton for managing current input method (keyboard or mouse).
 */
var inputMethod = new /** @class */ (function () {
    function class_1() {
        var _this = this;
        // Default is keyboard in case an element is focused programmatically.
        this.method = 'keyboard';
        this.subscribers = new Map();
        this.subscribe = function (target, callback) { return _this.subscribers.set(target, callback); };
        this.unsubscribe = function (target) { return _this.subscribers.delete(target); };
        /**
         * Is the current input method `keyboard`. if `false` is means it is `mouse`
         */
        this.isKeyboard = function () { return _this.method === 'keyboard'; };
        if (typeof window !== 'undefined') {
            window.addEventListener('mousedown', function () { return _this.setMethod('mouse'); });
            window.addEventListener('keydown', function () { return _this.setMethod('keyboard'); });
            // We need to listen on keyUp, in case a TAB is made from the browser's address-bar,
            // so the keyDown is not fired, only the keyUp.
            window.addEventListener('keyup', function () { return _this.setMethod('keyboard'); });
        }
    }
    class_1.prototype.setMethod = function (method) {
        if (method !== this.method) {
            this.method = method;
            this.subscribers.forEach(function (f) { return f(); });
        }
    };
    return class_1;
}())();
/*
 * TODO: Consider adding 'disabled' state to this HOC, since:
 * - When component is focused and then it becomes disabled, then the focus needs to be blured.
 *
 * TODO: Consider using [Recompose](https://github.com/acdlite/recompose/tree/master/src/packages/recompose) to do:
 *  - the static hoisting
 *  - set displayName
 */
exports.withFocusable = function (Component) {
    if (utils_1.isStatelessComponent(Component)) {
        throw new Error("FocusableHOC does not support stateless components. " + utils_1.getDisplayName(Component) + " is stateless.");
    }
    var FocusableHOC = /** @class */ (function (_super) {
        __extends(FocusableHOC, _super);
        function FocusableHOC() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.wrappedComponentRef = null;
            _this.focusedByMouse = false;
            _this.state = {
                focus: false,
                focusVisible: false
            };
            _this.onFocus = function () {
                _this.setState({ focus: true, focusVisible: inputMethod.isKeyboard() });
                inputMethod.subscribe(_this, function () {
                    if (inputMethod.isKeyboard()) {
                        _this.setState({ focusVisible: true });
                    }
                });
            };
            _this.onBlur = function () {
                inputMethod.unsubscribe(_this);
                _this.setState({ focus: false, focusVisible: false });
            };
            return _this;
        }
        FocusableHOC.prototype.componentWillUnmount = function () {
            inputMethod.unsubscribe(this);
        };
        FocusableHOC.prototype.componentDidUpdate = function (prevProps) {
            /*
              in case when button was focused and then become disabled,
              we need to trigger blur logic and remove all listers, as disabled button
              do not trigger onFocus and onBlur events
            */
            var isFocused = this.state.focus || this.state.focusVisible;
            var isBecomeDisabled = !prevProps.disabled && this.props.disabled;
            if (isFocused && isBecomeDisabled) {
                this.onBlur();
            }
        };
        FocusableHOC.prototype.render = function () {
            var _this = this;
            return (React.createElement(Component, __assign({ ref: function (ref) { return _this.wrappedComponentRef = ref; } }, this.props, { focusableOnFocus: this.onFocus, focusableOnBlur: this.onBlur }, Focusable_st_css_1.default('root', { focus: this.state.focus, 'focus-visible': this.state.focusVisible }, this.props))));
        };
        FocusableHOC.displayName = utils_1.wrapDisplayName(Component, 'WithFocusable');
        FocusableHOC.propTypes = Component.propTypes;
        FocusableHOC.defaultProps = Component.defaultProps;
        return FocusableHOC;
    }(React.Component));
    return hoist_non_react_methods_1.default(FocusableHOC, Component, { delegateTo: function (c) { return c.wrappedComponentRef; }, hoistStatics: true });
};
//# sourceMappingURL=FocusableHOC.js.map