"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var enzyme_1 = require("enzyme");
var FocusableHOC_driver_1 = require("./FocusableHOC.driver");
describe('FocusableHOC', function () {
    var render = function (Comp) { return enzyme_1.mount(Comp, { attachTo: document.createElement('div') }); };
    describe('Pure component HOC', function () {
        it('should render the wrapped component', function () {
            var wrapper = render(React.createElement(FocusableHOC_driver_1.WithFocusableComp, null));
            expect(wrapper.children().instance()).toBeInstanceOf(FocusableHOC_driver_1.PureChildComponent);
        });
        describe('hoisting', function () {
            it('should hoist static methods', function () {
                expect(FocusableHOC_driver_1.WithFocusableComp.staticMethod()).toEqual('staticMethod');
            });
            it('should hoist static variables', function () {
                expect(FocusableHOC_driver_1.WithFocusableComp.staticVariable).toEqual('staticVariable');
            });
        });
    });
    describe('Focusable', function () {
        var expectKeyboardFocused = function (driver, msg) {
            var prefix = msg ? msg + " - " : '';
            expect(driver.hasFocusState()).toBe(true);
            expect(driver.hasFocusVisibleState()).toBe(true);
        };
        var expectNotFocused = function (driver, msg) {
            var prefix = msg ? msg + " - " : '';
            expect(driver.hasFocusState()).toBe(false);
            expect(driver.hasFocusVisibleState()).toBe(false);
        };
        var expectMouseFocused = function (driver, msg) {
            var prefix = msg ? msg + " - " : '';
            expect(driver.hasFocusState()).toBe(true);
            expect(driver.hasFocusVisibleState()).toBe(false);
        };
        var WithFocusableComp2;
        var focusableModule;
        beforeEach(function () {
            // Reseting modules, in order to reset the FocusableHOC.InputMethod.method state.
            if (typeof jest.resetModules === 'function') {
                jest.resetModules();
            }
            focusableModule = require('./FocusableHOC');
            WithFocusableComp2 = focusableModule.withFocusable(FocusableHOC_driver_1.PureChildComponent);
            // TODO: find a way to reset the eventHandlers which are added to the window.
        });
        it('should not have focus nor focus-visible [given] initial render', function () {
            var driver = FocusableHOC_driver_1.createDriver(React.createElement(WithFocusableComp2, null));
            expectNotFocused(driver);
        });
        it('should have focus and focus-visible [when] focused programatically', function () {
            var driver = FocusableHOC_driver_1.createDriver(React.createElement(WithFocusableComp2, null));
            driver.focus();
            // Default input is keyboard
            expectKeyboardFocused(driver, 'after focus');
        });
        it('should have focus and focus-visible [when] tabbed in', function () {
            var driver = FocusableHOC_driver_1.createDriver(React.createElement(WithFocusableComp2, null));
            driver.tabIn();
            expectKeyboardFocused(driver, 'after focus');
        });
        it('should have focus and focus-visible [when] tabbed in withot keyDown', function () {
            // This test case checks a scenario when the focus is on the browser's
            // url input, and we press tab. The keyDown is not fired.
            var driver = FocusableHOC_driver_1.createDriver(React.createElement(WithFocusableComp2, null));
            driver.focus();
            driver.fireKeyUp();
            expectKeyboardFocused(driver, 'after focus');
        });
        it('should not have focus nor focus-visible [when] blured programatically [given] keyboard focused', function () {
            var driver = FocusableHOC_driver_1.createDriver(React.createElement(WithFocusableComp2, null));
            driver.tabIn();
            expectKeyboardFocused(driver, 'after focus');
            driver.blur();
            expectNotFocused(driver, 'after blur');
        });
        it('should have focus but not focus-visible [when] clicked', function () {
            var driver = FocusableHOC_driver_1.createDriver(React.createElement(WithFocusableComp2, null));
            driver.click();
            expectMouseFocused(driver, 'after click');
        });
        /**
         * This test checks that the InpurMethod.method state is updated to `keyboard` after
         * is was set to `mouse`.
         */
        it('should have focus and focus-visible [when] focused [given] mouseDown and blur', function () {
            var driver = FocusableHOC_driver_1.createDriver(React.createElement(WithFocusableComp2, null));
            driver.click();
            expectMouseFocused(driver, 'after click');
            driver.blur();
            expectNotFocused(driver, 'after blur');
            driver.tabIn();
            expectKeyboardFocused(driver, 'after focus');
        });
        it('should not be focused [when] tabbed out [given] focused by mouse', function () {
            var driver = FocusableHOC_driver_1.createDriver(React.createElement(FocusableHOC_driver_1.WithFocusableComp, null));
            driver.click();
            expectMouseFocused(driver, 'after click');
            driver.tabOut();
            expectNotFocused(driver, 'after tab');
        });
        it('should have focus and focus-visible, when: any keyboard key pressed [given] focused by mouse', function () {
            var driver = FocusableHOC_driver_1.createDriver(React.createElement(FocusableHOC_driver_1.WithFocusableComp, null));
            driver.click();
            expectMouseFocused(driver, 'after click');
            driver.fireKeyDown();
            expectKeyboardFocused(driver, 'after pressing space');
        });
    });
});
//# sourceMappingURL=FocusableHOC.spec.js.map