"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var _1 = require("./");
var stylableUtils_1 = require("./stylableUtils");
describe('Utils', function () {
    describe('buildChildrenObject', function () {
        it('should return an empty object when called with null children and null initial object', function () {
            var children = null;
            var initialObject = null;
            var childrenObject = _1.buildChildrenObject(children, initialObject);
            expect(childrenObject).toEqual({});
        });
        it('should return an empty object when called with one child without display name', function () {
            var children = React.createElement("div", null);
            var childrenObject = _1.buildChildrenObject(children, {});
            expect(childrenObject).toEqual({});
        });
        it('should return a children object when rendered with component', function () {
            var displayName = 'componentName';
            var Component = _1.createComponentThatRendersItsChildren(displayName);
            var children = (React.createElement(Component, null,
                React.createElement("div", null)));
            var childrenObject = _1.buildChildrenObject(children, {});
            expect(childrenObject[displayName].type.displayName).toEqual(displayName);
        });
        it('should return a children object when rendered with component with namespace', function () {
            var displayName = 'a.b.c.b.componentName';
            var displayNameWithoutNamespace = 'componentName';
            var Component = _1.createComponentThatRendersItsChildren(displayName);
            var children = (React.createElement(Component, null,
                React.createElement("div", null)));
            var childrenObject = _1.buildChildrenObject(children, {});
            expect(childrenObject[displayNameWithoutNamespace].type.displayName).toEqual(displayName);
        });
        it('should return a children object when rendered with multitple component', function () {
            var firstComponentDisplayName = 'a.b.c.b.firstComponentName';
            var firstComponentDisplayNameWithoutNamespace = 'firstComponentName';
            var FirstComponent = _1.createComponentThatRendersItsChildren(firstComponentDisplayName);
            var secondComponentDisplayName = 'a.b.c.b.secondComponentName';
            var secondComponentDisplayNameWithoutNamespace = 'secondComponentName';
            var SecondComponent = _1.createComponentThatRendersItsChildren(secondComponentDisplayName);
            var children = [];
            children.push(React.createElement(FirstComponent, null,
                React.createElement("div", null)));
            children.push(React.createElement(SecondComponent, null,
                React.createElement("div", null)));
            var childrenObject = _1.buildChildrenObject(children, {});
            expect(childrenObject[firstComponentDisplayNameWithoutNamespace].type.displayName)
                .toEqual(firstComponentDisplayName);
            expect(childrenObject[secondComponentDisplayNameWithoutNamespace].type.displayName)
                .toEqual(secondComponentDisplayName);
        });
    });
    describe('createComponentThatRendersItsChildren', function () {
        it('should generate stateless component', function () {
            var displayName = 'componentName';
            var component = _1.createComponentThatRendersItsChildren(displayName);
            expect(component.displayName).toEqual(displayName);
        });
        it('should return element children when called', function () {
            var displayName = 'componentName';
            var component = _1.createComponentThatRendersItsChildren(displayName);
            var props = { children: { prop: 'value' } };
            expect(component(props)).toEqual(props.children);
        });
    });
    describe('node styles attachment', function () {
        var attributeName = 'data-att';
        var classA = 'CN';
        var classB = 'NC';
        var node;
        var stylesObj;
        beforeEach(function () {
            node = document.createElement('div');
            stylesObj = (_a = {
                    className: classA
                },
                _a[attributeName] = 'ribute',
                _a);
            var _a;
        });
        describe('attach', function () {
            it('should attach styles to node', function () {
                stylableUtils_1.attachStylesToNode(node, stylesObj);
                expect(node.classList.contains(stylesObj.className)).toBeTruthy();
                expect(node.getAttribute(attributeName)).toBe(stylesObj[attributeName]);
            });
            it('should attach more than one classname', function () {
                stylesObj.className += " " + classB;
                stylableUtils_1.attachStylesToNode(node, stylesObj);
                expect(node.classList.contains(classA)).toBeTruthy();
                expect(node.classList.contains(classB)).toBeTruthy();
            });
        });
        describe('remove', function () {
            it('should remove styles from node', function () {
                node.className = stylesObj.className;
                node.setAttribute(attributeName, stylesObj[attributeName]);
                stylableUtils_1.detachStylesFromNode(node, stylesObj);
                expect(node.classList.contains(stylesObj.className)).toBeFalsy();
                expect(node.getAttribute(attributeName)).not.toBe(stylesObj[attributeName]);
            });
            it('should remove more than one classname', function () {
                stylesObj.className += " " + classB;
                node.setAttribute(attributeName, stylesObj[attributeName]);
                stylableUtils_1.detachStylesFromNode(node, stylesObj);
                expect(node.classList.contains(classA)).toBeFalsy();
                expect(node.classList.contains(classB)).toBeFalsy();
            });
        });
    });
});
//# sourceMappingURL=utils.spec.js.map