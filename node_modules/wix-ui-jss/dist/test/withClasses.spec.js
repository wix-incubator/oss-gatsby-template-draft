"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var domStyleRenderer_1 = require("../src/domStyleRenderer");
var React = require("react");
var enzyme_1 = require("enzyme");
var _1 = require("../src/");
var styles = function (theme) {
    if (theme === void 0) { theme = {}; }
    return ({
        someClass: {
            color: theme.color || 'green'
        }
    });
};
var Component = function (_a) {
    var classes = _a.classes, children = _a.children;
    return React.createElement("div", { className: classes.someClass }, children);
};
var StyledComponent = _1.withClasses(Component, styles);
var render = function (Comp) { return enzyme_1.mount(Comp, { attachTo: document.createElement('div') }); };
var getJssStyleElement = function () {
    var styleElement = document.querySelector('style');
    return styleElement && styleElement.hasAttribute('data-jss') ? styleElement : undefined;
};
describe('withClasses', function () {
    var wrapper;
    afterEach(function () { return wrapper.detach(); });
    it('should pass classes prop to the rendered component', function () {
        wrapper = render(React.createElement(StyledComponent, null));
        expect(wrapper.html()).toBe('<div class="someClass"></div>');
    });
    it('should preserve the component original props', function () {
        wrapper = render(React.createElement(StyledComponent, null, "Hello"));
        expect(wrapper.prop('children')).toBe('Hello');
    });
    it('should set an id for the component and map it to the style element in the dom', function () {
        wrapper = render(React.createElement(StyledComponent, null));
        expect(wrapper.instance().id).toBeDefined();
        expect(domStyleRenderer_1.sheetMapper[wrapper.first().instance().id].styleElement).toBe(getJssStyleElement());
    });
    it('should inject the correct style tag to the DOM', function () {
        wrapper = render(React.createElement(StyledComponent, null));
        var element = wrapper.getDOMNode();
        expect(window.getComputedStyle(element).color).toBe('green');
    });
    it('should calculate the style with respect to the theme prop', function () {
        wrapper = render(React.createElement(StyledComponent, { theme: { color: 'blue' } }));
        var element = wrapper.getDOMNode();
        expect(window.getComputedStyle(element).color).toBe('blue');
    });
    it('should update the style element when the theme changes, and remove the old style element', function () {
        wrapper = render(React.createElement(StyledComponent, { theme: { color: 'blue' } }));
        var element = wrapper.getDOMNode();
        var styleElementBefore = window.getComputedStyle(element);
        var numberOfDomStyleElements = document.querySelectorAll('style').length;
        wrapper.setProps({ theme: { color: 'yellow' } });
        var styleElementAfter = window.getComputedStyle(element);
        var updatedNumberOfDomStyleElements = document.querySelectorAll('style').length;
        expect(numberOfDomStyleElements).toBe(updatedNumberOfDomStyleElements);
        expect(styleElementBefore).not.toBe(styleElementAfter);
        expect(styleElementAfter.color).toBe('yellow');
    });
    it('should not update the style tag when the component re-renders not due to a theme changes', function () {
        wrapper = render(React.createElement(StyledComponent, { theme: { color: 'blue' } }));
        var element = wrapper.getDOMNode();
        var styleElementBefore = domStyleRenderer_1.sheetMapper[wrapper.getDOMNode().id];
        wrapper.setProps();
        var styleElementAfter = domStyleRenderer_1.sheetMapper[wrapper.getDOMNode().id];
        expect(styleElementBefore).toBe(styleElementAfter);
        expect(window.getComputedStyle(element).color).toBe('blue');
    });
});
it('should remove the style tag after component unmounts', function () {
    var wrapper = render(React.createElement(StyledComponent, null));
    expect(getJssStyleElement()).toBeDefined();
    wrapper.detach();
    expect(getJssStyleElement()).toBeUndefined();
});
//# sourceMappingURL=withClasses.spec.js.map