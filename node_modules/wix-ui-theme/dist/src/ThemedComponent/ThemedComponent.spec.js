"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var enzyme_1 = require("enzyme");
var _1 = require("./");
describe('ThemedComponent', function () {
    var themeObject = { color: 'green' };
    var expectedRender = '<div>green</div>';
    describe('theme is a function', function () {
        it('should pass the calculated theme object to the wrapped component', function () {
            var Component = function (_a) {
                var theme = _a.theme;
                return React.createElement("div", null, theme.color);
            };
            var wrapper = enzyme_1.mount(React.createElement(_1.ThemedComponent, { theme: function () { return themeObject; } },
                React.createElement(Component, null)));
            expect(wrapper.html()).toBe(expectedRender);
        });
        it('should keep the original props of the wrapped component', function () {
            var Component = function (_a) {
                var theme = _a.theme, anotherProp = _a.anotherProp;
                return React.createElement("div", null, anotherProp);
            };
            var wrapper = enzyme_1.mount(React.createElement(_1.ThemedComponent, { theme: function () { return themeObject; } },
                React.createElement(Component, { anotherProp: "Hello" })));
            expect(wrapper.html()).toBe('<div>Hello</div>');
        });
        it('should calculate the theme with the additional props that was given to the wrapper', function () {
            var Component = function (_a) {
                var theme = _a.theme;
                return React.createElement("div", null, theme.color);
            };
            var wrapper = enzyme_1.mount(React.createElement(_1.ThemedComponent, { theme: function (_a) {
                    var color = _a.color;
                    return ({ color: color });
                }, color: "green" },
                React.createElement(Component, null)));
            expect(wrapper.html()).toBe(expectedRender);
        });
        it('should re-calculate the theme when the additional prop for the wrapper changes', function () {
            var Component = function (_a) {
                var theme = _a.theme;
                return React.createElement("div", null, theme.color);
            };
            var wrapper = enzyme_1.mount(React.createElement(_1.ThemedComponent, { theme: function (_a) {
                    var color = _a.color;
                    return ({ color: color });
                }, color: "green" },
                React.createElement(Component, null)));
            wrapper.setProps({ color: 'red' });
            expect(wrapper.html()).toBe('<div>red</div>');
        });
        it('should not re-calculate the theme when the component get\'s updated but not due to a theme dependant props change', function () {
            var Component = function (_a) {
                var color = _a.color;
                return React.createElement("div", null, color);
            };
            var mockedTheme = jest.fn();
            var WrappedComponent = function (_a) {
                var theme = _a.theme, color = _a.color;
                return (React.createElement(_1.ThemedComponent, { theme: mockedTheme },
                    React.createElement(Component, { color: color })));
            };
            var App = /** @class */ (function (_super) {
                __extends(App, _super);
                function App(props) {
                    var _this = _super.call(this, props) || this;
                    _this.state = { color: 'green', theme: mockedTheme };
                    return _this;
                }
                App.prototype.render = function () {
                    return React.createElement(WrappedComponent, { theme: this.state.theme, color: this.state.color });
                };
                return App;
            }(React.Component));
            var wrapper = enzyme_1.mount(React.createElement(App, null));
            wrapper.setState({ color: 'red' });
            expect(wrapper.html()).toBe('<div>red</div>');
            //only the constructor called the theme function
            expect(mockedTheme.mock.calls.length).toBe(1);
        });
    });
    describe('theme is an object', function () {
        it('should pass the theme object to the wrapped component', function () {
            var Component = function (_a) {
                var theme = _a.theme;
                return React.createElement("div", null, theme.color);
            };
            var wrapper = enzyme_1.mount(React.createElement(_1.ThemedComponent, { theme: themeObject },
                React.createElement(Component, null)));
            expect(wrapper.html()).toBe(expectedRender);
        });
        it('should update the state with the new theme when the component get\'s a new theme object as a prop', function () {
            var Component = function (_a) {
                var theme = _a.theme;
                return React.createElement("div", null, theme.color);
            };
            var wrapper = enzyme_1.mount(React.createElement(_1.ThemedComponent, { theme: { color: 'green' } },
                React.createElement(Component, null)));
            wrapper.setProps({ theme: { color: 'red' } });
            expect(wrapper.html()).toBe('<div>red</div>');
            expect(wrapper.state().calculatedTheme).toEqual({ color: 'red' });
        });
    });
});
//# sourceMappingURL=ThemedComponent.spec.js.map